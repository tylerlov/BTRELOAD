using UnityEngine;using System.Collections;using System.Collections.Generic;namespace SelectedEffectWireframe{	public class Wireframe : MonoBehaviour	{		public enum ETriggerMethod { MouseMove = 0, MousePress };		public enum EStyle { CullBack = 0, CullOff, DoubleSide, Overlay, Stylized };		[Header("Trigger Method")]		public ETriggerMethod m_TriggerMethod = ETriggerMethod.MouseMove;		public bool m_Persistent = false;		[Header("Style")]		public EStyle m_Style = EStyle.CullBack;		public Material m_MatBasic;		public Material m_MatOverlay;		public Material m_MatStylized;		[Header("Baisc")]		[Range(0.01f, 2f)] public float m_Width = 0.5f;		public Color m_Color = Color.green;		public Color m_FrontColor = Color.green;		public Color m_BackColor = Color.grey;		[Header("Stylized")]		public bool m_EnableSqueeze = true;		public bool m_EnableDash = false;		[Range(0.1f, 0.9f)] public float m_StylizedWireframeSqueezeMin = 0.2f;		[Range(0.1f, 0.9f)] public float m_StylizedWireframeSqueezeMax = 0.8f;		[Range(1f, 8f)] public float m_StylizedWireframeDashRepeats = 6f;		[Range(0.1f, 2f)] public float m_StylizedWireframeDashLength = 0.6f;		[Header("Internal")]		Renderer m_Rd;		Material[] m_BackupMaterials;		MeshFilter m_SelfMeshFilter;		public Mesh m_MeshBackup;		public Mesh m_MeshNew;		public bool m_IsMouseOn = false;		public bool m_IsFxEnable = false;		void Awake()		{			m_Rd = GetComponent<Renderer>();			// cache all original materials			Material[] mats = m_Rd.materials;			int len = mats.Length;			m_BackupMaterials = new Material[len];			for (int i = 0; i < len; i++)				m_BackupMaterials[i] = mats[i];			// generate wireframe mesh vertex			m_SelfMeshFilter = GetComponent<MeshFilter>();			m_MeshBackup = m_SelfMeshFilter.mesh;   // backup original mesh			// generate vertices data with barycentric coordinate			Vector3[] pos = m_SelfMeshFilter.mesh.vertices;			Vector3[] nor = m_SelfMeshFilter.mesh.normals;			Vector4[] tan = m_SelfMeshFilter.mesh.tangents;			Vector2[] tex = m_SelfMeshFilter.mesh.uv;			int[] tri = m_SelfMeshFilter.mesh.triangles;			List<Vector3> wireframePos = new List<Vector3>();			List<Vector3> wireframeNor = new List<Vector3>();			List<Vector4> wireframeTan = new List<Vector4>();			List<Vector2> wireframeTex = new List<Vector2>();			List<Color> wireframeBc = new List<Color>();			List<int> wireframeTriangle = new List<int>();			for (int i = 0; i < tri.Length; i += 3)			{				int ind1 = tri[i + 0];				int ind2 = tri[i + 1];				int ind3 = tri[i + 2];				wireframePos.Add(pos[ind1]);				wireframePos.Add(pos[ind2]);				wireframePos.Add(pos[ind3]);				wireframeNor.Add(nor[ind1]);				wireframeNor.Add(nor[ind2]);				wireframeNor.Add(nor[ind3]);				wireframeTan.Add(tan[ind1]);				wireframeTan.Add(tan[ind2]);				wireframeTan.Add(tan[ind3]);				wireframeTex.Add(tex[ind1]);				wireframeTex.Add(tex[ind2]);				wireframeTex.Add(tex[ind3]);				wireframeBc.Add(new Color(1, 0, 0));				wireframeBc.Add(new Color(0, 1, 0));				wireframeBc.Add(new Color(0, 0, 1));				wireframeTriangle.Add(i + 0);				wireframeTriangle.Add(i + 1);				wireframeTriangle.Add(i + 2);			}			// create the wireframe mesh			m_MeshNew = new Mesh();			m_MeshNew.name = m_SelfMeshFilter.mesh.name + "_Wireframe";			m_MeshNew.vertices = wireframePos.ToArray();			m_MeshNew.normals = wireframeNor.ToArray();			m_MeshNew.tangents = wireframeTan.ToArray();			m_MeshNew.uv = wireframeTex.ToArray();			m_MeshNew.colors = wireframeBc.ToArray();			m_MeshNew.triangles = wireframeTriangle.ToArray();		}		void UpdateSelfParameters()		{			if (!m_IsFxEnable)				return;			ApplyWireframeMaterial();			Material[] mats = m_Rd.materials;			for (int i = 0; i < mats.Length; i++)			{				if (m_EnableSqueeze)					mats[i].EnableKeyword("WIREFRAME_SQUEEZE");				else					mats[i].DisableKeyword("WIREFRAME_SQUEEZE");				if (m_EnableDash)					mats[i].EnableKeyword("WIREFRAME_DASH");				else					mats[i].DisableKeyword("WIREFRAME_DASH");				if (m_Style == EStyle.DoubleSide)					mats[i].EnableKeyword("ENABLE_DOUBLE_SIDE_COLOR");				else					mats[i].DisableKeyword("ENABLE_DOUBLE_SIDE_COLOR");				if (mats[i].HasProperty("_MainTex"))				{					mats[i].SetTexture("_MainTex", m_BackupMaterials[i].GetTexture("_MainTex"));					mats[i].SetTextureOffset("_MainTex", m_BackupMaterials[i].GetTextureOffset("_MainTex"));					mats[i].SetTextureScale("_MainTex", m_BackupMaterials[i].GetTextureScale("_MainTex"));				}				mats[i].SetFloat("_LineWidth", 0.91f - m_Width);				mats[i].SetColor("_LineColor", m_Color);				mats[i].SetColor("_LineFrontColor", m_FrontColor);				mats[i].SetColor("_LineBackColor", m_BackColor);				mats[i].SetFloat("_StylizedWireframeThickness", m_Width);				mats[i].SetColor("_StylizedWireframeColor", m_Color);				mats[i].SetFloat("_StylizedWireframeSqueezeMin", m_StylizedWireframeSqueezeMin);				mats[i].SetFloat("_StylizedWireframeSqueezeMax", m_StylizedWireframeSqueezeMax);				mats[i].SetFloat("_StylizedWireframeDashRepeats", m_StylizedWireframeDashRepeats);				mats[i].SetFloat("_StylizedWireframeDashLength", m_StylizedWireframeDashLength);				if (m_Style == EStyle.CullBack || m_Style == EStyle.Overlay)					mats[i].SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Back);				if (m_Style == EStyle.CullOff || m_Style == EStyle.DoubleSide)					mats[i].SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Off);			}		}		void ApplyWireframeMaterial()		{			int len = m_Rd.materials.Length;			Material[] mats = new Material[len];			for (int i = 0; i < len; i++)			{				if (m_Style == EStyle.CullBack || m_Style == EStyle.CullOff || m_Style == EStyle.DoubleSide)					mats[i] = m_MatBasic;				else if (m_Style == EStyle.Overlay)					mats[i] = m_MatOverlay;				else					mats[i] = m_MatStylized;			}			m_Rd.materials = mats;		}		void FxEnable(bool enable)		{			if (enable)			{				ApplyWireframeMaterial();   // apply wireframe material				m_SelfMeshFilter.mesh = m_MeshNew;   // apply wireframe mesh			}			else			{				m_Rd.materials = m_BackupMaterials;				m_SelfMeshFilter.mesh = m_MeshBackup;			}			m_IsFxEnable = enable;		}		void OnMouseEnter()		{			if (m_TriggerMethod == ETriggerMethod.MouseMove)				FxEnable(true);			m_IsMouseOn = true;		}		void OnMouseExit()		{			if (!m_Persistent)				FxEnable(false);			m_IsMouseOn = false;		}		void Update()		{			if (m_TriggerMethod == ETriggerMethod.MousePress)			{				bool on = m_IsMouseOn && Input.GetMouseButton(1);				if (on)					FxEnable(true);				else					FxEnable(false);			}			UpdateSelfParameters();		}	}}