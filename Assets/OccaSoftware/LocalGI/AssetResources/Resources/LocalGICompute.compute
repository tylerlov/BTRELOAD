#pragma kernel ComputeScreenSpaceLocalGI

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareOpaqueTexture.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"
#include "LocalGI.hlsl"

// This line must be included to ensure LoadSceneNormals automatically unpacks Accurate G-Buffer Normals
#pragma multi_compile _ _GBUFFER_NORMALS_OCT
#pragma multi_compile _ _LGI_USE_GBUFFER

Texture2D<float4> _GBuffer0;
Texture2D<float3> _ScreenTexture;

RWTexture2D<float3> _GlobalIlluminationTarget;

SamplerState my_point_clamp_sampler;
float2 _ScreenSizePx;


#define _ThreadSize 8


float2 GetUV (uint3 id) 
{
	return (id.xy + 0.5) / _ScreenSizePx;
}


[numthreads(_ThreadSize, _ThreadSize,1)]
void ComputeScreenSpaceLocalGI (uint3 id : SV_DispatchThreadID)
{
    float rawDepth = LoadSceneDepth(id.xy);
    float3 sceneColor = _ScreenTexture.Load(uint3(id.xy,0)).rgb;
    
    if(Linear01Depth(rawDepth, _ZBufferParams) > 0.999999)
    {
        _GlobalIlluminationTarget[id.xy] = sceneColor;
        return;
    }
    
    
    
    float2 uv = GetUV(id);

    #if defined(_LGI_USE_GBUFFER)
    float3 albedo = _GBuffer0.SampleLevel(my_point_clamp_sampler, uv, 0).rgb;
    #else
    float3 albedo = _ScreenTexture.SampleLevel(my_point_clamp_sampler, uv, 0).rgb;
    #endif

    float3 worldPosition = ComputeWorldSpacePosition(uv, rawDepth, UNITY_MATRIX_I_VP);
    float3 normals = LoadSceneNormals(id.xy);
    float3 irradiance;
    GetLocalGI(normals, worldPosition, irradiance);
    
    _GlobalIlluminationTarget[id.xy] = sceneColor + irradiance * albedo;
}
