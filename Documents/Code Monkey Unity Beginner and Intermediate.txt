hello and welcome I'm your code monkey
and here is a free complete course on
making a game from start to finish if
you've always wanted to learn how to
make a game or if you already know the
basics but want to see how to organize a
more complex project then this video is
for you it's perfect for both beginners
and more intermediate users this is a
completely free course video but it has
the same level of quality as my paid
courses or my Steam games you can
download the project files to follow
along or inspect the final game you can
even play the final game directly on
Steam we're going to start complely from
scratch and build a really awesome game
with tons of systems and mechanics
building this design requires working
with lots of unity and C features so
this is a really awesome project for you
to learn after following this course and
learning all of these techniques you
will be able to build all kinds of games
in all kinds of genres this is going to
involve learning about the basics of
unity and C learning how to make a
character controller physics rcast learn
all about C interface and events using
script M objects handling UI the new
input system and lots more very
importantly everything that we're going
to do here is going to be focused on
writing good easy to understand clean
code meaning that I will not be teaching
you bad practices that some beginner
tutorials teach the code that we're
going to write here is production
quality code this is not a throwaway
demo the quality of the code and the
structure of the game that we're going
to build is on the same level of quality
as my own Steam games as you can see
from the video link this is indeed a
complete very thorough course so don't
try to watch this whole thing in one
setting take your time take take it slow
and just focus on learning there are
chapters for every single lecture in the
video here's a quick overview of the
entire course all the steps that we're
going to take to reach a final polished
game so first of all we're going to
start compling from scratch by selecting
a Unity version and creating a brand new
project with that new project we will
then learn all about the basics of the
unity interface and setup a layout then
the other important part is Visual
Studio which is where we're going to be
writing all of our code after that comes
an extremely important lecture all about
coding style and naming rules like I
said the code in this course is on the
same level of quality as my Steam games
so having proper naming rules and good
coell is Paramount next we're going to
download and import all the assets that
we're going to use in the course
everything is included so you can follow
along with every step of the way with
the as important we're going to set up
some quick post processing just to make
the game look good then for our first
piece of logic we're going to make a
simple character controller with that
logic working we will then Implement a
proper character visual with the
included assets next we're going to
learn the basics of animation and the
animator component and with that we're
going to make our player really come Al
with some simple but really nice
animations then we're going to install
the cin machine package this isn't
actually used too much in this course
but I still wanted to include it because
it is such a useful tool so I do want
you to know about it after that comes
another extremely extremely important
lecture with regards to writing some
good clean code we're going to do a nice
refactor to replace the Legacy input
manager with the brand new input system
learning how to refactor is an extremely
important and very valuable skill that
will massively improve the quality of
your code with that done we're going to
implement some nice Collision detection
to make sure our character doesn't walk
through walls next we're going to create
the very first kitchen counter and make
a script to handle how to interact with
it then we're going to learn all about C
events and create a proper interact
input next we're going to build a
selected counter visual which will
require us to learn about the extreme
useful Singleton pattern with the
counter working we're going to start
working on the kitchen objects
themselves so these are going to be the
ingredients and the plates we're going
to use script wall objects to Define all
of the types then a very important part
of our design is each kitchen object
will have to be place somewhere so we're
going to take some time to really think
about the best way to achieve that all
while writing some good clean code next
we're going to enable the player to pick
up an object in doing so we're going to
learn about C interfaces then we're
going to make a container counter this
is from where we can spawn new objects
with that we will enable the player to
pick up objects and drop them anywhere
where they're space then we're going to
make the cutting counter this one
enables the player to cut an ingredient
into slices so to do that we're going to
make an alternate interact action and
for handling the cutting we're going to
once again use script M objects to
define a proper cutting recipe then
we're going to learn about a really
awesome Unity feature World canvases and
use that to display a nice progress Bar
for our cutting progress after that is a
quick lecture just going to make a very
useful generic script to make any object
look at the camera next for another
counter we're going to build a trash bin
this is where the player can drop
objects to destroy them then the stove
counter this one is going to be quite a
bit complex we're going to create
recipes for cooking and for burning
we're going to learn how to make a basic
state machine and handle timers next
we're going to make the plates counter
this is a simple counter that just
spawns a bunch of plates after that
we're going to make some custom Logic on
the plate to be able to hold other
objects with that logic working we're
going to build a complete visual for all
the objects that can exist on the plate
then make a nice UI element on the plate
itself to showcase the icons of what
exactly is on that plate afterwards
we're going to make the very last
counter the delivery counter this is
where we drop the completed plates and
in this lecture we're also going to
learn about the unity Shader graph and
make a quick simple custom Shader
then we're going to build the delivery
manager class that generates the recipes
that the customers are requesting next
we're going to build a UI to showcase
the wedding recipes after that comes
something pretty crucial we're going to
add some music and then add some sound
effects for all kinds of game actions
with that the game will be almost done
so next we're going to build a proper
game start and a game end then make a
simple main menu and handle scene
loading after that handle creating a
basic pause window then make an options
menu enable the player to modify the
audio levels and rebind keys after that
we're going to enable menu navigation
with a controller and in the end as
usual comes a Polish stage so we're
going to add all kinds of small tweaks
and effects to make the game feel really
great like I've said many times polish
is what separates good games from great
games after all of that we will have our
final completed project so as you can
see you will learn about tons of Topics
by following this course also let me
point out one of the reasons why I chose
this specific design is because my next
free course won't be on taking the game
that we're going to build here and make
it multiplayer so if you've ever wanted
to make multiplayer games then that
course will be excellent for you
definitely take your time following this
course the multiplayer free course
should hopefully be out next month or if
you're watching this in the future check
the links in the description although
that multiplayer video won't be starting
from where this course ends so
definitely make sure you watch this one
now if you're new to the channel then
welcome and here's a bit about me and my
credentials or why you should listen to
what I have to teach
my name is Hugo and I've been running
this Code Monkey YouTube channel for 5
years now in total almost 700 videos on
all kinds of topics including tons of
tutorials sharing my knowledge to help
you on your Game Dev Journey I'm also a
professional indie game developer making
games for over 10 years with eight
successful Games published on Steam so
what I'm teaching here is based on a lot
of years of experience making a lot of
games just like with my paid courses I'm
always going to be in the comments
answering questions so if you get stuck
at a particular point or need extra
clarification on something go ahead post
a comment and I'll do my best to help do
make sure you include a time stamp of
what you're referring to I will also be
updating the pin comment with any
frequently asked questions that I see so
actually right now go ahead pause the
video and scroll down a bit just to look
at that comment since on YouTube I
cannot update the video after it's
published I will be updating that
comment over the next months and years
with anything that comes up also I've
been running this channel for 5 years
and in that time I've made almost 700
videos so there's lots of topics that
I've covered separately in more detail
all of those videos are linked in the
description throughout this course I
will be focused on building this
specific game using whatever it takes to
build it meaning for example when we get
to using C events I will teach the
basics about how they work in order to
achieve what we want to build but if you
then want to learn about C events in
more detail definitely go watch a
dedicated video and I also made a page
on my website for this course it
contains a link to download all of the
project assets you can also download the
complete project files for every single
lecture so if you get stuck at any point
you can download the code at that
lecture and compare with your own
there's also references to all of the
videos and I will also be including
frequently ask questions for each
lecture so definitely keep that page
open in a second tab as you follow along
this course now this free course Took a
ton of work to make so I really hope you
find this video helpful go ahead and hit
the like button if it helps you it's a
small thing but it generally does help
this video on the YouTube algorithm
making this course with a ton of work
and by making it complely free it means
it will obviously never make as as much
money as if I had just made the a paid
course I'm perfectly okay with that
decision with the hopes that by making
it free it will reach and help many more
people I'm also a big believer that
education should be free so if you can't
afford one of my paid courses like if
you're just a kid or going through a
rough time I still want you to have
access to high quality education so you
can achieve your Game Dev dreams one
easy way you can help me for free is
simply by liking this video subscribing
to the channel and just watching this
course that will hopefully help push
this video on the YouTube algorithm and
tempet reach many more people another
free way to support what I do is I'm
currently working on my next team game
called total warm Liberation you can
wish list the game on Steam wish list
matter a lot for steam visibility so
just by doing that you will be helping
me and just in case you can't afford it
and you find this free course useful you
can also support what I do in a few
other ways I spent a bunch of money
making this course I heard an artist for
the 3D assets so that I head right to
the tribum so that you can download and
follow along same thing for the music
and sound effects the logo and the cost
to upload the game to seam so I would
like to at least not lose money on this
project hopefully there's enough of you
who can afford to help me so that I can
at least break even and for one way you
can support is I added this exact same
course on my website as a regular paid
course although I want to be very very
clear there is absolutely no difference
between this free video and the paid
course there is absolutely nothing
behind any kind of pay Woll all of the
lectures are free all of the SS are free
everything is free you don't have to pay
for or anything if you can't afford it
or you just don't want to the paid
version is essentially a donation the
only difference is this free YouTube
video has regular YouTube ads whereas
the paid version on the website doesn't
have any ads that's it that's the only
thing so the only reason why I made that
paid version is just in case some of you
can't afford it and you want to support
what I do and want to help me break even
on this project but again only do that
if you can afford it if you can't that's
perfectly fine I hope you'll learn a ton
from watching and following this free
course beyond that if if you follow this
course and you enjoy my teaching style
perhaps look into my other courses if
you like this video then I think you
will really like my turn-based strategy
course that is the perfect course to
follow upon this one it Dives even
deeper into some of the concepts used
here and it will help you make the jump
from beginner to advance and since
you're interested in unity I think my
ultimate unity overview course would
also be very useful to you each lecture
on that course is focus on teaching one
Unity tool or feature there's already
over 50 lectures including plenty of
small but very important things that you
just wouldn't see in a regular YouTube
video if you're interested in visual
scripting I have course on making three
unique games internally with visual
scripting and no code at all or if you
prefer code you can learn how to build a
nice Builder Defender game so if you
enjoy my teaching style in this free
course then check out my other ones then
of course YouTube has Channel
memberships and super thanks so you can
use those if you want I also have my
patreon if you prefer that and in a lot
of my videos I have some affiliate links
if you ever pick up anything through
those I get a nice Commission and I also
have some of my own assets on the unity
as store so if you enjoy this recourse
and you want to support what I do
there's plenty of ways but again don't
feel obligated if you can't afford it or
you just don't want to that's perfectly
fine I hope you'll learn a ton from
watching and following this recourse all
right so that's enough talk of that for
now before we begin building the game
from scratch let's inspect the final
polished game that we're going to build
so let's see that in the next
lecture hello and welcome I'm your Cod
Maki here let's take a look at the fin
game that we're going to build so we
start off on a simple but really nice
main menu so we've got a nice visual a
nice logo and a bunch of useful buttons
then of course the game has a nice
loading system so when I click on play
it's going to load into a loading scene
and then finally into the finnal game
scene so let's go ahead and play and if
there we go here we do see the game
scene and right away we see a nice
tutorial window so it's telling us how
to play the game so the basic
interactions and then over here the
controls importantly these are all
rebindable so over here this element is
all dynamic then we can look at this
tutorial for as long as we want and we
are waiting for the interact to continue
there's also a really nice song playing
in the background so the game has music
now we can look at this tutorial for as
long as we want and when we're ready we
can interact to continue and as soon as
we do y there you go we've got a nice
countdown some nice animations a nice
sound effect and there you go now we are
playing okay so here I am controlling a
nice character I can move in any
direction there is Collision detection
so obviously I cannot go inside solid
objects so I can walk around and for the
goal of the game over here on the left
side we've got recipes that the
customers are waiting for so for example
One customer wants a simple Burger so
for that we got to need to pick up a
nice bun so let's pick it up then the
burger obviously requires a meat Patty
so let's go ahead we can pick one up
from here but this one is an uncooked
meat Patty so we need to drop it over
here on the stove and there you go it
starts cooking we've got a nice timer
we've got a nice worm bar UI and there
you go it keeps counting and we've got
some nice Sparkles some nice visuals and
over there even a nice indicator telling
you the meat is about to burn and there
you the meat has burned so now I can
pick this up and I'm holding some burned
meat so the customer probably doesn't
want to eat this so we can go over here
to the trash in order to trash it let's
try doing another one and do it properly
so let's wait for it to cook pick up a
plate so we can pick it up directly onto
the plate there you go the meat is
cooked so let's pick it up then go pick
up some bread and there you go here we
have our complete recipe so let's go
into the delivery counter delivered and
there you go a nice delivery success all
right awesome we've just delivered our
first recipe so then someone else wants
a salad so let's go ahead pick up a
tomato here we have a big uncut tomato
so let's drop it onto a cutting board
and now we can interact with it so we
can interact with a secondary
interaction key and by interacting we
cut the tomato so it takes a few cuts
and there you go it slices and it sliced
into tomato slices so let's do the same
thing for the Cabbage here we are
holding a regular cabbage then slice it
and this one actually takes a bunch more
and there you go got both slices okay
great so now let's pick up the plate
pick up both slices and leave to the
customer and there you go got a nice
success all right awesome and of course
we have a correct identification of if
we have a correct recipe or not so if I
just pick up an empty plate and deliver
it there you go got a final delivery
because nobody wants just an empty plate
all right so here you can already see
quite a lot of interactions quite a lot
of systems at work so the character has
a nice character controller it has
physics interaction you can see how it
identifies the counter that is in front
of the character I can press a button to
interact with the counter and
interacting with different counters does
different things so if I interact with a
clear counter I can pick up or drop
things over here I can pick up drop it
with an alternate interaction I can do
the second action then there's the stove
machine so that one has a nice State
machine so it counts up over here we've
got some nice particles we've got a nice
Ploom so all the visuals look really
great so we've got some postprocessing
we have a bunch of UI elements directly
on the world and outside of here we've
got some regular UI elements so we've
got the recipes with Dynamic icons for
all of them we've got a timer over there
on the top right corner showing how long
we have to deliver all our recipes and
on the kitchen counter we're also using
a custom Shader so this was built using
Shad graph so as you can see lots of
interlocked systems then the game also
has of course the basics that any game
should have so I can pause the game and
there you go we've got a nice pause menu
so we can resume to go back or pause it
again and of course while pause
everything is paused so that's great we
can go back into the main menu or we can
go into options and over here we can
play around the sound effects volume the
Music Volume we've got all of our
controls importantly these are the
controls for the keyboard and also the
game pad so the game can be played with
any game pad so it can be an Xbox
controller PlayStation switch controller
it doesn't matter all of them work and
we can also rebind all these Keys both
the keys as well as the gam pad inputs
so let's go ahead and deliver a
cheeseburg so here's some burned meat so
let's toss this then pick up some more
meat pick up a plate here we've got some
cheese we've got some bread pick up the
meat and the liver all right awesome and
of course finally a at the end when our
timer is elaps here we have a nice game
over window showing how many recipes we
deliver all right so this is the final
game that we're going to build as you
can see it involves lots of interesting
interactions which require learning lots
of different skills we're going to be
using C interfaces C events the new
input system Shad graphs SC all objects
we're going to learn about C events make
a character controller handle collisions
and so on like I said one thing that
we're going to focus heavily throughout
the making of this game is on writing
good clean code meaning that the final
game that we're going to build will be
very easy to expand upon thanks to how
the code is very clean it will be very
easy to add more recipes maybe more
counters with more actions maybe things
like perhaps washing dishes adding an
oven and so on or really you could make
something completely different this game
is all about character and interactions
so that could be whatever you want you
could take this as a base and build some
kind of sci-fi game something like among
amongus or FTL you can make a survival
crafting game like rust or Minecraft or
don't starve really by learning how to
build this game by the end you will have
gained the knowledge required to build
all kinds of unique and interesting
games all right so now that we've seen
the final game Let's actually build it
just before we do let's get a quick
refresher of the absolute Basics you
should know in the next lecture hello
and welcome I'm your code monkey in this
lecture we're going to just get a quick
refresher of the absolute Basics you
should know in order to be able to
follow everything in this course okay so
like I said this free course is targeted
at both beginners and more intermediate
users in order to start following the
course you really only need to know the
absolute Basics I've made three useful
videos with all of the basic knowledge
required to follow this course watch the
video on how to download install and
setup Unity then the quick Unity Basics
and the C Basics those three Quick
videos contain all of the absolute basic
knowledge you need so if you're a
complete beginner go ahead pause this
video and go quickly watch those and
even if you're already somewhat familiar
with unity still go ahead and give those
videos a watch perhaps in a faster speed
just so you know everything that this
course assumes that you know here I will
assume that you know the basics covered
in those videos like what is a game
object what is a transform what is a
Mony Behavior how scripts have a start
and update and some C Basics as long as
you know those absolute Basics you
should be able to follow everything in
this course I will teach everything
above the absolute Basics and if you are
a more advanced users definitely keep
watching the beginning of this course
might not have much that is new to you
but as we build the game and start using
more advanced tools like script V
objects C events and interfaces
refactoring code and focusing on Project
architecture and writing some good clean
code if you're not a complete beginner
you will still learn quite a lot from
seeing how this project is built and
again like I said I answer comments
every single day so any questions you
have just post them there and I'll do my
best to help this course is played into
lectures they are all as chapters on
video so you can navigate around let me
also take this time to point out that
you are not expected to follow this
course in one sitting go ahead and take
your time for focus on actually learning
remember that's the only goal you're not
competing with anyone you're gaining
knowledge just for yourself so take as
much time as you need rewatch some
lectures if you feel you didn't fully
get it or just ask some questions
whatever you do take your time and just
focus on actually learning so again if
you haven't done so go ahead pause this
video and go watch those three Basics
videos with that we're going to have
everything we need to get started we're
going to start comely from scratch so
let's begin creating a brand new project
in the next lecture
hello and welcome I'm your Cod monkey in
this lecture we're going to begin
actually building our game so let's
create a cum2 project and start building
it all from scratch okay so the first
thing that we need is to install Unity
now I covered this in detail in that
other Basics video so here I will assume
that you already have Unity Hub
installed the first decision we really
need to make is choosing a Unity version
so on Unity Hub you go into installs and
install an editor and now Unity
recommends that you use the LTS version
or long-term support you should be using
that one in most cases it's what it in
installs by default which as of the time
of this recording the latest one the
latest LTS one is 20 21.3 however I want
this video to stay up to date for as
long as possible so for making this game
I'll actually be using version 2022
point2 if you're watching this video
where as came out then download this
version and if you're watching this
months in the future after version 22
LTS is out then you can use that one it
will probably be the exact same thing as
version 22.2 so you should be able to
follow everything exactly for any
changes I will Point them out in the
updated pin comment and if you're
watching this here in the future and
there's an even newer LTS version I
would still recommend you follow using
the 22 LTS don't worry about using a
quote unquote older version everything
you'll learn here in this version will
still be applicable even 10 years from
now so like I said I'm going to be
installing this one and in terms of
modules doesn't really need anything
already have Visual Studio Community
installed and all the other ones are
unticked so
install Okay so the version is installed
now let's create a new project let's go
into the project tab then create a new
project and now first up up here make
sure to select the right version so
again I'm going to be using
22.2 then for the templates this has
mainly to do with the unity render
pipelines now if you're a beginner don't
worry about that too much just go ahead
and select the 3D urp template so scroll
down this one right here 3D urp make
sure you select this one and not the one
that says just 3D the urp here stands
for the universal render pipeline which
means our game won be playable on
literally any platform so we can make
the funnel game and put it on steam or
consoles or mobile it run on everything
then over here on the right side let's
quickly just download the template there
it is it's done now select the name for
your project so I'm going to call this
kitchen chaos and then select the folder
for it all right so that's it again make
sure you're using the exact right
version make sure using the 3D urp
template give it a name a fer and let's
head on
create all right so it's open and right
away you might or might not see a window
talking about urp material upgrades I
think this has to do with the template
not having the default materials updated
to the latest urp version so if you're
watching this in the future chances are
you might not see this one that all but
if you do then just go ahead click on
okay and it will automatically upgrade
all the default materials all right so
here we have our basic unity window now
since we started a project starting from
the urp template we have down here A
bunch of urp helper files so you can
click to select the read me file and you
can see it over here on the right side
on the inspector if you want you can
browse around these links in order to
learn more about urp but in our case for
building our game we really don't need
this so over here on the inspector let's
just click this button to clean up these
breed me files just go ahead click on
yes and okay that's it so basically you
should only have these files in your
project window so there's the scene
folder and inside we've got the sample
scene then we've got the settings and
inside a bunch of urp assets all this
should have been set up automatically
since we use the 3D template and then
finally we just have the urp global
settings asset now let's just verify
everything work correctly so let's go to
the top left go into edit then go down
into project settings then over here
let's go into the graphics Tab and you
should see the urp High Fidelity asset
assigned by default if not you can click
on the circle icon and assign it then
the other menu is over here the urp
global settings again this one should be
set by default then down here on the
equality tab on this one make sure High
Fidelity is selected basically whatever
you select here is the quality that
we'll be using in the editor and in turn
the selected quality over here also has
a render pipeline asset now in order to
avoid any confusion let's actually get
rid of the other ones so let's just
click on the trash icon to get rid of
the performance and the balanc quality
so just click and click okay so we only
have this one then let's close the
project settings and let's go into the
settings folder and over here let's
select the urp balance there are two
assets for each quality so select those
leave the High Fidelity and the
performance and let's delete these all
right that's it by the way if you made a
mistake and accidentally deleted
something don't worry you can always
just click over here on the plus icon on
the project window and then go over here
under rendering and you can create a new
urp asset with universal render okay so
just like this so we only have one
quality setting we have high fidelity
the quality setting is using this render
pipeline asset which is also using this
renderer so that's really it with this
we have the absolute bare minimum we
need if in the end after building the
whole game you want to provide multiple
quality settings then you can come back
to this menu and recreate them but in
order to avoid confusion while building
the game let's keep things like this as
simple as possible okay so that's the
basic setup done next we want to prepare
our layout so let's continue on to the
next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
learn about the UN layout and set it up
so first first things first let's
familiarize ourselves with the various
Unity Windows to create our own layout
it's very important that you feel
comfortable with your layout that you
have easy access to all the things that
you need and you know where everything
is you can see that there's lots of tabs
everywhere over here on the N window all
of them can be dragged and dropped in
any different position so you can
customize your layout to get it looking
exactly as you want you can set it up in
any way but it will be easier to follow
this course if you're following the same
layout as me I'm assuming you've seen my
quick Basics video so I'm assuming you
know what is the inspector what is a
game object what is a trans form what is
the console where is the hierarchy and
so on if this is the very first time
you're seeing the unity interface go
watch that other quick video first just
to learn the absolute Basics now for me
I've been using Unity for over 10 years
now so let's see the layout that I've
developed over the years first the
inspector on the right side just like
default that way we always have a nice
view of the selected object and whatever
scripts and components it has then for
the hierarchy I like to put it down here
on the left side we're going to make
sure that our scene is always organized
so we don't need the hierarchy to take
up tons of space then with the project
files next to it this corner is enough
to really browse all the files we want
the console to be on the tab right next
to it usually I find that when making
the game I want to look at the project
window but when playing the game I just
want to look at the console so keeping
them in the same place but on different
tabs works great then over here on the
center the scene View and again with the
game view right next to it okay so this
is the basic layout that I normally use
now for a couple more options let's go
into the project window and on the top
right corner you can see over here these
little three dots by default it shows
you a two column layout so there's a
column here and a column here but
personally I prefer the one column
layout this showcases all of the project
files in a nice compact list view the
one thing where I prefer the other one
is if you're browsing for some visual
assets over here you can increase the
thumbnail size but for most times I
really like to use the onecom layout
much more compact also since we're
talking about the project window just in
case you don't know there's over here
this little button with the ey this one
has to do with package visibility if you
toggle it then some of the install
package are hidden whereas if you
untoggle it then you can see all the
various packages with all the source
code and so on you can expand over here
the packages and right now it is showing
all of them all of them with source code
the things everything there and if you
click on this then it hides it only
shows a bunch of core ones but for most
part you really want to leave this
teched and leave this one collapse nice
and clean okay so then on the console
over here once again let's go into the
three dots and for the log entry for
this one I like to select one line this
makes the console nice and compact which
I personally prefer you can see more
logs without taking up more space and if
you want to read the whole log you can
always just click on it to see the whole
stack now there are also some more
options over here if you want for
example show the time stamp this will
show the time stamp when each message
was sent you can use a mono space font
meaning a font where every character has
the exact same width so a bunch of
options but for me leaving it just like
this works perfectly fine then also
importantly over here these three
buttons these toggle the visibility for
the TP messages that appear in the
console the left one this one is for
regular messages we're going to use this
a lot then we've got warnings and
finally errors if you untoggle them then
the messages of that type will not show
up on the console so if you ever come
across an issue where nothing is showing
up on the console make sure all three of
these buttons are ticked then on left
side on clear you can click on the Arrow
to see more options I like to set it to
clear on play then collapse this one
basically collapses messages that are
the same of them into one entry
personally I do not like this I want to
see every single message as it comes out
even if it's repeated I've also seen
this lead to a lot of confusion for some
people they think their code is firing
just one message when it's actually
firing hundreds So to avoid any
confusion make sure you leave this un
toggled then for air pause this will
automatically pause the game when an
error occurs you should definitely have
this one toggled if there's an error you
definitely want to know about it you
want to know when it happens so you can
fix it whereas if you untoggle this you
might get some errors and the game might
keep playing which will then lead to
lots of confusion when something start
behaving weirdly so always leave this
one toggled and then the editor button
this one is for more advanced use case
so don't worry about it okay so that's
the console then over here for the game
view we've got a button here to select
the aspect ratio let's go ahead and
select full HD this one is a 16x9 aspect
ratio so everything is pretty normal
this will really only matter when we
start working on the UI but still I like
to keep it as 16x9 always then on this
button that says play Focus we can
modify some options basically Focus will
play exactly like this on this small
window if you choose maximize then it
will maximize this window when playing
the game and play in Focus won't play
the game even when the window is not in
Focus then another important one is
actually on the same one as the aspect
ratio here we've got a button to togg on
vsun usually When developing the game
you really want to toggle this that's
because right in the beginning when the
game doesn't really have anything if you
leave it un toggled then this might run
at like 1,000 frames per second and that
will pretty much drive your GPU crazy
finally if your game view is looking a
bit too pixelated make sure over here on
the scal slather make sure this one is
not zoomed in this one should always be
pushed straight to the left as much as
possible okay so that's the game view
then over here on the scene view for
this one default should be good these
two buttons are extremely important
pretty much all the time you want to
keep the tool handles on the pivot and
not on the center if you ever see your
handles on weird places always come back
to this you want this on pivot pretty
much all the time then for rotation
sometimes local is useful but for the
most part you should probably be keeping
it in global then for the grid showing
the GD and why yep that looks pretty
good a nice little visual grid then
you've got a bunch more options if you
want then next to it we've got snapping
this one we also don't need this for now
and finally same thing for increment
also don't need this okay then on the
right for the draw mode let's leave it
on shaded for 2D let's leave this
disabled since we're working on a 3D
game for lights let's make sure this one
is enabled for sound we're only going to
add this in the end so it doesn't really
matter for now then for special effect
usually you want this one to be enabled
so it shows everything you can click on
the arrow and make sure all of them are
toggled the only exception is always
refresh you probably don't need this
little scene window to be refreshing at
60 frames per second so you can leave
that one unticked and take all the
others then these are for the Hidden
Object so let's leave them toggled for
the camera here are the defaults and
finally gizmos leave them all enabled as
the defaults all right so all that said
here is the layout that I'm going to be
using throughout the course it will be
easier to follow the course if you're
using the exact same layout as me so
ideally you should be using this but
again like I mentioned all the windows
are customizable so if there's something
that you absolutely prefer differently
then go ahead you can drag and drop and
place any Windows anywhere you want so
once you have layout your happy win you
can go up here to the top right corner
where it says default you can click on
it and here you've got a bunch of
layouts so you can save your new layout
so I'm going to save this one as kitchen
chaos and then over here you can select
anyone you want for example if you ever
have some issues with any kind of weird
editor Windows you can load back the
default layout and then go back and load
your own layout okay so with that our
layout is set up the next important
thing is setting up visual studio so
let's do that in the next
lecture hello and welcome I'm your code
monkey in this lecture we're going to
set up our visual studio all right so
with the UN layout set up let's make
sure Visual Studio is also set up
correctly I'm going to be using version
22 Community this one is the free
version you don't absolutely have to use
the same code ID that I'm using you can
use ryer or vs code or whatever you want
so let's see my setup for visual studio
but first let's actually set up
something over here in unity so let's
let's go up top into window and then
let's open up the package manager then
over here on the drop- down menu let's
select the packages and select the ones
from the unity registry then let's
scroll down to find the visual studio
editor package so here it is this one
this package basically handles the
integration with visual studi so you can
use the debugger and a bunch of things
alternatively there's also a package
over here for visual studio code and
there's also one over here for jet
brains Rider so if you're using a
different ID go ahead and install the
package for me I'm going to install the
visual studio one so this one just go
ahead and install okay it's done so next
let's go up into edit and let's open up
the preferences then over here let's go
down into external tools and on the
external script editor make sure you
select the one you're using so again for
me I'm using visual studio 22 and also
over here you've got a bunch of extra
options now if you want to play around
with reading the source code for the
various un packages then you can take
all these boxes but in our case for this
simple game we don't need that so go
ahead and leave everything just like
this with defaults okay so with this set
up now we can go over here into assets
and open up the C project and this
should open up visual studio and all
right so here it is now for some more
settings inside of here in my visual
studio I have a really nice extension
that adds a bit more colors to my code
which makes it easier to read and write
so up top let's go into the extensions
menu and manage extensions and the
important one that I've installed is
this one vs4 if you want you can go into
the online Tab and over here search for
it and yep it does show up in here then
for the settings on that extension let's
go up here into tools and let's open up
the options then over here let's scroll
down and find vs4 Yep this one and here
are all the settings and expand this and
a bunch more settings now for me I think
these are all the defaults I don't
remember if I changed anything the
important one is over here the rainbow
braces so these have a bunch of colors
which make it a bit easier to read the
code so let's create a simple script
just to see this so back in unity let's
go into the project window let's click
the plus icon and let's create the brand
new C script let's call it just testing
wait for it to compile and now let's
open now over here I'm just going to
write a bunch of simple code just to
test it out you don't have to follow
this all right so here's a bunch of
sample code these are the colors you can
see it makes everything a bit easier to
read although again this is not a
requirement you don't absolutely need
this extension but personally I do find
it quite useful I find that it helps
make the code more readable than having
everything be gray okay so that's the
setup for this extension next for the
text formatting options so once again
let's go into tools go into options and
then over here let's go into the text
editor then over here I think I've got
pretty much all the same defaults then
we can go into the C rules so here are
all the settings if you notice something
different on your end go ahead and pause
the video and compare the settings but
again I think everything here is pretty
much default I believe the only
difference that I did was over here on
the code style over here for new lines
personally I like to have the currently
brackets on the same line but if you
want you can also change it and put it
on the second line I think that's pretty
much the only difference that I did
everything else should be exactly the
same as defaults so that's the code
style settings and speaking of that the
next lecture is very important we're
going to talk a bit about naming rules
although just before we go let's just
clean up our testing SCP so let's close
this one click on the X then back into
Unity we don't need the script so let's
just delete it okay so with that we have
Visual Studio set up and ready to go now
let's continue in the next lecture to
learn about some naming
rules hello and welcome I'm your Cod
monkey in this lecture we're going to
learn something extremely important
let's learn about naming rules this one
is a very important lecture that you
should definitely refer back to whenever
you have some questions so first what
exactly are naming rules these are
really just rules you follow when
writing your code it is extremely
important that you you are consistent in
applying your own rules you don't want
one class in your game to be written a
certain way and then a different class
using a completely different style that
would create tons of confusion so naming
rules and writing the code correctly is
very very important one mistake that I
see a lot of beginners do is they send
me some code and ask why it's not
working then I take a quick look and I
see that all of the code is written in a
very messy way some functions are in
lowercase others using snake case some
fields are in Pascal case some in camel
case and so on remember that code is
case sensitive so it is extremely
important that you write the code
correctly if you change a character from
lower case to uppercase then you are
suddenly referring to something
completely different if you're a
beginner keep that always in your mind
code is case sensitive so don't just
write code semi-randomly write it
properly as if you were doing an English
literature test now with that said when
it comes to naming rules you can use
whatever naming rules you want different
people like different rules for example
you can use a prefix in your variables
you can use a postfix you can use
capitals for constants camel case for
property snake case for Fields by the
way here are the definitions of what
those terms actually mean Pascal case
starts with a capital and every word is
capitalized camel case starts lower case
and then uppercase for the first Lector
of every other word kind of like a camel
hump in the middle and snake case is
where you add an underscore in between
the words like I said every rule can be
valid the important thing is that you
are consistent in always following
through with your rules as you might
know Unity mono behaviors have some
default functions you can Implement
things like start and update which are
written using Pascal case since you can
can't really change un's rules at least
on function names I would say you should
base your rules off of theirs so for
functions you should probably be using
Pascal case for the other rules like I
said choose whatever makes sense to you
here are some of my own personal rules
that I've developed over the last 10
years and the code style that I will be
following in this course for functions I
use Pascal case just like unity and just
like the C standard for function
parameters I use chamel case for Fields
also camel case properties are in pel
case constants are in uppercase snake
case then other rule is that I like to
add the Tope of the variable as a
postfix so if it's a list I open the
list if it's an array I open array and
now you might be thinking with this
wouldn't it be an issue if you change
the type then the name is suddenly wrong
and the simple solution for that is that
if I change the type then I just use
Visual Studio to quickly change the name
that's it then for the currently
brackets like I mentioned in previous
lecture I like them on the same line
some people have some very strong
opinions about this really it's just a
visual style and this is the one that I
personally prefer if you like new line
then go ahead and use that it doesn't
change how the code works in any way and
a final rule spend some time deciding on
a proper name and don't be afraid to
rename things you will note how all the
code that we're going to write in this
course has proper names for everything
you should never use a variable with a
single letter like X or k the exception
of course would be iterated in a for
Loop also don't use acronyms or
abbreviations those might seem clear
right now but in a few weeks you might
not remember what they mean remember you
don't get bonus points for writing
extremely compact code so prioritize
making your code readable and
understandable even if it requires
variables and functions with long names
so these are my general rules and the
code style that I personally follow
figure out what works for you and follow
your own naming rules but naturally in
this course I will be using my own code
style so if when following the course
you're not sure how to write some type
of code you can refer back to this
lecture and watch it again like I've
mentioned many times the code that I
willon teach you how to write in this
course is on the exact same level of
quality as my paid courses and my Steam
games so as such because that this
lecture these naming rules are all
extremely important okay so with this
very important lecture out of the way
now let's start playing with some
visuals by importing some Assets in the
next lecture hello and welcome I'm your
Cod monkey in this lecture we're going
to import the project files with all the
assets that we're going to use by the
way remember that if you have any
questions go ahead and post them in the
comments I go through those every day
and I'll do my best to help okay so with
the project created the next thing we
want is to import the assets that we're
going to use to make this game you can
download all of the assets with the link
in the description which by the way like
I mentioned a while ago that link
contains a Unity package that contains
both the assets and the finnal game so
any download that you get a Unity
package just go ahead and double click
or click and drag and drop it on the
project window here is the asset import
window just make sure you select all and
let's import okay so here it is this
import the assets folder and inside
comes all of the assets meshes textures
and so on so everything we're going to
need and then it also imported inside of
it another un package so if you want to
import the final project with all of the
code already written it's also here if
you extract this one you're going to get
the complete project files now of course
don't do that if you want to follow
follow along with the course and be
aware that if you're following along and
you accidentally unpack this one it will
override all of your own files so if you
want to inspect the final project files
go ahead and do that but do that in a
separate project in order to make sure
that we have no accidents I'm going to
delete this one from the current project
so just go ahead and delete okay so
that's it and over here we've got all of
our really nice visuals we can look in
the prefab visuals and over here we've
got a vision for a container so there
you go that's a container counter then
we have a cutting counter we've got a
trash B then on the kitchen object
visuals we've got all the visuals so a
block of cheese we've got some burned
meat we've got a plate and so on these
are all the nice 3D models that we're
going to use in our game and then over
here on the textures folder we also got
a bunch of General icons as well as
actual icons for all of the various
parts okay so all of the assets have
been important now let's continue onto
the next lecture hello and welcome I'm
your Codi in this lecture we're going to
set up post processing now here let me
make a quick note usually when Mak your
games you probably don't want to handle
on post processing right away you should
first get an ugly prototype up and
working before worrying about any
visuals so normally I would only add
post processing much later on in the def
process but since this is a course and
video format in order for the video to
look a bit more appealing let's set a
post processing right away now we
already have the project set up to use
urp so adding post processing is
actually super simple it's actually
already added by default first before we
do that let's rename our scene with a
proper name so inside the scenes folder
it starts off with sample scene this
this will be our main game scene so
let's just rename this to game scene
okay and now here on the hierarchy we
can see by default this scene already
contains a global volume game object
this is how you actually add post
processing and by default you can see
that it also already has a sample
profile attached this is how you add all
the various effects you can click on
this link and it will show it over here
on the project window now let's build
this from scratch instead of starting
from this one so let's go into that file
into that asset and just delete it okay
so now we have no volume profile now
let's go ahead and click on new to
create a brand new one okay so now here
we can add overrides add all of the
effects that we want let's drag some
visual meshes that we imported in the
last lecture to get a better look at all
these effects and what they do so first
let's make some kind of floor so let's
make a 3D object let's make it a plane
let's name this the floor also one
extremely important thing whenever you
create a brand new object always check
the object's transform position by
default when you create an object it
appears in front of the scene camera
which will probably not be on 0000 you
always want to be very careful with the
position of your actual objects so for a
plane we do want this to be on the
origin so on 0 0 0 so make sure you
always do that then let's scale it up a
bit so on the scale let's put it on 555
which by the way you've got this nice
little icon this was added in a recent
Unity version basically if you enable
this then it matches all of these values
so if you just change one of them it
changes all of them so let's put this on
Five okay great now for the visual let's
go ahead into the mesh render on the
materials and let's select the brand new
materials so let's click on the circle
icon and over here let's find the floor
material so here it is it's the one
included in the assets there you go
we've got a nice basic for material now
let's also drag the player visual so
let's go inside the assets folder and
over here let's go inside the prefabs
visuals and down here we find the player
visual so let's just go ahead and drag
this one so there it is a nice player
visual let's also drag a counter so
let's find let's say the Clear counter
let's drag this one let's rotate it to
face the camera something like this and
let's also put a cutting counter again
we're just placing some visuals just so
we can see what the post processing will
do and let's also place a bunch more
things so let's say a tomato let's place
a tomato over there and maybe cabbage
all the way over here okay so we've got
a handful of nice visual elements so we
can test out our post procing by the way
here's a quick inty tip on scene
controls whenever you are on the scene
view which make sure you're on scene
View and not game view those are
different so on the scene view you can
move the camera with a mouse you can pan
with mouse 3 so the middle Mouse button
so hold that and pan it around you can
rotate with the right Mouse button you
can rotate around the point by holding
down left alt and left click and just
drag it around to rotate around an
object you can select an object like for
example player visual then then you can
press on F to select that object and now
if you hold alt and click it will rotate
around that object also another method
is you can hold the right Mouse button
to move it around and then you can use
was to move so d a and so on then you
can even press shift to move in faster
and you can use the scroll wheel while
holding down the right Mouse button or
to modify the speed at which you move so
there are plenty of camera controls to
really get you seeing exactly what you
want to see now for another quick un tip
you can move the scene camera to where
you want the game camera to be so let's
say I want the game camera to see things
from about this angle so you just
position the scene camera then on the
higher key select the camera game object
so the main camera right here and with
that object selected you press control
shift and F and if there you go you can
see over here on the camera preview let
it position the main camera looking on
the exact same position at the exact
same direction as the scene camera so
that's the shortcut control shift F or
alternatively go up into game object and
over here Aline withd view now if you
look here is the scene View and over
here we've got the nice camera view so
just position the camera somewhere where
we can view all the Assets Now with this
let's add some post Crossing effects so
first let's select the global volume
game object and over here we can add all
of our effect overrides first up let's
begin by adding tone mapping so there
you go we've got the effect and over
here we've got a nice little checkbox so
you can enable it in order to enable
this effect and set one of the options
now for this one I'm not too familiar
with color correction but I find that
usually adding a neutral tone map
usually that helps also make sure you're
looking at the game View and not the
scene view if you're looking at the game
View and you enable and disable this
effect you should see a difference
whereas on the scene view if you enable
and disable doesn't actually show that
even if on the scene view over here you
have all the effects enabled even with
that some effects for some reason don't
show up on the scene view so when
playing around these effects always make
sure you're looking through the game
view so like I said you should be able
to talk on this and see a visual
difference on the game view if you don't
then make sure the camera has
post-processing enabled so let's select
the main camera game object and down
here there's the tole for post
processing make sure this one is enabled
and then also on the render pipeline
asset so let's find that one on the
project window over here we've got the
settings and you've got the urp High
Fidelity this one should be using a
renderer so if you click on the renderer
over here you should have post rossing
enabled again all of this should already
be correctly set up by default so if you
go into Global volume enable or disable
you should see a visual difference okay
so next Effect one that I always like to
add is a bit of saturation so let's add
an override post procing and let's add a
brand new here it is color adjustments
then over here you've got plenty of
things to play around in for me I like
to add a bit of saturation so just lift
it up a little bit let's say just about
20 and I also like to add a little bit
of contrast over here let's also add 20
and there you go it makes the colors pop
a little bit more so personally I like
this effect then later on we're going to
have some glowing objects for example
the stove let's actually try dragging
that into the scene so let's go into
scene View and in the assets let's find
the stove counter so here this and
inside the stove counter there are some
things so here is the stove on visual
this one is disabled by default so on
the inspector let's just enable this
game object to make it visible again
don't worry about the positioning of the
objects on the scene view right now
we're only positioning them just set up
the post processing we're going to
delete them all at the end of this
lecture okay so that one enable let's go
into the game View and over here we see
the stove enabled so now let's go into
the level volume let's set an override
go into post pressing let's add a bloom
effect so right now notice how that one
is not glowing red hot for that to work
we need to have Bloom and we need to
enable the threshold and the intensity
if we raise the intensity we do see yep
there we go a really nice glow there by
the way here's a quick visual tip if you
want to make your game feel a bit more
ethereal and magical one good way is to
put the Threshold at a low value below
one so something like 0.5 and then put
the intensity as a little bit and with
this notice how everything has a slight
low even colors that don't have any
extra intensity so the floor is glowing
the character is glowing so everything
looks quite a bit ethereal this is a bit
extreme but it is an interesting effect
also another quick note here in case
you're not seeing anything change make
sure you go into the render pipeline
asset so the urp High Fidelity and over
here make sure AGR is enabled you can
look at the so low if I disable it yep
that one stops glowing and with that
enabled it does start glowing HR stands
for a high dynamic range so that is how
you can have a color go with an
intensity above one which actually makes
it low when you have the balloon post
pressing if even with that you're still
seeing issues then make sure you go into
the renderer and over here for the
postprocessing sometimes Unity has a
weird bug and doesn't generate this
postprocess data file so if that does
happen just go ahead un toogle and
toggle this and it should work and
finally like I said on the camera make
sure you have post procing enable so
with all of that you should be able to
see the game view glow okay back into
our effects with our Bloom working like
I said you can lower this below one to
get a nice ethereal look but this is a
bit too intense on what we want so let's
make it a bit more subtle so on the
threshold let's put it at 0.95 so
there's a slight low on the white Parts
but nothing too intense and for the
intensity let's put it at a r one okay
so I think that's a nice amount of Bloom
all the colors glow a little bit and we
can see over there the stove it is
indeed glowing okay great now if you
ever forget all these steps and you
can't get your project to Glow I made a
nice video with a nice checklist of
everything needed for you to Glow
definitely go ahead and watch that video
whenever you have issues then for
another fun effect we have vignette so
let's go into add override post pressing
and let's find the vignette what this
one does is adds a bit of Darkness to
the colors so if we enable on the
intensity and we increase it you can see
what it does so it adds Darkness right
on the corners there personally I find
this one looks good when it's quite a
bit subtle so let's put the intensity at
some like 0 25 and then for the
smoothness let's also put it on point4
so just like that just a slight Darkness
on the edges so personally I think it
looks pretty good and that's pretty much
it for the Post pressing on the volume
component I like how this looks you can
see difference with the volume enabled
or disabled quite a big difference looks
pretty nice
but again these are just visuals so feel
free to play around maybe add some more
effects use in different settings these
are just visuals they don't impact the
game logic at all so feel free to make
it work exactly as you want it then yet
another thing related to post procing
but not in this component is some
anti-aliasing for that one place where
you can change it is on the main camera
over here you see a field for post
rossing and you have a bunch of types so
FXAA or SMA or if you want some more
higher end post pressing you can go into
the rendom pipeline asset so urp high
fodell and over here we anti analing
msaa this one is a bit more expensive
but looks a bit better if you want to
see the difference you can go over here
into the game View and on the slider up
top on the scale you can increase this
quite a bit so with this we can now see
the pixelation and you can see over here
if I switch anti eling from 4X back into
disable you can see lots of jagged edges
and if I put it on 2x Yep looks a bit
more smooth 4X a bit more smooth and 8x
even more smooth so with that you can
see difference on all the edges all the
things by default this renderer has on
4X and nothing on the camera this
already looks pretty good but to make
the video look even better I'm going to
put it on 8X and on the main camera I'm
also going to leave it with no antiy you
can combine them but if you do then
everything looks a bit too blurry so I
don't quite like that effect so put this
one on none and the other one on 8X
although again this is just a visual so
if you have a low NPC feel free to go
into the urp and over here disable
anling so the game looks a bit worse but
it will run much better okay let's drag
the scale back down okay now one final
thing we can add is some really nice
screen space ambient inclusion for that
let's go into the renderer so not the
render pipeline asset the renderer and
over here by default it already added
screen space amb inclusion if it didn't
add you can click on ADD render feature
and over here you won't be able to see
it I don't see it because I already have
it okay so here it is basically what
this effect does is it adds some tiny
Shadows where geometry intersect if we
enable and disable it quickly we can see
the effect over there on the counters so
you can see with the default effects it
already Works quite nicely for example
look that on the player we can barely
see the difference between the head and
body but if we enable this it adds that
nicely Shadow I think it looks really
nice but then we've got a bunch of
settings we can play around increase
intensity the radius and so on Now One
important thing when setting all these
effects is to remember the point of view
of the camera in this case we're making
a top down game so before we play around
these settings let's actually position
the camera in a correct position so
let's go ahead select the main camera
and let's position it above pointing
down so let's put it on an X of zero on
a y of 21.5 on a zed ofus 21.3 then for
the rotation on the X for six then 0 and
zero and finally on the camera over here
on the field The View instead of 60
that's really wide for this game let's
go with 20 okay so this is the view that
we're going to use for our game let me
just rotate the objects so they actually
face the camera so on the hierarchy
let's just select all the objects let's
rotate them all around and just position
them again we're only using these just
to see what they'll look like we're
going to delete all of these objects in
a bit okay so yep that's the game view
now that we have the camera set up let's
work on the settings for the EM
inclusion so let's go down select the
render and over here for the settings
for the intensity let's put it on four
for the radius let's put it AT3 and the
rec lighting strength let's put it all
the way up to one okay so you can toggle
this enable and disable to see the
difference and yep I do think these
settings look pretty good finally the
last thing we need to check is the
lightning window so let's go into window
then down into rendering and let's go
into lighting out pops up the lighting
window personally I like to Anchor it
over there next to the inspector and
over here we're really going to leave
everything on defaults so you can leave
it as the lighting settings assets and
nothing assigned and then on the
environment tab over here again all the
defaults I didn't touch any of these so
you've got environment lighting from the
Skybox intensive multiplier of one so
everything pretty much on defaults
although again like I said most of these
visual effects are very much personal
preference so if you want to make your
game look a bit different than mine then
go ahead you can play around with
lighting over here you can change Skybox
to gradi and color and so on if you want
you can use some bake lighting then if
you want you can add all kinds of extra
effects and also by the way remember
that the effects are sored on this
profile over here so for example you can
click over here here on the Clone button
and it won't clone the effect so let's
click on it to find it yep there you go
so that's the one that I built and
here's a clone one so if you want you
can make a clone one and then make it
look very different for example let's go
into chromatic aberration make it really
intense and for example let's go into
the color curves and over here for some
reason let's drag the green up and so on
so there you go completely different
visual so if you want to play around
make some weird effects and if you want
to go back just revert back into the
original profile personally I'm quite
happy with how this looks so I'm going
to be using this one okay again you can
enable and disable the volume game
object to see quite the big difference
that post pring makes if you ever want
to make your game look quite a lot
better always make sure to add some post
pring all right so like I said this
looks really good I like it now before
we go to the next lecture let's just
clean this up so let's get rid of all of
these objects so the counter cabbage
tomato and so on let's get rid of all of
them except the floor so let's leave the
floor and get rid of all these all right
so here we have our nice empty scene
let's just save our scene and let's get
ready for the next
lecture hi there this is a quick
intermission so how are you doing are
you enjoying the course so far are you
having any trouble with anything is
there something you didn't understand if
so remember I'm always active in the
comments answering all the questions so
if there's anything you need some extra
clarification go ahead and ask and I'll
do my best to help also remember to
check out the pin comment YouTube videos
cannot be updated so for any notes or
comments I'll put them in the pin
comment and definitely check out the
website page for this course as people
ask more and more questions I will keep
that page updated with any frequently
asked questions for every single lecture
so that way you can see what others have
asked and learned from them and you can
also download the project files for each
lecture so keep that page open on a
second Tab and check it every time you
start watching a new lecture I really
hope you're enjoying the course and I
hope you've already learned quite a few
things go ahead and hit the like button
and subscribe to the channel if you
haven't already Okay so let's go to the
next
lecture hello and welcome I'm your codm
in this lecture we're going to begin
creating our character let's make a nice
character controller so we can move our
character in the world
okay so first let's begin by creating
the character game object and now
usually most beginner tutorials would
tell you to just right click go into 3D
object and create something like a
capsule that way you would have the game
object with the visual
included however for a good project
structure and good organization you
should always separate the visuals from
the logic for example here let's say
that I don't want my capsule Exel like
this let's say that I want my player to
be a little bit more skinny to do that I
would have to modify on the scale on
this game object so put it maybe on 7.7
so something like this basically by
doing that by modifying the visual I
also modify the scale on the actual
player game object having a non-uniform
scale on a logic game object that can
cause all kind of problems with any kind
of logic component also I would prefer
to have my character on the floor but if
I put it on y of zero notice how the
character is half underneath the floor
so if I were to use this method I would
have to apply some kind of offset in
order to make the visual above the floor
so that would require rear arranging all
the logic to work with an offset on the
Y position so because of those reasons
and many more you should not Place both
the logic and the visual on the same
game object instead you should separate
them so let's get rid of this and
instead let's create an empty game
object let's name this the player let's
put it on 0000 0 okay and now inside of
it now inside let's create let's say a
capsule now this one we can easily scale
this get any size and shape you want so
for example 7.7
then since the visual is a child of the
game object we can also easily offset
this so let's say put it up by about one
unit so with this we can position the
visual so that basically the player game
object it's over here on 0 and the
character is above the floor so we don't
have any weird offsets this will make
all of our logic much more simplified
and now on this empty Parent Game object
we can attach all of the logic
components we want and then in the child
visual we can add or replace whatever
visuals we want so as a general rule you
should always try to do this always
separate the logic from the visuals in
your game objects okay so with that we
have the player game object now let's
make our character controller script and
before we do let's keep things once
again organized so before we do let's
create a brand new folder so let's right
click on the assets create a brand new
folder call it scripts and now inside
let's right click and create new C
script call it the player wait for the
code to compile then select the player
game object and attach the script again
remember logic components go on the
parent game object not the child visual
so child visual this one only has visual
components and the player this is the
one that actually has the logic
components so let's open up this script
okay so here's our first C script like I
said I'm going to assume you know the
absolute Basics go watch the C Basics
video If you haven't seen it yet so I
will assume that you know what is a
function what is a variable what is
start and update so pretty much the
absolute basics for a character
controller we first need some input from
the player and for that Unity actually
has two methods you have the Legacy
input manager and the new input system
basically the Legacy input manager is
super simple and very easy to use so
this one is perfect for quickly
prototyping and the new input system is
extremely capable with tons of features
but it's also a bit more complex so what
I do is while I'm doing a simple demo or
testing out a new prototype I just use
the Legacy input manager but when making
a more complex project like for example
my seam game then at a certain point I
refactor my code to use the new input
system so here I'm going to teach you
both as well as teaching you how to
refactor code which is an extremely
useful skill so let's first begin by
using the simple Legacy input manager we
want some basic was movement to move our
character and we're going to need to run
that logic on every single frame so
let's do it on update and let's actually
get rid of the code that Unity writes by
default let's start compling from
scratch let's get rid of this just close
okay so here let's start by writing
private void update and now here very
important if you're a beginner make sure
that update is written exactly like this
if you write update with lower case if
you do this then it won't work the
function will not be called
automatically I'm pointing this out
because I have seen a bunch of comments
from beginners wondering why their code
doesn't work and it's as simple as this
with the lower case Unity will not call
this automatically it needs to be
exactly perfect so again if you're a
beginner make sure you write the code
exactly the code is case sensitive so
this is very important also another note
you saw that the code that Unity wrote
by default when we made a new script it
just had void update it did not have the
private keyword private is what is
called an accessor you have private then
you have public and then there are some
more advanced ones technically you can
omit the accessor and in most cases it
willon defa to private however in
writing good clean code you should be as
explicit as possible there should be no
room for misunderstandings so while
technically you could Adit the private
you should always include it to make
your code easy to read and easy to
understand this one is the first of many
clean code rules that I will teach you
during this course like I said all of
the code that I'm writing here is on the
same level of quality that I use in my
own profession games I'm not going to
teach you bad practices like so many
beginner tutorials do so always be
explicit always include the accessor
okay so we have our update Running code
on every single frame then to test if a
key is being pressed we just go inside
input then over here we've got two
functions so we have get key and get key
down both these functions were turning
bulling so that's either true or false
the difference between them is that get
key down this one only returns true for
a single frame when the key is pressed
whereas get key this one stays true for
as long as the key is held down for
example for an action like jumping you
just want to know when the player
presses the button so for that one you
would use get key down however in our
case for a character controller we want
to know if the key is being held down we
don't want just one frame but always so
for movement let's make sure we go with
get key then requires a key so let's
write our key code and then choose the
key let's say we want W and then let's
just put this inside an if just like
this okay so here we have code we want
to run while holding down the W key
let's do a quick test just to verify
everything is working perfectly and for
testing we can use a super useful
debug.log this one lets us print a
message in the console so let's add one
log here just say something like
pressing and then let's also do an else
and if else let's do a debug.log and
just do a dash okay so here is our very
basic script let's make sure to save it
so contrl s then back in unity over here
make sure you have the script attached
to the player game object and now we can
test and now down here on the console we
can already see dashes so I'm not
pressing any key also like I mentioned
in the setup lecture if you're seeing
just one message then maybe that means
you have over here the collapse toggled
if you toggle it look how it only shows
one message but then over here on the
right side says the number of messages
personally I prefer to always keep it un
toled so I can see every single message
also over here on the right make sure
you have info messages visible if you
untoggle this and you don't see it so
make sure this one and actually both of
them make sure all of them are enabled
okay so we're seeing a whole bunch of
dashes and one more note if over here
the scroll bar stop scrolling so right
now you can see it's stuck up instead of
being down there so if that happens one
easy way to reset that is just click
over here on clear and it goes back into
Auto scrolling okay so we have the
dashes I am not pressing any key now as
I press yep there you go there's the
message if you don't see it make sure
the game window is in Focus so select
the game View and click right here on
the middle to make this one the focused
window then if you press the doubling
key you should see the message and if I
Let Go yep it is a nice Dash okay great
so all the basic logic is working back
in the code here now that logic is
working let's get rid of the else here
and let's set test for all of the other
keys so let's copy paste this so we're
going to need w a s and D so let's make
all of
these okay so we have our inputs let's
also get rid of the logs we don't need
this all right so we have all of our key
presses now let's construct a vector
with our inputs and since we're just
going to have to X
the Ws that is forward and backwards and
this one is left and right so just two
axes so because we have just two let's
use a vector two and let's call it the
input
Vector let's construct it so we do new
one and start off at 0 0 okay then over
here the logic is pretty simple so when
we press W then let's go into the input
vector and set the Y to plus
one then when we have an S we want to go
backwards so put the Y on minus one for
the a we want to go left so that's an X
on the minus one and finally for the D
that is an x on plus one okay so with
this we have our correct input Vector
let's do a quick log just a test so
debug. log on the input Vector okay so
let's test all right so we can see in
log 0 0 okay makes sense now if I press
W yep we've got an one on the Y if I
press a we got minus one on the X press
D+ one press s and minus one okay great
so everything works except we also need
to be careful about one other thing if I
press press both W and D with this look
at that the vector is 1 one which is
correct that's exactly what we did
except the vector 1 one actually has a
bigger magnitude than just one vector if
we leave it like this then the character
will move faster when moving diagonally
versus when moving in just one direction
for our input Vector we really want it
to be normalized meaning we want it to
have the same size regardless of the
combination of keys that we're pressing
so back in the code here after
calculating the input Vector let's
simply normalize it so we go into the
input vector and we set it equals to
input vector. normalized so this will
normalize our input Vector let's see now
over here if I press dou yep got one
press s minus one okay so all those work
now if I press both W and D yep there
you go now it says 71 when you combine
both these and you do the math these do
end up with a magnitude of one so with
this our character will move at the same
speed on both diagonals and straights
okay so we have the input Vector all
correct now let's actually apply some
movement for that there are many ways of
making a character controller for
example example you can decide to use
physics or not over here I want to keep
the game simple so let's not use physics
instead let's just move the player
transform directly over here we have our
input Vector okay great now we want to
apply this to our character position so
first we access the transform this one
refers to the transform where this
script is attached to this script was
attached to the player so this is going
to refer to the player transform then we
want to modify the position so let's
access the position and now for moving
we don't want to just assign it if we do
something like
this like this the player would never
leave the center of the world it would
always be near 0 so instead we don't
want to just assign it but instead we
want to add onto it now if you're a
complete beginner and you don't know
this syntax then this one is exactly the
same as this so transform. position
equals transform. position plus input
Vector so both these two lines are doing
the exact same thing personally I prefer
to use the shorthand I find that equally
readable and more compact Okay so we
have this and we add our input Vector to
the transform position except we can
also see a really nice error basically
it's telling us that we are mixing two
types our input is a vector 2 where we
only have an X and A Y but transform.
position is a vector 3 meaning it has an
x y and Zed one simple solution is to
cast our input Vector onto a vector
three so we just convert this from one
type into the other one and yep we don't
have the error so let's test and now if
I press W and yep the character does
move Let's ignore the massive speed for
now so it does move it does seem
slightly correct except you can
obviously notice that it's not correct
we are moving on the x- axis on left and
right that is correct but then we are
moving up and down instead of forward
and back basically we convert the vector
2 directly into a vector 3 so we are
moving on the X and Y axis but in our 3D
game we really don't want the characters
to fly so instead we want to move on the
X Z axis so back in code here instead of
directly casting this down into a vector
3 Let's construct a move Deer vector
so let to a vector 3 let's call it our
move Deer for our move Direction and
over here we construct a new Vector 3
and basically we're just going to assign
the input y to the Zen on here so first
of all for the X that one is correct so
input vector. X then for the Y let's
leave this one on zero and finally let's
use the input vector. y as a Z On The
Move direction also now at this point
you might be questioning if we're using
a vector 3 here why don't we also use a
vector 3 up here and then just assign
the said directly that's certainly a
possibility and for making a super quick
prototype I might even do that myself
but the proper answer to that is once
again all about writing good clean code
the input logically only has two axes
there's no Z axis on your keyboard so
logically it makes no sense for the
input to have three axis and beyond that
you should keep the logic separate so
you should first get the input and then
actually move the object we're going to
see the benefit of that separation when
we refactor this code to work with the
new input system doing that that will in
turn make enabling game pad j6 support
super easy because we have the input
Vector separated from the actual
movement so all of that to say let's do
things properly let's keep the input
Vector separate from the movement Vector
so we just translate the XY onto X Zen
and then we just apply this into our
transform position okay so let's test so
now if I press D go right go left and
press W and S and there you go okay
great so it is indeed moving Left Right
forward and back okay great so it is
working but as you can see it's moving
insanely fast you might think the issue
here is just applying some sort of
movement speed multiplier except there's
actually one sneaky issue here here on
the game view on the top right corner
we've got a stats button and over here
we can see a whole bunch of things
specifically we can look at the frame
rate we can see that it's running at 144
frames per second over here on the left
side on this button I have vsync enabled
this will cap the frame rate to the
monitor's refresh rate so that is why
I'm seeing 144 Herz I can over here
disable V sync and yep look at that goes
all the way up to 700 basically now the
game is running as fast as my computer
can run it and if I press the movement
keys and look that now it's moving even
faster now I've completely lost track of
where my player is this is not what we
want we don't want the player to move at
different speeds depending on the frame
rate we want it to always move at the
same speed regardless of frame rate so
when you do any kind of movement Logic
on an update you always need to make
sure to multiply by time. Delta time
what this variable contains is the
number of seconds elapse since the last
frame for example let's add log to this
we don't need input Vector so let's log
just the time. Delta time okay so we can
see there that is basically telling us
how many seconds it is taken to render a
single frame once again note how I have
vsync enabled so I'm running at 144
frames per second and now if I disable
it let's see what happens to that number
so if I disable and you have look at
that that number is now much much
smaller and the game is now running much
much faster so by incorporating this
value into our calculation we are going
to be taking into count the frame rate
does making sure that the movement is
always frame rate independent right now
with this frame rate if I move you can
see I'm moving at this speed and now if
I enable vsync change the frame rate and
I move and I'm still moving at the exact
same speed okay that's great except
obviously it's not exactly great it's
moving way too slow so let's also
incorporate a movement speed now for
this once again most beginner tutorials
will teach you to go all the way up here
and find a public float move
speed maybe defaulted to some valum like
7f some like that then you have this
field and then down here you simply use
it in the calculation so movement here
move multiplied by move speed and by
time. time so this is what most
tutorials would teach you by making it
public up here what you're doing is
you're enabling access from the editor
so if you go over here in the editor
over there on the player we can see the
move speed variable we can see this
Expos and we can modify it this makes it
really easy for testing and for
iterating upon the value even while the
game is running so the game is playing I
can move and I have this move speed now
I can modify this and yep now I got a
different move speed so I can use this
to quickly iterate and find the perfect
value so it's great to have this
variable exposed in the editor and this
feature is indeed the reason why most
beginner tutorials would teach you to
make it public it's so you can see it in
the editor that is indeed a very
valuable thing being able to easily
trate upon important values is always
very useful however when you make
something public when you do that you
don't just expose the film to the editor
you are exposing it to every other class
in your entire code base so some other
class could access this field and set
the player's movement speed to something
like zero and you would have no idea
that was happening because the issue
would not be on this code right here I
have an entire video on this subject why
you should not make everything public
this is an extremely important topic to
know about this one tiny change will
massively improve the quality of your
code definitely go ahead and watch that
video to learn why such a bad thing and
make sure you don't do it so to avoid
all kinds of problems you should never
make Fields public so very quickly the
obvious alternative is make it private
making it private means that only this
class only the code in here only this
can modify this field so you know for
certain that no other class can ever
modify this however making it private
also means the editor cannot modify this
field so we've lost our very useful
iteration approach so what we can do to
expose it just to the editor is to keep
it private and then we add the attribute
serialized field this way this field is
still private meaning that it can only
be modified by the code inside the
player class
but with this attribute over here in the
editor yep we do have an editable field
so only the code in thatass and the
editor can modify it nothing else can
touch it nothing else can read or write
which is exactly what we want one of the
main rules in writing good clean code is
minimizing complexity and one of the
easier ways to minimize complexity is
simply to minimize access by making this
F private we are minimizing complexity
because it doesn't matter how complex
our game is maybe our code base is a
thousand classes long it doesn't really
matter because only this class can ever
touch this field so if we have a bug
related to movement speed we know for
certain it has to be inside this code
and nothing else so we minimize the
things we need to keep in our head which
is always a very good thing okay so with
all that said we have our movement speed
and down here we are incorporating it
into our calculation just with this we
have our character working with a
variable movement speed and by using
Delta time we have our movement
correctly being frame rate independent
so here's our character and using the
keys I can walk around and yep the
character moves in any direction so we
have movement fully working while using
the Legacy input manager like I said
we're going to learn how to refactor our
code to use the new input system
learning how to refactor is an extremely
important skill to improve your own
programming skills it is something that
you should always do when necessary it
will massively help you improve the
quality of your code so we're going to
do that but before we get to that let's
actually do something a bit more fun and
add some proper visuals and animations
to our player in the next
lecture hello and welcome I'm your code
Mak in this lecture we're going to
replace our barding capsule visual with
a nice proper character mesh okay so in
the included assets project files over
here if we go inside the prefab visuals
we see a nice player visual let's
position it inside the player game
object so let's drag it inside again
because we separate the logic and the
visuals this is going to be pretty easy
we don't need to modify the parent game
object at all we just drop the visual as
a child that's it also again very
important make sure the visual is over
here on local position 0000 0 only the
parent game object should move the
visual itself should never move if you
notice some weird positions as your
player moves and rotates always check to
make sure that the child visual is on
0000 okay so with this let's delete the
old capsule deleted okay so here we have
a pretty simple but really nice
character visual it's really just two
spheres stacked on top of one another
with a bunch of eyes very simple for the
visual itself the material is using just
a solid color so here it is inside the
assets material you can see a bunch of
player bodies with different colors
these different colors they won't be
used in the upcoming multiplayer video
basically each player will have a
different color also by the way if
you're a complete beginner here's a
quick lecture on materials these are
materials and if we collick select we
can see a bunch of sets related to that
material basically the materials have a
Shader and then a bunch of properties
now the Shader is the actual code that
runs on the graphics card that says how
an object should be rendered by default
you have a whole bunch of included
shaders we're using the universal render
pip line so you should mostly be using
the ones inside the urp and by default
you probably want to be using the
standard light Shader then of course you
can also build your own custom shaders
when excellent tool for doing that is
Shader graph which I have covered in
detail in a previous video it's a fully
visual tool that you can use to make
shaders without having to write any
Shader code it's a great tool I've also
made a bunch of tutorials on all kinds
of effects you can make although right
now we're not going to be using custom
shaders we're going to do that later on
the course but for now we're going to
stick with default light Shader so
materials have a combination of shaders
and the properties on that Shader for
example over here for the default light
Shader you can see that it has over here
a base map that it has a color field
this is what you can change to apply a
different color to your player also as
to how you apply a material to an object
over here on the player visual you can
see the objects are made up of a sphere
so this is the mesh and then the mesh
render this is the one that has the
material so both these are what stores
the shape as well as the visual for the
object the mesh is just 3D shape but
just by itself the mesh filter doesn't
actually render anything so it needs a
mesh render which needs a material
attached to it so for example over here
on the hierarchy let's right click on
empty space and let's create a brand new
Cube just to see it so yep there you go
it does create an object and as you can
see it has a mesh fter and a mesh render
now to apply a different material you
can click on this little circle icon and
it shows you all the materials in that
project alternatively you can grab the
material directly from the project
window so for example the player body
just grab it and drop it in there or you
can also drop the material over here on
scene view as you can see as I Mouse
over different objects it applies that
material to a different object although
note that only works over here on scene
view it does not work on game view so
this basically sets the material over
there on the object now one more very
important thing on materials if you have
multiple meshes all using the exact same
material and then you modify the
material it will change the visual on
all meshes using that material so for
example if I modify the color here put
it on some different there you go all
three instances all three objects that
are all using the exact same material
they all update with the new color if
for example you wanted the head to be a
different color from the rest then you
would just create new material so you
can right click on the project window
let's create a new material then you can
give it name give it colors use
different shade or whatever and then use
this one for something different so
that's pretty much the basics for
materials and by the way if you're a
complete beginner and you have questions
remember to post them in the comments
and I'll do my best to help like I said
I want to keep this video moving I'm
trying to teach as much as possible
while still keeping the video a
reasonable length so if you need any
further clarification on anything
specific just go ahead and ask in the
comments okay so when materials out of
the way here we have our player with
visual let's just get rid of our Cube
okay and just with this if we test and
yep over here we already have a nice
player visual walking around okay great
except the player isn't actually
rotating ideally the visual should be
facing the walking direction so if I
walk down it should be rotated to face
down so let's add that doing that is
actually going to be pretty simple let's
go into our script here we are on the
player script and over here we already
have the movement Direction so we're
going to use this in order to make sure
to rotate the game object to face this
move Direction and for rotating a
transform there are many many ways to do
it one obvious one is to modify the
transform. rotation however this one as
you can see works with querian for me
even though I've been doing Game Dev for
over 10 years I still find qu is quite a
bit confusing so I normally don't use
this method another method is to modify
the transform. oiler angles this one is
much more intuitive and makes more sense
to me it works with regular Oiler angles
which is much easier to understand if
you don't know that name it really just
means the angles that go from Z to 360
then for another method you can also use
the function transform. look at this one
makes a transform look at a certain
point so it can be a transform Target
can be a vector 3 for one position
anything like that so this is a very
useful function we could calculate a
point right in front of our move
Direction and look at it or finally the
method that I personally like to use for
this specific purpose which is just
modify the transform. forward this one
has the normalized vector representing
the forign AES and importantly you can
get it and you can also set it so you
have both read and write you can read it
to get the current transform forward but
you can also write to it to essentially
rotate the transform so we can just
assign this to our forward Vector also
by the way you also have transform. up
and transform. right both these work
exactly the same way for example
transform. right this one is extremely
useful for 2D games but over here we're
working in 3D so we want transform.
forward and all we need is the forward
Vector which is really just the move
Direction so let's set this one equals z
move there okay so just like this it
should already work let's also just
clean up the log we no longer need to
see the Delta time okay so let's like
this okay here we are and as I move and
Y there you go look that the player
object does indeed rotate to face the
move Direction okay so it's already
looking great all right awesome however
it also looks a bit odd with how it's
instant so I move left and right look
that it instantly rotates so there's no
smoothing nothing it's way too junky so
let's add some nice simple smoothing and
for that let's use a really awesome
really useful math function called lurp
it helps you interpolate between two
values I made a quick video showcasing a
bunch of uses for it you can lurp floats
Vector 3 quion or just about anything
it's really perfect for making some
smooth movement or smooth rotation so
for that we can access the function
inside the vector 3 class so we can find
lurp then here we actually have two
options we've got lurp this one
interpolates and we've got slurp this
one interpolates but with a spherical
interpolation basically if you're
dealing with rotations like what we have
here then we want to be using slurp
whereas if you're dealing with just
positions then you want to use slurp so
here let's use slurp this one as you can
see takes an a a b and a t like I said
this interpolates between A and B based
on T so for example if T is zero then it
won't return the value a if T is one
then will return the value B if T is5
then will return the point in between A
and B if you want to learn some more
about interpolation and the math behind
this then I highly recommend you look at
my video on splines splines are
basically just a whole bunch of lbs put
together so anyways over here we can add
some smoothing to our Rotation by just
using the current transform. forward as
our a then for the B this one is our
Target so let's use the move there and
finally for T let's use time. Delta time
meaning that with this over time the
character won't rotate towards our
Target movement Direction so just with
this let's test so here if I move to the
right and yep look at that it is indeed
rotating it's way too slow but yep it is
rotating smoothly all right so let's
just add a bit more speed so over here
let's just find a float for the rotate
speed let's put it at something like 10f
then we just multiply it so time do time
multiply by our speed let's see and move
and yep there you go look at that much
much better okay great so as you can see
everything works as I move the character
does rotate to face the move Direction
all right great so here we have our
character with a nice visual all
rotating to face the move Direction now
the next step is we want to add some
nice animations so let's do that in the
next
lecture hello and welcome I'm your Cod
Maki in this lecture we're going to add
some animations to our player character
now I have already included some
pre-made animations with a pre-made
animator over here inside the access
folder but let's first do it from
scratch just so you'll learn how to do
it first to animate we're going to need
the animator component if we go inside
the player visual game object once again
remember all the visuals go on the
visual game object so for adding the
animated component we want it on the
Visual and not on the logic component so
anyways over here as you can see by
default I already attached it with the
assets included but let's do it from
scratch so let's remove this by default
now let's add a new component let's call
it an animator also one very very
important thing here it's the animator
component not the animation component
these two are completely different the
animation component this one is actually
related to unity's Legacy animation
system from a very long time ago it's
only here pretty much for backwards
compatibility and for super simple use
cases so most of the time make sure
you're using the animator component okay
so to drive this animated component we
need an animated controller let's go
into our project files and let's create
and create a brand new animator
controller let's call this my player
animator then let's select the player
Visual and just drag the controller on
there okay again if you have issues and
you cannot drag the animator onto the
film make sure you're using the animator
and not the animation component okay so
with this we have assigned our animator
controller and now let's double click on
it to open the animator window and if
you don't see it then go into window
then go into animation and open up the
animator window and also if you still
don't see anything then maybe you might
have some issues with your layout if
that's the case then go onto the top
right corner layout and go back into the
default and then back into your own
layout and finally if you still don't
see anything on this window if you don't
see default states make sure you have
the object selected in the hierarchy so
with that you should be able to see
these states so this is our animator
controller now I have a really detailed
overview of the animator and the
animation windows in my ultimate unity
overview course so you can go watch
those lectures for some really in-depth
explanations about everything this does
basically the animator is a state
machine so you have various States and
you can create transitions between each
state by default you have these three
special States there's the entry State
exit and any state these are used for
making transitions but we don't really
need to worry about them just for now
first let's just make a basic new
animation and for that the easy way to
do it is to open up the animation window
so let's go up top into window go into
animation and open up the animation
window so here it is again that's a
different window that's animation not
animator and for me for for this window
I like to dock it down here so there's a
nice timeline so I think this is good
okay and now if we select the object in
the Hier key that has our animator then
we can see the text here so to begin
animating we've got a nice button to
create an animation so let's go ahead
and click on this and now let's give it
a name for now let's first make the idle
animation so let's just call this idle
and if just like that we have created an
animation you can see the animation
window down here has changed we now see
a nice timeline showing the time and
also on the animated controller you can
see the new animation was added as a
brand new state so a new state was
created and if you click to select it on
the right side on the inspector you see
the motion so the actual animation
selected and you can also see that
there's an arrow pointing from the entry
onto the anal state so that means this
one is going to be the default State
when the animated controller starts it
will start playing right on this state
let me just point out one more thing
related to animations so on the project
window we can see yep here is our
animation that we just created and you
can see the inspector looks just like
this now if your inspector looks
differently that might be because you
accidentally created the Legacy
animation that has to do with the
previous animation system that I talked
about the one that is Legacy that should
really no longer be used so if you see a
different inspector then a quick way to
fix it is to click on these three dots
on the inspector these three dots then
you change the inspector into debug
inspector and over here you see a toggle
for legacy so for the animations that we
want to use right now we do not want to
be using Legacy animations so make sure
this one is untoggle if in your case
toggled just un toogle it then go back
into the normal inspector and now yep it
should look just like this okay so we
have our animation and now it's on our
animat controller now let's actually
make an animation so let's select the
animation window and again let's make
sure to select the object so let's
select the player visual game object so
here on the animation window we see this
nice little red button this one enables
or disables recording so if you click on
it you can see yep the timeline is now
red meaning that we are now recording
and now we can do anything to any chn
objects and it won't record any changes
we make now note what I said that's very
important it needs to be child objects
if you select for example the parent
game object then all of a sudden it's
stop recording so you can only animate
child objects so let's select the player
visual let's enable recording then let's
expand the player visual let's make sure
that our timeline is on zero so drag it
all the way to the left and now for
example let's grab the head object and
let's move it just a tiny tiny bit
basically just move it enough in order
to make sure that the position over here
is in red meaning that we have recorded
a key frame then let's drag the timeline
by a little bit let's go over here to
frame three this one is actually going
to be half a second and it's going to be
that because over here on the samples
this is the frame rate for the animation
so at 60 that means we have 60 frames
this makes 1 second so 30 frames would
be half a second you can also zoom out
by scrolling over here or dragging the
handles down here so let's go into 30
half a second and now this one let's
move the head by a little bit something
like this as you can see down there we
can note that it record the new key
frame and now if we h on the play button
we can preview the animation and yep
look at that it does do exactly that so
it starts off down and then moves up
okay so that's great but we don't want
to snap back so let's actually add
another key frame right at the end so
let's stop playing the the animation and
to make sure we have a perfect Loop
let's just click to select the key frame
let's press contrl + C then let's go
down into the 1 second Mark let's press
contrl + V and there we go there's the
exact same key frame so now if we head
on play yep there you go we have our
nice seamless Loop so the head goes up
and down and repeats forever all right
awesome okay so that's great now let's
also do one thing let's also record a
key frame on the body however we don't
want it to move at least not in this
idle animation we just want to have a
static key frame so let's the body and
let me actually move it a bit to the
side just to make sure to record and now
manually we can modify things over here
to modify the actual key Frame data so
on this one I don't want it to move so
let's put it all the way back at zero
just make sure we have a nice key frame
recording now the reason why we are
recording the body position even without
moving it is because the walk animation
will indeed move the body but when we
get back to idle we want the body to go
back to this exact position so that is
why we need a key frame here okay so
that's done so we can stop recording so
let's click on the red button again okay
great by the way one more note to make
sure that the animation Loops go into
the project window and over here select
the animation and make sure Loop time is
enabled it should be there by default
okay so the animation is set up and if
we look in the animator it's already the
default state so if we head play we
should be able to see the addal
animation playing non-stop so let's hit
play and you there it is the Addle
animation with the head moving up and
down everything works perfectly all
right awesome okay so next up let's make
a walk animation now for me when I'm
making an animation that is based on
another one I like to actually duplicate
it inste of starting from scratch so
over here on the project window let's
select the utle animation and let's
duplicate it so contrl D let's rename
this one to the W animation and now if
we select the player Visual and then we
go into the animation window over here
we see a nice little drop- down menu for
all of the animations except right now
we don't see the won animation we only
see the idle animation that is because
this menu only shows animations that are
attached to the animator so first we
need to add the animation onto the
animator component and how we do that is
actually super simple let's just open up
the project window and just drag the
walk animation and drop it here that's
it so with this we have attached a new
state to the animat controller and now
if once again we select the object in
the Hier key go into the animation click
the drop down menu and yep now we do see
the won animation so let's click to
select this one and now for this one
let's make the animation so let's look
in scene View and make it bounce just up
and down so I'm going to enable record
go back here and for the body this one
already has a key frame so let's go up
here move it a little bit and then copy
the key frame put it the same one at the
end something like this so there you go
it just goes up and down let's actually
put it offset so it look a bit better so
something like this by the way in a bit
we're going to replace these animations
with the ones that I made previously so
don't worry about making the animations
perfect unless you want to do that okay
so there you go that's the animation
although for walking should be much
faster so here's a quick animated tip
this top bar here lets you select all of
the key frames within a certain time so
if I click to select note how it selects
both those key frames and also if you
click and drag once on top of here you
can select multiple key frames so for
example to select everything just click
and drag to select all of them and now
you see these nice little vertical bars
so if you click on the those and then
you drag them you can basically modify
the time of all the animations and
everything matches up so for example
let's make this one super fast let's put
it just 20 frames there you go now it's
a much faster walk animation okay great
let's click on the right to stop
recording all right and back in the
animator so over here we have both
animations and now what we need is to
make a transition going from idle into
wonk otherwise the won animation will
never play so how we make a transition
is also super simple let's right click
on the idle State let's make a
transition then now we have a nice
little arrow under the mouse and now if
we go into the walk and click on it
there you go we have a nice transition
now we can click on the transition
itself to selected and over here in the
inspector we see a bunch of transition
options so let's expand the settings yep
there you go everything now like I said
I covered all of these options in a lot
of detail in my ultimate unity overview
course so if you want to learn more go
watch that here let's just learn the
basics for how to achieve our goal in
making a simple player animator the
important one is over here the exit time
basically if this one is toggled then
this transition will be triggered
automatically meaning it won't play the
out animation and immedi transition into
the wonk animation so for example if we
hit play and look at it quickly you
there go there's the idle and you have
transitions into wonk and now it stays
there forever okay so that's good but
not exactly what we want we want the
walk animation to only play When the
character is walking and when it stops
we want it to go back into the idle
animation now for that we need to use
animator parameters so back in our
animator on the top left corner we see
something called layers we don't need to
worry about that for now and the next we
we see parameters then we can click on
the plus button order to create a brand
new parameter and you can see all the
various types that we we can create now
for woning we want something that we can
set to either true or false so let's go
with a nice bullion and for name let's
call it is woning again pay very close
attention to the capitalization this is
extremely important just like code is
walking is different from is walking so
make sure the capitalization is perfect
okay so with that we have our nice
parameter now let's click on transition
going from idle into won and now let's
untake exit time we don't want this
transition to trigger automatically and
as soon as we do we see this nice little
warning basically it's telling us that
this transition will never happen so
over here we have the nice conditions if
we click on the plus icon we can add
some conditions and for this one we want
this transition to happen from idoling
to walk when the parameter is walking is
set to true so that's it this is our
transition now let's just do the reverse
so let's right click on the walk make
Transition go back into idle let's click
to select transition get rid of the exit
time and conditions when is Walking is
set to false okay so just like this our
basic animation logic should be working
so let's test so here we are and the
character is playing the an animation by
the way can look at the animator while
the game is running so let me just drag
the animator window just drag it and put
it on the side of the game view so we
can see both at the same time okay great
and right now note how it's not updating
so there's nothing moving over here on
the animator component that is because
like I said you must select the object
so on the Hier key make sure you select
the player Visual and yep there you go
now you do see that updating so make
sure the object is selected in the Hier
key and now over here we see a nice
little progress bar showing the addal
animation constantly playing and looping
okay great and another important thing
is over here the parameters you can
manual ually change the state of these
while the game is running so for example
if I click it's going to trigger the is
walking parameter which should trigger
this transition and should go into W so
if I click and Y there you go
transitions into the won animation and
now yep it is playing the wonking
animation and if I click to untick it
look at over there what happens untake
and there you go transitions back into
idle all right awesome so as you can see
we have all of our logic working we have
the animator with both of our states and
by changing this parameter we can change
which animation is playing now of course
the goal is not to trigger this manually
by clicking on it but rather doing it
through code but at least for now we
know that our animator is fully set up
again if you want more detail on the
animator and animation windows and
everything related to animations then
check out those lectures in my ultimate
D overview course and also later on for
more advanced use case I have a video on
the animation rigging package this one
is for more advanced use cases for
making Dynamic procedural animations
it's really fun so definitely check it
out but only after finishing this course
that one is a much more advanced tool
for now let's continue here so we want
to trigger our parameter but do it
through code and again here we have yet
another clean code question technically
we could add that code directly over
here on the player script we could just
grab the animated component and change
the parameter and in this case for this
very simple game that would actually not
necessarily be a very bad approach since
the game is so simple with so few
animations but like I said I want to
teach you proper good practices so let's
make it properly and actually separate
the animations from the logic for that
let's go into our project right click in
our scripts folder create a new C script
let's call it the player animator let's
select the player visual game object and
attach the component okay okay so now
here first let's grab the animator now
one approach is like we've seen we could
just make a serialized field and drag
the reference in the editor that's one
approach or alternatively since the
animator is attached to the same game
object as this script then we can just
do a get component both approaches are
really valid so here let's use get
component just to see a different
approach so we just have a field for our
animator so animator and then we just do
a private void awake and on a w let's do
get component of type animator and we
set our animator variable again like I
mention very important make sure you
don't mix animator and animation these
are two different components we want the
animator okay so with this we have a
reference to our animator component and
now how we modify the parameter is
actually very simple we just access the
animator and then we have a bunch of set
functions you can see we have one for
each type so we've got a set bow set
float then down here a set trigger set
Vector so function to set any parameter
type now we made the bullan so let's use
the set B and this one as you can see
takes the name for the animator
parameter by the way strings are a hor
horrible horrible way of identifying
things but sadly this system really does
require strings to identify the
parameter we want to change if you're
wondering why strings are bad for
identifying things the reason is because
it's very easy to make a mistake for
example if you use is walking here then
this will work however if you instead
write is walking then all of a sudden
does not work if you write is walking
like this doesn't work like this doesn't
work and even though it doesn't work it
will also not throw any compiler errors
that is because for the compiler a
string is a string it's always valid but
then when the code runs this one is
going to be different than our parameter
which is named the Exel like this always
remember that strings are case sensitive
so that's one reason why you should
never use strings to identify things
it's very very easy to make tons of
mistakes that are then very difficult to
find out but like I said in this
animator system we have to use strings
there's no other way in order to
minimize our usage of strings one thing
we can do is for example let's find find
a constant up here so let's make a
private make it Con for a Conant meaning
this will never change make it up type
string and call it is walking again
refer back into the naming R section for
constants we always use uppercase snake
case so is walking and let's set it with
is walking again make sure you don't
make a mistake here make sure you type
it exactly like you did on the animator
then down here let's use is won and now
if we do make a mistake so if we
accidentally use something different now
we do get a compiler error so at least
we have a little bit of protection okay
so this one takes a string for the name
and then a simple bullion for the value
so this going to be the value that we
want to set to our parameter now for
this one we want to set to True when the
player is walking and false when it's
not so for that we need to ask the
player what it's doing so let's go over
here into our player class and let's
make a function to return just that so
let's make it public because we're going
to access it from another script we're
going to return a bll and call it is
walking now over here we just need to
return if the player is walking so let's
make a local field to store that safe so
over here private ball is walking again
note the capitalization for fields we
start with camel case whereas for
functions we have Pascal case so these
are different okay so basically in order
to Define if we we are walking that's
very simple it's just down here we have
the movement Direction so we are walking
if the move direction is different from
Vector 3.0 which by the way Vector 3.0
is just a shorthand for writing 0 0 so
if the movement direction is different
from zero then we are indeed walking so
we Define that we update that field on
every update and then over here we just
return it okay just like this and now
back in our player animated component
over here first we need a reference to
the player so let's add it here let's
add a serialized field of type player
and we need to compile this in order
drag the reference so let's just comment
out this line just to make sure the code
compiles now here with the code compile
let's drag the reference of our player
okay that's it and then over here for
the animator set is walking let's go
into the player and let's ask is walking
and of course we don't want to do this
just on awake we want to do it on every
single frame so let's do a private void
update and on update let's do this all
right that's it so this should be
working let's test so here we are
starting off as Idle and now as I move
yep there you go it is playing The
Walking animation and now if if I stop
and you there go back into Idol all
right Awesome everything does work
perfectly okay great we can even look at
the animator to see the state change so
here with both side by side and with the
object selected in the hierarchy right
now you can see is walking is false so
it's on idle and as I move that one says
true that one goes into walk and now I
let go if there go back into false back
into idle all right awesome so with this
everything is working perfectly if
you're having issues make sure you pay
attention to the capitalization so make
sure the name you wrote here is the
exact exactly the same one that you
wrote here and it's exactly the same
that you're using here all right so all
of our animations are working perfectly
now if you want you can go ahead and
make your own animations or you can use
the ones that I pre-built so in the
included project files inside the assets
here we've got the animations and we've
got the player with the idle and the
walk animations if we double click on
this to look at it you can see yep it
looks exactly the same so there's a
parameter called is walking and our
transition so everything is exactly the
same just over here let's select the
player Visual and on the prefab like we
saw we already had the animated
component we just remove that one from
the prefab in order to build it off from
scratch but if you want to use my
animations then we can just go ahead
remove the animator that we added and
then right click on this one on the
remove component let's revert back to
changes and there you go here we have
our animator with the player controller
so that's the one in the included
animations and just like this if we h on
play and actually over here I found an
issue although in your case there
shouldn't be any issue because I have
updated the assets but this is a good
time to teach you about any issues with
animations so if you select the
animation and you select the animation
and over here you might see some of them
in yellow saying missing basically the
way that animations work is based on the
actual name of the object if it cannot
find an object with the exact same name
then it cannot load the same animation
so my problem is that when I initially
made the assets package I made this
animation and the object was previously
named face and then I renamed it thee so
now it no longer loads so if you ever
have problems with loading animations
just make sure the names perfectly match
so in my case I can just click in here
in order to rename this key frame on the
animation and I'm just going to use the
name that I renamed named it so head and
just like this yep the animation does
play correctly so just a nice quick tip
if you ever have problems with
animations always remember that the
stored key frames they're all stored
based on name so if you rename the thing
in here or over here on the game object
if you rename you're going to have
missing animations but if you make sure
the names match and the animation should
load perfectly so let's head on play and
there you go there's the add animation
and if I move yep there's the nice walk
animation so everything still works
perfectly because it's only using the
exact same parameters all right awesome
so like I said if you want feel free to
make your own animations or use the ones
that I've included for me I'm going to
be using these ones so the ones that we
made just for learning which I created
down here so the M player animator and
these animations I'm just going to
delete these just to keep the project
clean so just delete and just like that
okay so now that we have our character
fully working let's quickly handle our
camera hello and welcome I'm your code
monkey in this lecture we're going to
quickly install C Machine this is a
Unity tool that makes handling cameras
super easy our game isn't really going
to have a moving camera so this part
isn't strictly necessary but s machine
is a super useful tool so I definitely
want you to learn about okay so let's
begin by installing the package let's go
into window open up the package manager
then up top let's make sure we are in
the unity registry make sure you're on
the all Tab and now just scroll down
until you find yep there it is C Machine
okay so let's go ahead and install
this all right it's installed so let's
close this and now the way that sin
Machine Works is by creating what is
called a sin machine virtual camera so
let's go up top into the game object
menu then scroll down into sin machine
and over here you can see that we can
create a multitude of virtual camera
types now just by the names you can see
how this tool is insanely useful for
example making a fre low camera doing
that from scratch is a bit tricky but
with s machine it is super easy for our
case like I said we want the absolute
most basic thing possible so let's just
create an empty virtual camera okay
that's it this creates a virtual camera
over here in the Hier key and turn this
object has a s machine virtual camera
component and also importantly when we
added this it also added over here on
the camera if we scroll down we can see
it has a C Machine brain component
basically the way C Machine Works is it
works on top of the main camera so it
doesn't replace it it works on top of it
and drives the main camera so now that
we're using C Machine if we try
modifying the main camera game object so
for example over here if I try to drag
the FI of view nope does not work I
cannot move it if I try to move the
position nope can't do it if I try to
rotate it nope that does not work like I
said when working with sin machine the S
machine brain is what drives the main
camera so rather than modifying the
things over here on the camera itself
what we need to do is change them on the
virtual camera so over here we have
pretty much the exact same options that
we have on the main camera for example
modifying the fov over here we've got
the lens so we can modify the fov and if
we look in the game scene as we modify
this one yep it does modify the actual
properties on the actual main camera now
this has tons and tons of options
related to everything the most important
ones are all kinds of options down here
for the body and the aim so this is
where the camera is position and where
it's looking at using this you can make
a follow camera in 5 seconds it really
is insanely useful if you want to learn
about C Machine more detail I have a
dedicated video on it I go through what
all of these options do then I also have
another super detailed video on how to
make a camera system with pan Zoom
scroll in both 2D and 3D and a bunch
more features again all of it using S
machine but in our case we really want
to keep it simple so let's just position
our virtual camera on the same settings
that we had previously so first let's
set the FI The View so for our game we
want something narrow so let's go with
just 20 then for the position let's put
it above so zero on the X then 21.5 on
the Y and minus 21.3 on the Zed then for
the rotation 46 on the X and then zero
on the others okay so our camera is
positioned in the exact same position
and if we head on play yep everything
still works the same the camera is
looking from the same point of view and
the character still works everything's
still exactly the same now since we're
using cin machine we can easily add some
things on top of this like for example
we can add some noise to our sin machine
camera to make it smoothly move a little
bit this one is a fun simple effect that
can make our game feel a bit more
Dynamic especially in games like this
where we have a fixed overhead view how
we do that is over here on the in
machine virtual camera we've got a film
for noise so let's click and let's
select basic multi Channel pein and then
over here we've got the noise profile so
we can choose one of the included ones
or we can create our own profile so for
example let's go with handheld normal
mild and by the way you can actually
modify these settings while the game is
playing so here it is the game playing
and you can see what this effect does it
adds a nice little wobble to the camera
and then over here alude and frequency
so we can play around these so you can
make it really intense so something like
this that is way too intense so there
you go quite a lot so for something more
subtle maybe put 0.5 and 0.5 there you
go just a slight little movement in the
camera so this would help make the game
a little bit more Dynamic so this could
be a fun effect although actually in my
case in order to make sure that the
video doesn't get way too compressed I'm
actually going to Z this on my end so
just set the channel noise to none but
you can see how easy it is to add
complex Cammer features when using C
Machine and of course when using C
Machine if you want you can use it to
make your game a lot more unique now for
me I want to design here where the
camera is fixed but let's say for
example you wanted the camera to
actually follow the player like I said
go watch that dedicated video to to
learn all about C Machine but over here
very quickly let me just show you how to
do that but at the same time don't
bother following this part it's just to
show what C Machine can do that I'm
going to revert back to this state so
first of all for testing one great thing
about C Machine is you can have multiple
virtual cameras you can have as many as
you want and then the priority and the
game object enabled state is what
defines which camera is actually being
used so for example on this second one
let's make it follow the camera and put
the priority on 20 so that it's above
then over here for the body I'm going to
select transposer let's put it with
worldspace it requires a follow Target
so let me drag the player as the follow
Target and put it slightly above and
behind Okay so it's pretty similar as
before then for the aim let me also drag
the aim player Target and just with this
it should already work so if I head on
play y there you go look at that the
camera is now moving and falling the
player so I can move the player anywhere
and yep the camera Falls alone so as you
can see it's this simple to really make
some complex camera movement doing some
complex camera logic just like this
would require a ton of work manually but
with s machine it is super easy then you
can even play around with other prior
priority or enable and disable and there
you go C Machine even transitions
between the state of all your virtual
cameras so as you can see lots and lots
of things you can make with your camera
very easily all thanks to S machine like
I said in my case I just want a fix
overhead camera so I'm just going to
delete this secondary virtual camera and
there you go just this one on top
looking at the player looking down with
a low fov and Yep this is the exactly
the kind of camera that I want for my
game okay so that's in machine it's a
really awesome tool for making camera
handling much much easier so this was a
quick lecture all about learning about
in machine now let's handle the test
that was actually left undone quite a
while ago let's finally learn how to
refactor code and implement the new
input system so let's do that in the
next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
refactor our code from the Legacy input
manager onto the new input system so the
simple character controller that we made
is working perfectly fine with the
Legacy input manager like I said this
one is excellent for making quick
prototypes and demos as you can see it's
super easy to use but now let's quickly
refactor this code to use the new input
system instead also like I said in the
beginning of this course here I'm going
to be focused primarily on building this
game so for example for any Unity tools
that I use like the new input system I'm
going to cover enough to be able to use
a tool and Achieve our goals in building
this game but of course every tool does
a lot more than just what we're going to
use so definitely make sure to watch a
dedicated videos Link in the description
for example the input system tutorial is
40 minutes long covering everything you
need to know about system whereas here
we're just going to learn enough to know
how to use it so let's refactor this
code to make it work with with new input
system except before we work with new
input system let's just refactor this
code so we can completely decouple the
input from the player class again we
want to focus on writing good clean code
so we should keep all of our input logic
in its own class that other scripts can
access remember the goal with clean code
is to minimize and manage complexity so
every class should do one thing and just
one thing meaning that the player class
should only handle the player and then
the input lass should only handle the
input the only reason why I put this
over here in beginning is exactly to
teach you about refactoring and how it's
a very common thing that you should be
doing all the time this is exactly how I
build my own games I start by making a
prototype and I write the input directly
inside the player class then at some
point I refactor the code to split them
up so don't be afraid to refactor code
it's a Perfectly Natural part of the
game da process and actually a very very
good thing okay so let's make a script
just to manage our inputs let's make a
new C script call this game input let's
create an empty game object give it this
same name input as always keep things
clean so put it on 0 0 0 Let's attach
the script and open okay so here's our
script and let's get everything related
to the inputs on the player for the
input we are culating the input Vector
then getting the actual inputs from the
keyboard and returning the input Vector
so let's put this on the other script so
over here let's make a new function
let's make it public since we want to
access it from the player we're going to
return a vector 2 and let's call it get
movement vector
now here let's really just copy paste
the exact same code that we have on the
player so let's copy paste all of this
let's go and paste it here okay so we
get the input Vector we get the inputs
we normalize it and then return the
input
Vector okay so that's it super simple
also by the way here we have an
interesting question which is do we
normalize the input over here or do we
do it over here on the player both
options can be valid you can make it so
that the game input class returns a
regular input or or you can make it
return a normalized vector you can use
either option but whatever you do make
sure you are explicit so over here I am
going to normalize input inside the game
input class however I'm also going to
make sure to rename this function so
instead of get movement Vector get
movement Vector normalized that way it
is 100% clear this Returns the movement
Vector as a normalized vector okay great
so now let's use this in our player over
here in our player class we need some
reference to our input class now later
on in this course I'm going to teach you
about the Singleton pattern but for now
let's just do a simple direct reference
again remember don't make it public make
it a serialized fi private so over here
let's make a serialized fi private of
type game input and let's call it just
game
input okay so we have this we're going
to drag it in the editor then over here
we simply grab the vector 2 for the
input Vector we simply go into this one
and we get the movement vector
normalized and okay that's it no more
errors let's just make make sure to save
all of our scripts and back in the
editor let's go into the player and just
drag the reference for the game input
okay so just like this everything should
still work everything should work
exactly the same as previously Let's
test and make sure so here we are moving
and yep everything still works I can
move in any direction okay so far so
good and what we have done here is
essentially we have refactored our code
and completely separated the input from
the player class this is an excellent
thing so again don't be afraid to
refactor code also what we did here of
putting the code in a separate class and
then doing a quick test to make sure
that everything still works the same as
previously this is exactly what you
should do whenever you do some kind of
reorganizational refactoring in the end
you want to end up with the exact same
behavior as previously just with a code
organized in a different way okay so now
that we have the separate game input
class now we can very easily refactor
the Legacy input manager onto the new
input system so the first thing we need
is to install the package so let's open
up the package manager let's make sure
up here we are in the unity registry
make sure we are in all and let's scroll
down to find the input system so here it
is let's go ahead and
install Okay the package is installed
and right away we see this message
basically it's asking us if we want to
enable the new input system now you
could click on yes but let's actually go
ahead and click on no we're going to
enable it manually so click on no then
let's close this window and now let's go
up here into edit then let's go into
project settings then on the left side
let's go into player and now let's
scroll down expand over here the other
settings tab and keep scrolling down
until we see yep here it is the active
input handling this is where you can
select which input system you're using
basically if you click yes on that
window it would automatically set this
option to use the new input system so it
would only enable that one and
completely disable the Legacy input
manager but like I said the Legacy input
manager is still pretty useful so
normally for me I prefer to enable both
of them so let's go ahead click on both
and this will restart the editor so okay
let's go all right the editor has restar
so now the new input system is now
enabled okay so the way that this system
works is by creating something called an
input actions asset so on the project
files let's click on the plus icon let's
create something and let's find the
input actions so we need to scroll down
here so click on the little arrow to go
down and find the input actions creates
this file let's call this the player
input
actions okay now let's go ahead and
double click on it and yep there you go
out pops out the input system window
basically this this one is where we're
going to manage all of these settings
for all of our inputs also by the way
like I've mentioned if you're watching
this in the future and for some reason
the input system got a new update and
change this window if so make sure you
check the pin comment I'll keep it
updated with any changes on anything in
this course so over here we've got the
action Maps then we've got the actions
and then we've got properties now action
maps are how you can have different maps
for example one action map would be for
the player whilst walking normally and
you could have another one whilst
driving a vehicle then for the
individual actions in each action map
and finally the properties for each
action again if you want to learn about
the entire input system itself in more
detail go ahead and watch my dedicated
video on it in order for this course to
not to be 20 hours long I'm really only
going to use enough to make sure that we
can achieve our goal so over here we
just need one action map so let's click
on the plus icon let's name this the
player and now for the actions right
away we have a new action so let's just
rename this one let's call this action
move then with this action selected over
here on the Action Properties we can
select the action type again in the
dedicated video I cover what all of
these mean for movement we do not want a
button we want movement in multiple
directions so let's go with value then
over here for the control type for this
one let's go with a vector 2 and then
let's expand our action over here we can
see our bindings however we don't want
this default binding so let's actually
delete this one instead let's click on
the plus icon and over here for the type
first for the keyboard let's go with
this one up down left right composite so
this one adds essentially four bindings
let's go ahead and name this
was then for the up let's select the
bindings so over here on the path let's
click on it then we can either find it
manually over here or click on listen
and now press the W button yep there you
go W then for down let's go ahead listen
s then for the left listen a and for the
right let's listen D okay great so with
this our input asset is correctly set up
one thing you must never forget is up
here make sure to save the asset
you can see this little Sisk here that
means we have unsaved changes also
alternatively there's an autosave there
but for now let's just manually save the
asset okay great so now let's see how to
actually use this in our code there are
many ways we can use the input system
one way is by using the built-in player
input component so for example on the
player we would add the player input so
you could add this one attach an input
actions asset so this is our player
input actions then over here we have
various behaviors in order to be able to
trigger our actions but in this course
like I said I'm going to be using the
exact same code quality that I used in
my own Steam games so I will not be
using this component so let's remove
this instead I will be using the native
C method so let's select the player
input actions and over here on the
inspector we see this nice toggle to
generate a C Class let's go ahead enable
it and for these fields we can leave
them all on defaults that's okay let's
just go ahead click on apply and now
it's going to generate those scripts and
compile them okay great basically what
this is doing is autogenerating some C
code and on the player input actions we
can see over here yep we've got the
generated script if you want you can
even open this to see all of the source
code now all this like it says here this
was all autogenerated so don't make any
modifications here if you change
anything any manual changes won't be
lost when you save some changes in the
input asset so if you want go ahead and
read through in order to see how all
this works but in order to use it it's
actually super simple you don't need to
worry about this script first thing we
need is to construct our script class
that was autogenerating so let's do it
over here in our game input let's make a
private void awake and on awake let's
construct it so let's do a new player
input
actions so we construct an object of
this
type so we have this although just like
this it won't be active so we need to
manually activate whatever action map we
want so let's go inside and let's go
inside the player so this is the action
map that we created and let's call
enable on it okay so just like this it's
really already working all we need to do
is modify our code over here on the get
movement Vector so for that we're going
to need to access this so let's actually
make this a member variable so private
let's store it up here instead of making
a local variable in here okay so we have
this one and then down here on the input
Vector let's go inside the player input
actions inside the player action map and
then we called it move so we've got this
one and then we defined it as a vector 2
so over here we can call read value and
this one takes in the type of the value
now we Define it as a vector 2 so let's
read it as a vector 2 and just like this
this returns a vector 2 which is really
going to be our input Vector so let's
put it exactly like this and we can now
get rid of the rest of it all right so
that's it and just like this we should
already have everything working exactly
the same as previously so let's just do
a debug.log just to make sure so let's
test so here we are and the output is 0
0 now I press W there you go Plus plus
one minus one left right and all of the
ones in between all right awesome so we
have the new input system all of it
working flawlessly also by the way over
here we can normalize the input just
like we were doing previously so we do
it over here through code or
alternatively we can also go into the
player input actions and over here
there's something called a processor so
you can go into this action add a
processor and make it normalized so
these processes here can be quite useful
I covered them all in detail in the
other dedicated video but over here
let's stick with making it through code
that works just as well okay so that's
our refactoring done with that simple
change we are now using the new input
system so you can see how by refactoring
our code to make sure to use the game
input class when we change from the
input manager onto the new input system
when we made that change we did not have
to touch a player class at all the
player class just has the game input to
get the movement vector and does not
care what system he uses to get that so
here we have a very practical very
excellent example of the power of
writing good clean code because we separ
things correctly we manage to change
something completely and not have to
make any changes on any other class so
now that we're using the new input
system let's just quickly see one of the
main benefits of this system which is
easily supporting game pads and more
keys for example a lot of people like
using was but some people also like to
use the arrow keys with this system that
is super easy to add so let's go into
the move let's add another one let's add
another one up down left right composite
let's call it arrow keys then let's just
put them so let's listen on on the up
Arrow then over here we've got the down
arrow then we have the left arrow and
finally we have the right arrow all
right so we've got all the arrows and
now we don't even need to touch any code
at all let's just make sure to save the
ENT which again in turn that is going to
autogenerate the C class and going to
compile okay so we don't need to touch
any code at all let's just hit on play
and now if I move we're using the was
Keys yep still works and if I go into
the arrow keys yep also still works all
right great now for another one let's
make it for a game pad so I just
connected an Xbox controller and we can
see over here on the log yep the game
did identify it so this is the new input
system in action let's once again open
up the input actions and over here on
the Move let's set another one and this
time let's just make it a regular
binding and now over here on the path
once again if we want we can go down
here and specifically find some
joysticks so you can find any of them or
once again let's just use the en listen
now I'm just going to move the thumb
stick on the controller yep there it is
and now if you wanted you could go
specific and make it just work with Xbox
controllers or you can just use the
generic left sick this will make it work
with an Xbox controller or a PlayStation
or really anything so let's go with this
one and that's it nothing else we need
to do let's just save the asset and
that's it we don't need to touch any of
our code to make our game playable with
a controller so let's go ahead and test
so here we are and first of all if I
move the keys yep C Works move the arrow
keys yep both of them works and now if I
use my Gamepad and yep there you go
everything works perfect perfectly all
right awesome so as you can see this is
one of the main benefits of the new
input system it makes handling different
inputs really super easily as you saw we
didn't have to touch our code at all we
just add new bindings and just like that
our game is playable with all kinds of
inputs so here you can really see just
how powerful new input system is okay so
with this our basic character movement
is working great we can walk around
everything looks great now in the next
lecture let's apply some collisions to
our player
hey again here's another quick
intermission I hope you've already
learned a ton from the course have you
seen the benefits of writing good clean
code has the course already helped you
understand some more advanced concepts I
really hope the answer is yes to both
those remember to follow the website
page as you follow along I will be
adding frequently asked questions to
every lecture if you ever get stuck you
can just download the project files for
a lecture and compare with your own and
definitely check out the related videos
when I reference them this course is
focused on making this game but you
should definitely learn more about some
of these Concepts in more detail and you
can learn that in the videos that I
mentioned by the way if you're watching
this right now this is the secret call
out so go ahead post a Time step in the
comments with a nice monkey emoji I want
to see how many people make it this far
okay so that's it for now let's go to
the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
apply some collisions to our player
movement okay so here we have our game
so far we have our player walking around
and everything looks pretty good however
now let's create over here in in the
hurac let's right click create a brand
new Cube so there you go let's place it
over here and push it down okay there's
a cube make it just a little bit bigger
so there's the cube and by default it
has a box col component so it has
physics and the player if I move and
nope there's our issue the player is
going right through the object now the
player is not meant to be a ghost so
let's fix this over here in our player
script we are carrying the input Vector
culating the move Direction and then
just moving the transform so right now
we're moving it no matter what now
before we do that let's first do a test
to see if any object is in the way and
how we're going to do that is by firing
a raycast this one is a physics
operation that basically fires a laser
from a certain point towards a certain
direction and then tells you if it hits
something how we do that is let's go
inside the physics class and let's call
the rcast
function this one as you can see has
many many versions of this function with
all kinds of parameters let's use this
one option number seven which takes a
vector three for the origin a direction
and a max distance so first for the
origin that is from where we want to
fire our recast let's put the player
origin so that's transform. position
then for direction this is going to be
our move Direction so let's use our move
there and finally for distance let's use
some kind of player size player width
something like that so let's define up
here a float for the player size and put
that 7
units let's try out with a size just
like this okay so basically this returns
a bullion it's going to return true if
it hits something and false if nothing
is in the way so let's just do a bull
call it can move and basically we can
move if this Ray cast doesn't hit
anything so we can move if this one is
false so if the ray cast is false then
can move is going to be true that's very
simple so if we can move then we move
the transform position otherwise we
don't okay that's it super simple let's
test so here we are I can move around
and if I go towards the cube and nope no
longer works so I can longer go inside
that Cube okay great now in your case if
it's not working first of all make sure
that the cube make sure it is touching
the floor we use the transform position
as the origin which is right on the
floor so if the box is raised up then
you won't be able to go through so make
sure the cube is touching the floor also
make sure the cube has a box colider
component it can be any type of collider
but if you made a cube then it should
have a box col by default and it should
have the same shape as the visual and
also remember that the 2D and the 3D
physics systems those are completely
separate they are completely different
worlds so make sure you're using 3D
components and not the 2D ones so for
example if I add box cider 2D if I add
this one then it will not work so make
sure you're using the 3D and not the 2D
components same thing over here on the
script make sure you're using physics
and not physics 2D also finally if
you're still having issues make sure you
check the player position again the
player should be on a y of zero the only
thing that might have an offset is the
player visual although if you're using
the same aset me then this one should
also be on a y of zero so all of these
on y of zero and then you can also check
the floor by default this one has a mesh
Lether but if it is exactly on y of zero
with no rotation then it shouldn't cause
any issues alternatively you can also
just disable or remove the mes leather
from the floor since we're not going to
need that so with all of that yep
everything works I can move the player
but I cannot go through solid object all
right awesome so it is working but for
this particular use case a rast isn't
necessarily the best method we should
use basically a r cast is like I said
kind of like a super thin laser but as
you can see the player visually has an
actual body shape so the visual and the
logic are using completely different
shapes if I go ahead and push towards
the box you can see it works just fine
however if the player is a bit more off
to the side and the center of the player
right in front of it is not the box and
I move and yep there you go now I am
going through the box the reason is
because the ray cast being fired from
the center of the player and like I said
it's kind of like an infinitely thin
laser so it has no shape so as long as
the center of the player is not hitting
the box and it can go through it whereas
what we really want is for the visual
and logic to have pretty much the same
shape so let's not use a ray cast over
here on the code instead of a ray cast
we can use a physics query with an
actual shape there are all kinds of
casts you can use and as you can see all
of them with different shapes so you've
got a box cast if you want to have a box
a capsule if you want a capsule or a
sphere cast all of these work pretty
much the exact same way except instead
of a ray cast which fires an infinitely
thin laser these are going to have an
actual shape and for player controllers
for the most part you really want to be
using a capsule cast that's usually the
generally accepted player shape although
alternatively a box cast also can work
very well in our case let's just go with
a simple capsule cast this one to define
a capsule has a 0.1 and a02 by the way
if you have no idea what is a capsule
then we can go over here in the H let's
right click create a 3D object let's
make it a capsule and there you go this
is the capsule it's kind of like a
stretch sphere so it has round the top
round the bottom and then over here in
the middle it's just a cylinder and over
here for the rast takes a 0.1 and a 2 so
that is going to be the bottom of the
capsule and the top of the capsule
basically with those two points we can
Define the height of the actual capsule
okay so let's just get rid of this
capsule let's just delete it and over in
the code let's put those now for point
one it is indeed going to be the
transform position since that is the
point at the bottom and for the second
point for this one it's essentially
going to be the player head so we can
take the transform. position so this is
the bottom and we can essentially just
lift it up so let's add a vector 3. up
and multiply by some kind of player
height so let's define up here a float
for the player height and I tested it in
the editor and the player is about to
unit install so over here let's go ahead
and move it up by that much okay so next
we want the radius so this is pretty
much the player size that we defined
previously so let's use the same thing
but as always let's make sure to write
good clean code since now we are
referring to a radius let's actually
rename this to be a bit more clear and
by the way here's a quick Visual Studio
tip you can right click on a symbol and
then you can click on the rename option
alternatively use a shortcut controlr
controlr if you do that then now you can
change the name so for example player
radius and note how it changes every
single instance of that variable so this
renaming feature is extremely useful
always make sure to rename something if
you find the name that works best Okay
so let's rename this to player radius
then we have Direction so that is as
usual going to be our move Direction and
then finally we have the move distance
for that we can use the actual move
distance so that is going to be the
movement speed multiplied by time. Al
the time so I just find here a float for
the move
distance and we just do that just move
speed time. Delta time we have the move
distance and we use it both in here as
well as down here okay so here we have
our capsel cast the rest logic is
exactly the same so if this one is false
that means it didn't hit anything so if
it didn't had anything that we can move
and then we move the transform okay
let's test and over here now if I go
towards the box and yep still works EXA
the same as previously that's great and
now if I go towards the edge and make
sure that the center is not hitting the
box and now I try to move forward and
nope now we no longer go inside the cube
so even on the edges everything still
works perfectly all right awesome so it
works it looks good but it also is a
little bit janky for example let's
stretch this cube out a little bit so
let's put it just on One Direction so
stret like this let's see now if I move
towards it then nope I cannot go through
it so that is correct and if I move left
and right yep that's also correct that
works however if I now press W and D at
the same time in order to move
diagonally and nope right now it does
not move the reason is because the
diagonal Vector that one is indeed
hitting the collider but usually in
games when you move diagonally and you
cannot move in One Direction then it
tries to essentially hug the wall and
move around it so if I press W and D it
should essentially be moving straight to
the right so let's solve that so here in
our code we're making our capsule cast
okay that's great then we need to test
if we cannot move so let's do if we
cannot move so we can move is
false if so then that means we cannot
move towards this
direction and if we can then essentially
we basically want to split the movement
Direction and just move on the X or just
on the Zed so first let's attempt just
the X movement so attempt only X
movement let's create a new Vector
3 let's call it move the year X and we
make a new Vector 3 Let's Take in the
move Deer dox then zero on all the
others so we only want to test moving in
the X Direction and then let's do
literally the same thing so let's get R
can move try to move under this
direction so let's go instead of move
Deer move deer on the X so we do that
capsule cast and if we can move then
that means we can move only on the xaxis
so can move all on the X and if so let's
set the move there equals the move there
X so if we can move then down here when
we use the move there we're going to
move only on the X and if we cannot move
then that means we cannot move only on
the X and if so then let's attempt only
Zed movement so over here again let's do
the exact same thing so let's copy this
let's just change this one so instead of
move the X we've got move the on the Zen
so over here we use zero on the X zero
on the Y and accessally move there and
get the Zen then let's use this movement
Direction over there and finally the
same thing so if we can
move then that means we can move only on
the Zen and let's set the move there
equals the move there Z and if not then
we cannot move in any
direction okay so that's it now this
might seem a bit confusing but it
becomes a lot more clear When You See It
In Action again remember the scenario
we're trying to solve which is when
moving diagonally so for example when
we're moving forwards into to the right
if we do that then let's say this one is
going to hit something so we cannot move
so if we are trying to move both
forwards and to the right then we're
going to only attempt the X movement so
we're only going to try moving to the
right and then we're going to see yep
going to the right that does work so we
can move and we're going to move just to
the right all right so let's test and
see if all of this is working all right
so here we are and if I move straight to
the wall and nope there is a limit so I
cannot move anymore okay great now if I
move just left and just right and it
does work now if I press W and then D
and yep there you go now it does hug the
wall and continues to move same thing if
I go on the left over here if I press D
no I cannot go through it now if I press
D and S at the same time and there you
go it hugs the wall and moves around so
now our controller is much more easy
much more understandable okay so this is
great now this is one of those tiny
things that makes your character
controller feel much more responsive so
that's great however we also do see one
more issue right now you can see that
I'm right next to the wall and if I
press A and D then look at that I'm
moving with this spin however now if I
press W and D look at that now I'm
moving diagonally and it's actually
moving slower basically this is the same
issue that we saw previously where we
had to normalize the input so we didn't
go faster in diagonals basically now we
have the opposite problem since we are
normalizing the vector we are cutting
down on the left right vector and with
that basically if we are moving
diagonally then we are essentially going
slower whereas if I stop moving
diagonally just move left right it moves
a different speed now solution for this
is really super simple over here in our
code when we are constructing the move
Deer X and move Deer Z when we do this
very simple let's just normalize it so
if this one is less than one then it
will be going into one so let's
normalize that one and that one okay
that's it let's test and if I'm here
move forward and hug the wall left right
yep it does work and if I stop moving
diagonally and just go left right yep
all still works with the exact same
speed all right awesome okay so that's
really it as you can see it's super
simple to add Collision detection to
your movement scripts you just do a
physics query to test if our character
should move and just move it by the way
if you want to learn more about
collisions and physics queries there's a
bunch of interesting videos that you can
watch for example one is on various
methods of finding a Target then another
one is on various methods of handling
projectiles and finally another one is a
very quick checklist on why collisions
are not working basically there's lots
of really interesting things you can do
with physics so make sure you understand
these functions okay so now that we have
all of this working let's first just
clean up our scene so over here our
default queue we don't want this so
let's just get rid of this and with this
we are ready to build our first kitch
encounter and let's do that in the next
lecture hello and welcome I'm your Cod
Mony in this lecture we're going to
begin building one of our main game
mechanics we're going to make a kitchen
counter and handle the logic for the
player to be able to interact with that
counter okay so let's begin by making
our kitchen counter and just like we did
when we made the player let's first make
an empty game object and place the
visual inside of it so let's right click
on the Hier key create an empty game
object call this the clear counter so
it's going to be clear on top so we can
place and pick up objects let's make
sure to reset our transform so let's put
it on 0000 let's move it just a little
bit just so it's not exactly on top of
the player okay now inside let's add the
visuals so let's go inside the assess
folder and then over here we've got the
pref visuals and inside we've got the
counters visuals and over here let's
find the clear counter visual so let's
go ahead and drag it inside the game
object again make sure the chall visual
is on 0 0 the local position okay great
now just like we did in the last lecture
where we added Collision detection that
shouldn't already be working by default
but in order for it to work it needs a
physics collider however note how the
visual over here there's no collider and
inside there's no collider there's only
visuals again this is the same thing
that relates to separating logic and
visuals basically the visual prefab this
one only has visual components so only
meshes animations and that sort of thing
and the main Parent Game object this is
the one that is going to have all the
lgic components so that means any kind
of scripts Behavior as well as any
colliders so over here on the parent
game object let's add a new component
let's find a box collider again make
sure you add a box collider not a box
cider 2D and I chose a box CID just
because this is the shape that makes
most sense for our counter and now let's
scale the Box glider again that's the
Box glider not the transform so leave
that one with a scale of 111 that's good
and over here on the box leather for the
size let's put it up with a size that
fits the visual so 1.5 1.5 1.5 and
finally we just need to lift it up a bit
over here on the scene view you can see
those little green tiny lines these
refer to the Box L shape so let's lift
it up by a little bit in order to make
it perfect let's put it up by 0.5 on the
way all right so there you go that one
does have the perfect shape if we test
just like this it should already be
working so okay so here's my player and
if I move towards it and yep there you
go it does work so it is a solid object
I cannot go through it okay great let's
let's just visually rotate the CER so
let's do that and again for rotation
let's make sure we rotate the parent
game object and not the visual we want
the visual to be on rotation 0 00 0 okay
great so on the parent game object let's
just rotate it around by the way here's
a quick y tip if you want to rotate hold
down control and then click to rotate
and now instead of rotating on every
angle it goes on a 15 angle increment so
just hold down this way you can easily
get it to 180 so just for fun just to
make it face the player okay great so
now let's interact with this counter and
doing this is actually super simple we
already learned how to do a rast to
handle collisions and for interactions
that's exactly the same thing so let's
go into our player script and we're
going to do a recast to handle that but
before we do let's organize our code
here let's make a proper function to
handle our movement so let's make it
private this since this is going to be a
local function return void and call it
handle
movement and then inside let's put all
of this code so let's copy all of this
put it in there and then on update we
simply call this function okay great and
now let's make another function so
private void let's call it handle
interactions and we just call this
function on our update okay great
everything is much more organized so now
here let's do a
rast so once again go inside physics do
a rast for the origin let's start on
transform. position for this obviously
we want the move Direction so one
approach would be to make this a field
variable sorted up here so that way we
can ACC in both functions however if you
remember how we handled the whole issue
with the diagonals basically we're
modifying the move Direction so if we're
moving diagonally then this one modifies
to only move left or right we don't want
that for the interaction we want pretty
much the exact same one even if it's
pointing towards a solid object so let's
not make this a member variable and
reuse it instead let's just grab it
again create it again over here so we
get it and we want this one even if it's
pointing towards a object so let's use
this as our move Direction and now for
the distance let's define a fixed
distance so something like two units
would work and also here's another very
important lesson with regards to writing
good clean code so you would think to
write code like this so let's put the
two right in here that would work
everything would work perfectly but then
let's say you get back to this code
after one week would you remember what
this 2f means the answer is probably not
you would probably very easily forget
exactly what this means so because of
that you should never never use numbers
directly in the code like this instead
you can either make a field up here if
you want to make it customizable or much
simpler is actually what we already did
previously so let's define a local
variable with a proper name so let's
define a float and this one is going to
represent our interact distance so let's
call it exactly that interact distance
and let's put 2f and over here instead
of using a number let's just use that
variable now if we were to get back to
this code after a long time it would be
extremely clear what this parameter
represents
the technical term for what we did here
is called Magic numbers and I've also
covered them in detail in another quick
video but as a rule always remember very
simply never use magic numbers okay so
with this we have our recast it's
pointing forwards for this distance but
this is actually not very useful because
the rast this one only returns a bullion
so all this tells us is if there's
something in front or not it does not
actually get us the actual object
reference so for that let's use a
different version of the raycast
function so as you can see we've got all
kinds of versions in order to get the
object reference let's use this version
right here this one which has an out
parameter for a rast head note the out
keyword here this is important this
means that this is an output parameter
whereas the other parameters those are
all essentially inputs that you give to
the function whereas this output this is
basically a value that the function
outputs so let's use this so we've got
the origin we've got the direction then
we've got the ray asset in order to use
it we need to make sure to write the out
keyword here and then also very
important we need to write the type so
let's call it breakast hit and then the
name so let's call it breakast hit
basically what we're doing here is
essentially defining a variable of this
type with this name we're defining it
and giving it to the function
immediately so we can use it afterwards
if you don't include the type if you
just include the name then you get an
error because this name rake asset this
was never defined alternatively you can
Define it before you pass it in over
here you can do rast it rast it and just
like this it works because you are
defining it here and using here but in
order to make the code a bit more
compact you can just Define it here in
the same place where you get it okay so
let's use this and with this the
function s return is just a bulling so
just hit something or not but then we've
got the rasset output this won't be
filmed with data from the Collision if
we do hit something we can inspect this
to see what that it contains so you can
right click on top of the type and then
go to definition and up here we do see
the definition for the rastet struct you
can see this is a structure to get
information back from a rast
you can inspect this to see all of the
kinds of things that this one returns
for example you have a vector 3 point
for the impact point in World space
where the ray actually had a collider
you can get the normal of the surface
and so on so you can get all kinds of
things for our use case what we want is
to identify the object that we hit and
for that we can use the transform so
this going to be the transform of the
rigid body or the collider that was hit
so let's just do a quick test if we hit
something let's do a log on that object
so let's do an if so if this one is true
then that means we hit something so if
so let's do a debug. log go inside the
rast hit and log the transform okay so
like this we should be able to see on
the console if we do hit something let's
also do an else just to be able to
easily see when we hit something so on
else let's just log an empty Dash and in
our game in order to make sure that our
Collision is working that we are
correctly detecting it let's just
duplicate this object but before we do
let's make this a proper prefab if you
have an object of a certain type that
you want to create multiple instances of
it you should be using a prefab rather
than just duplic an object that way with
the prefab if you make any changes to
that prefab it applies to all of the
copies of that prefab so let's first
make this one a prefab and again since
this is our first prefab let's first
make a nice folder to keep things
organized so folder for our prefabs and
to make game object prefab is super
simple you just click and drag directly
from the hierar key and drop it inside
the folder there you go there's our
prefab and now let's just duplicate this
make sure it has a different name so it
has one so that's enough with this we
should be able to see it just for
testing let's put it just off this side
okay so let's see so here we are and on
the console we see a dash so by default
we are not hitting anything okay so that
makes sense now if I move towards this
object and if there you go it does
identify that object and if I stop
moving it stops identifying okay great
now if I move towards this one and if
there you go this is the one with the
name of one and this is one with the
name of none all right awesome so just
like this we are correctly identifying
what object is in front except we also
have an issue so if I move towards the
object then yep it does work but if I
stop moving whilst I'm still facing that
object right now it's returning none now
the reason for that is because of the
move dat that we're using here if we're
not moving in any direction then
basically this Vector will be 0000 Z so
we're going to be firing a ray cast
towards no direction at all so obviously
it's not going to hit anything the
solution to that is super simple we just
need to keep track of the last interact
move Direction so let's go up here
Define a field for that so let's make a
private let's make a vector 3 and call
it the last interact Direction and then
down here when we have our handle
interaction so we get the movement here
okay that's great so then we just check
if the move direction is different from
Vector 3.0 by the way this is a constant
a short hand for 0 0 so if it is not
zero then that means we are moving in
some
Direction so if so let's set the less
inter direction to this move Direction
and basically if it is not if move Deer
is zero then we are not going to modify
this so this one is only going to
contain the unless inter Direction then
down here instead of using the move
Direction Let's just use this one so
that way even when we stop moving we are
still going to be using the L inter
Direction okay so with this let's test
so here we are and if I move towards it
yep it works and if I stop moving and
yep it still works all right great so we
can move towards it Point towards a
certain object and then yep it still
works okay great now let's actually
interact with this counter and to do
that let's make a class for the counters
itself so let's make a new script in new
C script let's call it the same name so
clear
counter okay there's our script
now very importantly for attaching the
script remember that we have two
instances of our prefab if you just
select it in the Hier key and you just
drag it on there if you do that then
you're not actually adding this script
to the prefab itself you're only adding
it to this specific instance of that
prefab so if you look at this one yep it
has a script but this other one which is
a copy of the same prefab this one does
not have it also over here on the
inspector you can see the little script
icon has a nice little plus that means
it is something that you are adding on
top top of the prefab so that means this
script is not present on the base prefab
basically this is not what we want we
don't want just this object to have this
script we want all instances of this
prefab to have this script so instead
let's get rid of this one from here we
want to modify the prefab itself so one
way to do that is to select the prefab
on the project window so here it is the
ason prefab and now we can drag the
script on there so that works or another
alternative is select the prefab in the
Hier key and on the inspector over here
we see a nice button to open the prefab
and if we actually go into scene view
then we can see what that does so with
the object selected so this is an
instance of that prefab but if we click
on open then essentially we are opening
and we are working inside the prefab so
now if we make sure to add our script
and let's go back outside this prefab so
on the top left corner over here we can
see where we are so we were inside our
scene and then we are inside the clear
counter prefab so if we click on the
scenes we can go back now it tells us
that we made some changes through the
prefab so let's save them and yep we
added that script and we can see both
instances of the prefab they both have
the same script and we can see on there
on the icon that this is not an override
this is an actual script at on the base
prefab so whenever working with prefabs
always make very sure that you are
adding it on the right place if you want
something on the bass prefab make sure
you either add it on the prefab itself
or go inside the prefab by double
clicking on it or select an instance in
there and open to go inside the prefab
so always keep in mind differences
between a prefab and an instance of a
prefab okay so we have our script let's
open it and over here let's just make
one super simple function so let's make
it public because we want to call this
from our player class let's return void
and just call it
interact okay that's it super simple for
now let's just do a debug.log and just
say interact okay so that's it and now
over here on the player when we have our
handle interactions function so we
interact we do our recast and we find
out if we hit something so when we do
the first thing that we should do is
identify what this transform is so is
this something just like a dumb Cube or
is it an actual counter now when it
comes to identifying things this is
another place where a lot of beginner
tutorials would teach you to use the
unity tag system so that's over here in
the editor when you select any object
over here in the inspector you can see a
tag so you can see untagged and you can
add all kinds of tags this is something
that a lot of beginning tutorials teach
but Unity tags are horrible you should
never never use them I covered in more
detail why that is in the advanced
concepts video the main reason is
because of well pretty much the same
thing that I mentioned a while ago when
we were handling animator parameters so
we were doing this and I talked about
how this one takes a string and how
strings are horrible way for identifying
objects they are very brittle very
errone it's very easy to make mistakes
and tags have the exact same problems
because tags are strings so we do not
want to use tags to identify objects
instead over here on the player script
let's use a different method for
identifying objects and the best way to
do that is to Simply get our counter
component so we have our transform and
then from ins inside that transform we
can call the function try get component
this one then takes the type of
component and again note how this is an
out parameter so let's put out and we
want to test if this is of type clear
counter so clear counter and call it
clear counter and this one basically
does the same thing as a rast so it
returns a bullan so either true or false
so if this one is true then that means
that object has that component so over
here we know has clear
counter by the way if you're not
familiar with tri get component this is
pretty much the same thing as the
regular get component except it
automatically handles the null check for
you so if we just do this it's exactly
the same thing as this so you do an if
rast hit let's access the transform get
component component of type clear
counter naturally this one is not inside
ni but let's store this clear counter
equals this then you do if this one is
not null then we know has a clear
counter so basically what we have up
here is the exact same thing that we
have down here so just using triy get
component just a bit more Compact and I
find much easier to read than to always
get the component and test if it is not
known over here we just have one
function with a nice out parameter and
everything works perfectly so that's the
traget component I much prefer that
method so let's use that by the way on
the traget component over here you can
see it has a type inside some angled
brackets basically these are called C
generics these are an extremely powerful
C tool
I have a dedicated video on them and
I've used them in tons of videos
definitely go ahead and learn about them
basically this lets you write code that
works with many classes not just one
specific type in this case the triy get
component can work with any type of
component so it can be Unity built-in
component or it can be components that
you made yourself then if it finds a
type it returns through so for right now
it's not strictly necessary to know the
specifics about how C generics work but
definitely make sure you add that video
to your queue and watch it afterwards C
generic are an extremely useful C
feature okay so we do this and basically
if we are inside of here then we know
this object has a clear counter and we
have our clear counter reference so over
here it's super simple let's just call
the interact function all right so
that's really it let's just get rid of
the else we no longer want that log so
we should be able to see a log whenever
we call our interact in a counter all
right so here we are and if I move
around okay that's good over here the
console is empty all right now if I move
towards the counter yep there you go I'm
interacting with it and if I move
towards this one yep there you go
interacting all right right great so
with this we are correctly identifying
the object and interacting with it now
let's just do one final thing over here
we are doing a rast to find the counter
and right now we are doing a ray cast
towards any object that has any kind of
physics C so maybe that's our counter or
maybe just a random wall for example if
we had an invisible wall in front of our
counter then this code would not work
that's because this Ray cast and this
Ray cast hit it only Returns the very
first object that it does hit so if the
counter was behind the wall then the rec
asset object here would be a reference
to that wall object perhaps that's what
you want or perhaps not in that scenario
one thing you can do is instead of using
raycast you can use the function raycast
all and difference for this one is
instead of returning just a bullan just
true or false instead it returns an
array of all the objects that it hit
with that Ray cast then you could cycle
through them and identify the objects so
that's one approach or another option is
over here on the recast if we look at
these function versions we can see that
some of them has what it's called a
layer mask basically you can set a
certain game object to a specific layer
and then if you using a layer mask then
you can make sure this rast will only
hit objects within that layer anything
not on that layer will be ignored for
that rcast this is super useful so let's
learn how it works for a layer mask we
can go up here and Define a type of
layer mask so let's make another
serialized field private let's make it
of type layer mask let's call it the
counters layer mask
okay so we have this and then down here
when we have our recast let's use it so
let's find the function that matches up
these parameters with the layer mask so
here it is we have the origin then we
have Direction The Rake has hit the max
distance and then finally we have our
layer mask so let's use our counters
layer mask okay great now back in the
editor let's select our player game
object and yep there we see our field of
type layer mask and you can see how we
can select all kinds of layers and how
we set these layers to an object is
let's just select our clear counter
although again we want to make sure that
this change applies to all counters not
just this one specific instance so let's
go inside the prefab and over here we've
got a field for our layer and you can
see we've got a bunch of default layers
and then we can add some more so let's
add some layers and over here let's go
to the first empty one and let's call it
counters okay we've added the layer so
let's go back select our object and now
on the layer let's put it on the
counters now it asks you if you want to
modify the layer for all child objects
now since we made sure to keep the logic
and physics components only on the
parent object let's just modify this one
and leave the other ones on the default
so let's just modify this object only
okay so with that our counter is now on
the counters layer let's leave the
prefab make sure to save it okay great
and now if we go back into the player
and over here on the counters layer mask
yep we do see the counters layer so
let's just click to selected by the way
this drop down menu you can actually
select multiple so you can select all
kinds of layers so this is multi select
but we only want to counter so only like
this and just like this if we do test
and now if I move towards it and if
there you go got the nice interact on
both them so everything still works
exactly the same but now if we had
another physics Le in front of it it
would still work because we're using a
layer mask to only recast against
counter objects all right great now I
should point out another way to work
with layers is with something called a
bit mask that's a bit more advanced
usually the layer mask is much easier to
follow but if you want to learn about
bit mask go ahead and watch that video
and also another quick note in this game
we're only going to interact with one
single object type it's only going to be
a counter even though we're going to
have multiple types of counters but for
games where you want to interact with
multiple objects like for example having
an interact action to talk with an NPC
and another one to open a door or push a
button for those kinds of multiple
interactions to build a system like that
make sure you'll look into my how to
interact with objects video it covers
how to do all of that how to interact
with all kinds of objects it's all based
on C interface which we're actually
going to use in a few lectures and also
have a dedicated video on that topic so
keep following this course but then make
sure to watch those videos add them to
your watch list and make sure you do
watch them watch that how to interact
video it is something that is necessary
in so many games and most tutorials
don't actually teach you the correct way
of doing it anyway so back in our game
we are correctly identifying an
interacting with each counter but
obviously we don't want to interact
automatically just like this instead we
want to press a nice button to interact
so that means we're going to need to
create an interact input action so let's
do all of that in the next lecture
hello and welcome I'm your codemy in
this lecture we're going to create a
proper interact input action and in
doing so we're also going to learn about
a very powerful C feature called events
okay so here we have our game so we have
the player and if we move towards the
counter yep we are correctly identifying
it and interacting with it except of
course we don't want the interaction to
happen automatically it should be on a
player input so let's make our interact
action let's go inside our player input
action so let's double click on it and
let's make a brand new action so we've
got the move and now we're going to have
another one so let's click on the plus
icon for this one let's call it interact
and for this one action type we do want
it to be a button okay great then on the
default binding let's go into path let's
listen and by default let's bind it to
the E key just like so many games so
let's go ahead select this one and once
again let's make sure to save the asset
and let the C Class be generated okay
now over here in our game input script
in order to listen that is very simple
so we go inside the player input actions
then inside the player action map and
then we can find the interact action and
then over here we can see a whole bunch
of events that we can interact with
we've got these three cancel performed
and started these are the three phases
of every input again I cover these
stages in detail in the input system
video the important thing is that these
are C events which I also covered in
another dedicated video essentially they
are a way for how you can write code to
then get notified when something happens
rather than running code on every signal
update constantly testing something for
example over here on the movement
movement is a Prett constant action so
it does make sense to ask the input on
every single update if any movement is
pressed but for an action like the
interact the player is only going to
press that say once every 5 seconds so
it makes no sense to constantly check
for that action on every single update
instead we just want to be notified when
that action is triggered and that is
exactly what an event does again watch
the dedicated video to learn all about C
events in detail they are insanely
powerful and we will be using them more
and more as we go through this course
for now here are the absolute Basics
events have Publishers and subscribers
the publisher creates and fires the
event when something happens and the
subscriber un listens that event and
gets the UN listening function called
when the event is fired now on the
generated C Class we've got these three
events the one that we want for this
case is the performed event so let's go
into this one and basically we want to
add a listener to that event and we can
subscribe to that by doing plus equals
so this assigns a listener to that event
and now Visual Studio has a nice
shortcut so if you press on Tab yep
there you go it automatically creates
the function now if you're not using
visual studio you can just manually
write this function the only thing you
need to make sure is that the function
signature perfectly matches the event
signature as usual we can inspect event
so we can right click on it and go to
definition and up here is the definition
and you can see that this is an event of
type action with a comback context
action is what is called a delegate I
also have a video on delegates if you
want to learn more about them in detail
for now we don't really need to worry
about what is delegate we just need to
use it so in order to subscribe to the
event we need to make sure that this one
returns void because an action returns
void and needs to have a parameter of
this type comback context if I erase
this parameter y there you go now we
have an error because the function
signature does not match so it always
needs to match exact same signature okay
and also one more note over here when
subscribing to the event make sure you
only add the function name meaning you
do not add parenthesis we do not want to
call the function we just want to pass
in the function itself as a reference
okay so now when the player presses the
interact action it's going to fire off
this event which in turn we'll call this
function so over here let's do a debug.
log just to see what this contains for
example let's print out the comback
context okay so let's see so here we are
and if I press on E yep there you go
I've got a nice event okay great so with
this we know when the player presses the
key now the next step is how do we get
the player class how do we get this one
to know when this is performed and the
answer is we're going to do the exact
same thing we're going to make an event
over here on the game input class and
the player won't listen to that which in
turn the game input grabs from the input
system again the whole point is
separating our concerns so the player
does not care about the input system
does not care about the interact action
it only wants to know when something
related to interact happens so over here
let's make that nice event first of all
let's make it public because we want the
player to access it then we need to add
the vent key next we add the D type like
I said you can learn more about
delegates in my dedicated video you can
create your own custom Delegate for your
event or you can just follow the C
standard and just use the standard event
handler and this one exists inside
system so let's make sure to go up here
and add using system and this one has
the event handler class this one is
pretty much the C standard for events as
you can see it returns void it has an
object for the sender and an event ARX
parameter like I mentioned in the events
video you are not forced to use this
delegate you can use whatever delegate
you want like for example you saw that
the performed used an action delegate so
you can use anything you want it's just
that the event handler is the C standard
so it's easier to follow unless you have
a specific reason to deviate from the
standard you should probably use this
one so let's use this and then finally
for the name usually you start the name
with on and then whatever happened so in
our case let's go with on interact
action okay so we have defined our vent
and now for firing it
let's go down here into when we have the
interact performed and let's go into the
event and for finding it is pretty much
exactly the same thing as calling a
regular function so we just call it with
parenthesis then usually for the object
sender this is a reference to whoever is
sending this event so usually the this
keyword and then for the event ARS this
is in case you want to send some
arguments with the event in our case we
don't really need to send any extra data
for this one just firing the event is
going to be enough so for that we can
use the Conant event rx. mty okay so
that's it with this we are firing an
event except just like this we're
actually going to have one potential
error if we have no subscribers no
listeners to this event then essentially
this field won be null so this one over
here is going to trigger a null
reference exception let's do a quick
test just to see this happening so here
if I press on E yep there you go we have
a no reference exception so when working
with events you need to first test if
there are any listeners and only then do
you actually trigger the event so you do
if this one is not known if it is not
known that means that there are some
subscribers so we can fire the event so
like this it will work but there's an
even more compact way to do this which
is perfect for events so instead of this
we've got our uninter action then we can
add a question mark this is called the
non-conditional operator basically the
code is going to execute from left to
right and then when it gets to this
question mark it's going to evaluate the
left side and if it is null then the
execution W stop right here on the
question mark and will not throw any
errors whereas if this one is not null
then it continues executing to the right
except with this syntax we have an error
We cannot put parentheses directly after
the question mark but what we can do is
simply just call invoke and that does
the exact same thing that calls a
function so what we have here is exactly
the same thing that we had
previously so what we have over here and
over here these are the exact same thing
it just this one is much nice much more
Compact and especially for events this
one is super useful okay so with this we
are correctly firing for our event now
let's actually listen to it so let's go
over here into the player class and
let's listen to our event let's do it on
a private void start make it on start
and not on awake this is a very
important rule which I'm actually going
to cover in detail in the next lecture
but for now just make sure to listen on
start and not on awake so over here we
access the game input then let's access
the on interact action event and as
usual let's listen to it so let's use
press tab to listen to it so it is
exactly over here that we want to run
our interact code so let's go down into
the handle interaction code that we had
previously so this one so let's copy
paste all this code put it up here so we
get the interaction go to the object and
Trigger the interact now obviously code
duplication is a big no no so we're only
duplicating our code just for a quick
test just to make sure it works once
again refactoring is super useful so
we're going to refactor this code to get
rid of code duplication in the next
lecture but for now we just want to test
to make sure that this does work so
let's just remove the interact over here
from the handle interactions so the only
interact function being called is over
here when we have our actual input so
let's test and see if we can press to
interact with the counter all right so
here we are and as I move around if I
approach the counter yep there you go we
no longer have the automated interaction
and now if I'm facing the counter and I
press the interact key yep there you go
here we have our nice interaction all
right awesome so I can approach I can
interact and do whatever I want all
right so here we learned about C events
these are super powerful so if this is
the first time you're hearing about them
then you've just added an awesome new
tool to your toolbox definitely make
sure you watch my dedicated video to
learn about them in more detail events
are super useful the next thing we're
going to need is just a visual to
highlight the current selected counter
so let's do that in the next lecture
hello and welcome I'm your code monkey
in this lecture we're going to add a
visual to our selected counter and in
doing so we're also going to learn about
the very useful Singleton pattern okay
so over here we already have the logic
to identify the counter in front of the
player and we can interact with it
however once the logic works there is no
visual indicator at all so let's add
that now as usual the super quick and
dirty way of doing it would be pretty
simple over here on the player script we
could just directly enable a visual mesh
on the target counter so down here on
the handle interaction when we have this
over here we can tell the clear counter
to enable some kind of visual
technically the would work but that
would be some pretty dirty code we would
basically be making the player
responsible for enabling some kind of
visual which would mean that we were
mixing logic with visuals again we
always want to try separating the logic
from the visuals as much as possible to
keep our code nice and organized so
instead of doing the quick andary route
let's do it properly back in the editor
let's create a brand new C script call
this the selected counter Visual and now
let's go into the prefab again let's go
inside it so let's select the clear
counter on the hierarchy then on the
inspector let's open up go inside the
prefab and now let's select the visual
inside it and let's duplicate this so
you can press contrl D to duplicate it
let's name this one selected and then
inside there's a visual with a mesh
filter and a mesh render so over here
let's swap out the material so let's
click on the circle icon and now
included in the assets is this material
counter selected so it's all the way yep
up here the counter selected basically
it's just a solid white colar with a low
Alpha so on the kitchen counter inside
the select game object let's make sure
to use this one with this we have kind
of like a ghost visual so if we enable
in dis this game object we can see the
difference Also let's do one tiny thing
which is right now we duplicated the
actual visual meaning that these objects
are exactly the same they have the exact
same size and when that happens you
might end up with some rendering bugs if
two meshes are on the exact same
position you might sometimes see the
colar constantly flip back and forth so
in order to make sure that doesn't
happen let's make this one the selected
a tiny tiny bit bigger so over here with
the select game object selected on the
inspector over here we've got the scale
and also we've got this nice little
button here if it's like this then we
can modify each proportion differently
from one another whereas if we click now
these are all linked so now modifying
one will modify all of them so let's put
this on
1.01 meaning this one is going to be
literally just 1% bigger so that's
enough of a difference to make sure we
don't have any rendering Bo
and by default let's also start with the
visual hidden so let's do that not on
the parent select game object but rather
on the kitchen counter inside of it
let's make sure to disable this game
object by the way the quick shortcut is
shift alt and a you can enable or
disable the object very useful so let's
start with this one disabled so that
it's hidden and basically the goal is
that when this counter is selected we're
going to enable it and show this Visual
and when it's not selected we're going
to disable it okay so over here on the
selected let's set the script that we
made so the selected coun vision all
right so let's open it now here first
thing we need to know is know which
counter is selected meaning we need to
know which counter the player is
currently looking at so let's go over
here onto the player script and let's
basically just use some simple logic to
keep track of the selected counter so
over here let's make a field so a
private let's make it of type clear
counter and just call it the selected
counter then down here we have our
handle interactions logic okay so we do
all of this we try to find a counter in
front and if we do find it then we have
it here so here let's just check if it's
different so if this clear counter if
the one in front is different from the
current selected then let's set the
selected to this
one and let's also make sure to
essentially unselect so we want to make
sure to set this one to null when
there's nothing in front of the player
so if the ray cast does not hit anything
then there's nothing in front of the
player so let's set the select the
counter back into n and also if there is
something but that something does not
have the clear counter script then it's
also not counter so over here let's also
do an else selected counter equals null
so basically if there's a counter in
front of the player then it's going to
set it if not then it's going to be n
let's just do a simple debug onlog to
check on the selected counter okay and
also just briefly now that we've made
this selected counter logic actually up
here when we have our interact action
like we saw we were previously copying
some duplicated code but now we no
longer need this since we already know
the selected counter so over here when
we've got the interact action let's just
check if we do have a select counter so
if it is not null if so then we go there
and we call the interact function so
that's it we no longer need all of this
logic okay that's great so let's test
back in the editor let's go back into
scenes let's make sure to save the
prefab make sure the script was attached
save it and let's head on play and right
now if I'm down here yep there you go
we've got null and as I approach yep
there you go that one is a clear counter
and if I move towards this one yep it's
that one okay so basically we are
keeping track of the cord let select the
counter now basically we just need to
notify the visual whenever this one
changes so when this one is pointing at
that one or pointing at no or pointing
at that one we need to know when that
happens and for that we basically have
two options now one option is pretty
much what I mentioned a while ago which
is over here we have the select counter
so we can run some kind of logic on the
select counter we can do that over here
on the player then perhaps over here the
counter would fire off some kind of
event saying it has been selected and
then the counter visual would listen to
that event and update itself now that
approach would be useful if we wanted to
add some kind of logic on the clear
counter while selected and that approach
would also have the benefit where the
visual counter would only listen to
events on its own counter so that's one
approach pretty much a very direct
approach but another one is very simple
the player would simply fire off an
event whenever the selected counter
changes and then all of the counter
visuals would listen to that event then
they would identify if the event relates
to that counter and if so update their
state now the benefit of this approach
is that the logic doesn't get bothered
with any selection logic so over here
the clear counter script never really
knows if it's selected or not and that's
a good thing because it doesn't need to
know although the potential con with
that approach is that all of these
selected counter visuals are all going
to listen to the same event so both
approaches have pros and cons here let's
go with the second approach where all
the counters listen to a player event
the potential performance con doesn't
really matter on a game of this scale
we're only going to have about a dozen
counters so even if 11 of them are just
wasting on listening to the event it's
really not going to matter and going
with this approach will actually help us
learn about the Singleton pattern which
is extremely useful so first let's go
over here onto the player class and
let's make the event that we're going to
fire so as usual let's make it public so
we can access it let's make it an event
and as usual let's also use the standard
event handler let's make sure to add
using system so here Visual Studio adds
it automatically okay and let's call
this on selected counter changed
also this is a great moment to learn
about the event args this is how you can
extend a c event in order to pass in
some more data so how you do it by
following the C standard is very simple
we just create a class so over here
let's make a public class then for name
usually you include the name of the
event with event ARS at the end so in
this case on selected counter changed
and then event arcs then then on this
class we make it extend event
arcs and finally inside the class we add
whatever data we want like for example
we want the current selected counter so
let's make a public clear counter and
put the selected
counter okay so we have this nice event
ARs with a bunch of extra data and then
over here on the event handler we use
the version that takes a generic and we
pass in our event arcs again I covered
the generics in more detail in a
separate video definitely go watch that
one if if you haven't seen it yet C
generics are one of C's most powerful
features okay great so we now have our
nice event now let's fire it off so
let's go down here to when we're
modifying the selected counter so here
it is we've got all of these ones so
when we modify let's fire off the event
so we go into this event and as usual
let's use the question mark and then
call invoke then for the object sender
it's going to be this so pretty much a
standard and then for our custom event
TS let's construct an object of that
type so construct a new object and then
inside we pass in the selected counter
and we set it to this selected counter
now don't be confused by the fact that
we're using the exact same name if you
actually Mouse over the cursor Visual
Studio actually helps you by telling you
which object refers to this so with the
cursor here note how all of these are
highlighted but this one is not
highlighted that's because this field
this is the field inside the unselected
counter change vent ARS whereas this one
out here is the object that we're
referencing in here so even though these
two have the exact same name here we're
accessing the field inside of that and
we're assigning it to the reference that
we have have down here okay so that's
really it we're firing off the event
when the selected changes and we're
passing it in and let's also make sure
to do it over here so let's copy and
paste some code and there you go just
like this except of course we can
already see a bunch of code duplication
usually that means it's time to refactor
so let's do that pretty quickly let's go
down and make a brand new function so
let's make a private void let's call it
set selected counter and we're going to
receive a clear counter for the selected
counter
then over here we just set this do
selected counter so we're modifying the
member variable with the one that we
receive on the parameter and then let's
also fire off the event so let's copy
paste the event just like this the exact
same thing okay so that's it and now up
there instead of code duplication we
just do this so over here we set the
clear counter just call the function
pass in that one and get rid of this and
on that one just pass in null just like
this get rid of all of this and here the
same thing just pass and null all right
so with this our code is much cleaner
and everything still works EXA the same
so here we have everything done on the
player side let's just get rid of our
log we no long need this so we're still
handling the selected counter logic and
then down here we're firing off the
event now what we need to do is go over
here into the selected counter Vision
script and here what we want to do is to
listen to that event and in order to do
that we need a reference to the player
object now so far when we've been
listening to events like for example on
the player class up here we were
listening to some events on the game
input so there you go the UN interact
action so for the game input reference
we just added as a serialized field we
did this and then we dragged the
reference directly and technically we
could do the same thing over here on the
selected counter visual but we're going
to have like a dozen counters in our map
so it would be pretty tedious to drag
and drop the player reference to every
single one of them so instead of using a
serialized field another approach is to
use a Singleton pattern this one is an
extremely useful programming pattern
it's it's very useful for things where
you only have one instance of something
in this case we're making this game
single player so we're only ever going
to have a single player by the way
here's one obvious quick note like I
mentioned in the beginning of this
course after this video there's going to
be another one converting this game into
multiplayer and in that case we will
have multiple player instances but this
is also an excellent reminder of how
refactoring code is perfectly fine for
right now for this game it is intended
as single player so for now we're going
to use the single pattern then in the
future when we convert this to
multiplayer we will simply refactor that
logic again don't be afraid of
refactoring code it's a Perfectly
Natural part of programming and game
development okay so let's implement the
single pattern this is actually super
simple the name sounds intimidating but
it really is very simple over here on
the player script let's make a public
field this one let's make it static if
you don't know static basically it means
that this field belongs to the player
class itself and not to any instance of
a player so for example if you had 100
players you would have 100 instances of
move speed you would have one for each
player but there would only be a single
static field because this static field
belongs to the class itself and not to
any instance so let's make a field of
type player and then for the name the
convention is to call it instance and
the reason why I'm using Pascal case
here so capitalized in the beginning the
reason for that is because this is
actually not going to be a field but
instead it's going to be a property
remember the naming rules that we
covered in the beginning of this course
it's very important you follow your
naming rules always be consistent so
your code is easier to understand so
with that said since this is the first
time we're using a property let me
quickly explain what it is basically
it's the exact same thing as a regular
variable except you can add some logic
when getting and setting that field so
here let me write some quick code just
to show the difference between a
property in a regular field so for a
regular field you would call this maybe
instance field something like this so
this is a regular field then you would
have some kind of public
static return the player and call it get
instance
field then over here you would return
the instance field and then maybe
another public static void set instance
field where you receive a player for the
instance
field and you would set the player.
instance field into this instance field
so this is how you do this logic with
fields and now with
properties you would do public static
player then call it
instance then on the property itself you
open up the currently
brackets inside the property you put a
get then you return something so for
that something usually a property has a
field underneath it so you'd have a
private static
player for the instance that's a
different name from this one on the get
you would return that and on the set you
set the instance equals z value if
you're confused here don't worry
basically I'm just repeating just so you
can see difference here we have a field
with a get and a set function so regular
functions and up here we have a property
and inside the property the property
itself has a get and set functions which
can also do some logic so you can do
some logic in between or you can just
return the underlying value so basically
using a property is pretty much the
exact same thing as using a separate get
and set function also one more bonus
thing which is that c is smart enough to
automatically create the underlying
field for a certain property so if you
just want to do a get and a set then you
don't need to Define all this you can
just Define a property and then inside
you can just do get and
set and there you go this code here
works the exact same thing as we had
previous one which in turn is the exact
same thing as all the code we have here
with a getter and a Setter function so
here it is a valid functional C property
now I have to say that personally I
veryy very very rarely used properties
in fact the only place where I use them
is over here on the Singleton pattern
for everything else I normally use
regular Fields with get and set
functions personally that's just the way
that I like to code but that's really
just personal preference so if you do
like to use properties then go ahead and
use them anyway so the reason why I like
using a property specifically for the
single pattern is because the implicit
implementation allows you to do
something really nice again remember the
goal with clean code we want to minimize
complexity and the best way to do that
is minimize access here if we set this
property and we set it as public then
that means that any other class can both
get and set so anyone else can have both
read and write access so we have the
exact same problems that I warned you
about when I spoke about why you should
not make everything public and of course
if we make this private then at that
point we kind of lose the purpose of our
Singleton since no one else will be able
to access this basically we want to be
able to access this reference from
classes outside of this one we just
don't want those classes to also have
right access now thankfully properties
have an excellent thing which is you can
Define accessors for here both the get
and the set so we can make the property
itself public which means by default
both of these won't be public but then
we can also add the accessor over here
private which in turn means that the get
won't be public so any other class can
get this but private means that only
this class can set it this way we have
the exact level of accessibility that we
want this is the reason why for this
specific use case properties are are
very useful with just this one line of
code we already have our instense with
the perfect level of accessibility so
now that we have this field to set it
let's make a simple awake so let's go
over here private void awake and on
awake we just set instance equals this
however remember that a key point of the
Singleton pattern is you only have a
single instance of something so in this
case we should never have more than one
player if we do then something went
wrong so we can add a nice safety
feature here let's just just check if
instance if it is not known meaning it
has already been set to something if so
then that's an error something bad
happened similar to a debug.log error
because this should never happen so
let's say there is more than one player
instance this way we have a nice safety
check just in case something goes wrong
all right so that's really it for the
Singleton pattern we just Define a
property with a public yet in a private
set and on awake we just set the
instance that's it as you can see it's
super simple
and now for the really useful part over
here on the selected counter visual now
we can access the Singleton instance in
a super easy way let's make a private
void start and on start we just access
the player class and from the class we
can access the static instance so we can
access the Singleton and now we can
listen to The unselected Counter event
and over here by default Visual Studio
gives this function the name of the
event and also the property this isn't a
very descriptive name so I like to
rename this so control RR and just just
rename the instance here instead of
instance let's rename it to player okay
great so over here we can listen to this
event however here is yet another
extremely important thing note how I
made this on start that is very
important if you do this over here on
awake instead of start and over here on
the player you're also setting the
instance on awake if you do that
basically there is a chance that this
code will run before this code and if
that happens well then this one the
player instance has not been set yet so
this will be null and it will throw a
null reference exception now whether
this happens or not is actually somewhat
random it depends on the order in which
Unity decides to run both these scripts
if Unity decides to run the player first
and this one second if that happens then
there's no problem but if Unity decides
to run this first and then this one then
we have a problem let me do a quick test
and see if in my case it triggers that
error and if in my case it did trigger
that error so here we have a non
reference exception and yep it is being
fired on this line now one solution to
this problem is you can tell Unity spe
spefically which order the script should
run in so you can go up here into edit
then go into the project settings then
on the left side you've got something
called The Script execution order and
basically over here you can set the
order in which all of these scripts run
so if you were to make the player script
run before the default time that would
make sure that even though both these
scripts are on awake this one would run
before this one so that would fix that
problem however you should really only
use this approach in the last case
possible where there really is no other
way in this case we do have another a
better way personally I have a very
simple rule that I like to follow that
helps solve this issue as you know Unity
has both an awake and a start and all of
the awakes on all the objects will all
run before all of these starts so the
simple rule that I follow is that I use
awake for the initialization of that
script and for any external reference
for that I use it on start so in this
case for initializing the player and
setting the instance that relates to the
initialization of the player so let's do
it on awake whereas over here on the
visual
since here we're going to access the
player which is an external reference
for this one instead of doing it on Wake
let's do it on start this way we are
guaranteed to make sure that this
instance has been set okay so with all
of that here we have our instance so
that works great and we have our event
so that's great then here we have our
event and inside we've got our event ARS
so we can go inside the event arcs
object and inside we have our selected
counter so all we need to do is just
compare which counter this visual
belongs to so let's actually make a
field up here so as usual let's make a
serialized field of type clear
counter so we have this one and before
we go into the editor just make sure it
compiles let's comment this out so now
let's go back into the editor and over
here let's rag the reference but again
remember we're working with a prefab so
let's click on open to go inside the
prefab and now whil inside it let's
select the selected game object and just
drag the clear counter reference okay
great let's go back outside and save the
changes all right so now here in the
code it's actually very simple so we
just do an if if the selected counter
matches this clear
counter if so then we want to show this
visual if not we want to hide it so
let's also add a reference for that
visual so let's add another serialized
field of type game object for the visual
game
object then back in the editor again
let's go inside the prefab and on the SL
let's drag the child kitchen counter so
drag that one that is the visual game
object okay let's go back save and back
in the code here let's make some simple
show and hide functions so private void
show and a private void
hide and now on the show just go into
visual game object and call set active
so this enables or disables the game
object so for show let's set it to true
and for hiding let's set it back into
false okay so now it's super simple if
the selected counter is this counter
then let's show the visual if it is not
then let's hide the visual all right
that's it super simple let's test so
here we are and if I approach that
counter yep there you go look at that
the nice selected Visual and if I go
into this one yep there you go I can see
it all right great so here we haded a
really nice visual to our selected
counter and more importantly we'll learn
about the super useful Singleton pattern
as well as learning about C Properties
and a very helpful rule for how to avoid
code timing issues so this was a really
detailed really important lecture if
you're feeling confused about anything
go ahead watch it again or just post a
question in the comments and I'll do my
best to help so with all of this this is
all great we have the selected counter
and we can see which one is actually
being selected then by pressing a button
we can actually interact with it so I
can move and interact with any of these
counters but right now just interacting
with them doesn't really do anything so
the next thing we need is to create some
proper objects for all of our
ingredients so we can later pick them up
and drop them on counters so let's begin
doing that in the next
lecture hey again quick intermission
you're past the 15 lecture marks so
congratulations looking at my regular
course stats it seems about 80% of
people give up by this point so great
job with sticking with it the difficulty
and complexity is increasing over the
lectures so I just want to check in to
make sure you're understanding
everything remember to post in the
comments if you need extra clarification
on anything and I'll do my best to
answer also check the website to see
what questions others have asked and of
course remember this is your Learning
Journey you're not competing with anyone
but yourself so take your time re-watch
some lectures if you need to just focus
on learning okay let's go to the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
learn how to create the kitchen objects
like the various ingredients okay so far
we have our player we can walk around I
can approach each of these counters and
I can interact with now the next goal is
to create objects the player can pick up
and drop when interacting with a clear
counter so let's begin by making the
actual objects so let's create a new
empty game object call this one the
Tomato then again as usual let's
separate the visual so in the included
assets let's go inside of it then we've
got the preat visuals and we've got the
kitchen objects visuals and inside we've
got all of the ingredients so let's just
find the Tomato Visual and drag it as a
child of the tomato and again as usual
make sure to put on position local
position 0000 0 and for the main one
let's put it on a y of zero and just
push it a bit off to the side just so we
can see okay great now this one is
obviously not going to exist over here
in our world instead we're going to
spawn it so let's make it a prefab let's
just drag it over here into our prefabs
okay there it is
let's delete it from our scene and
actually on our prefabs let's make a
nice folder to keep things nicely
separated so inside the prefabs let's
make a sub
folder call it the kitchen objects let's
put the tomato inside of it and let's
also make another folder for the
counters and let's put the clear counter
inside of it okay so everything is
nicely organized all right now that we
have this let's go inside our clear
counter script and over here let's add a
simple reference to our prefab
so let's make of type transform call it
the Tomato
prefab by the way here you could make
this prefab reference of type game
object which type you use in this
scenario is pretty interchangeable I
talked about those differences in
another video so when using prefabs
using them as transforms or game objects
as pretty much personal preference and
personally I just prefer to use them as
transforms okay so we have this let's
just make this a serialized field so we
can set it in the editor and over here
in the editor let's open up go inside
the counter prefab and just drag the
Tomato reference okay great let's go
back outside save now back in the code
here when the player interacts with it
let's just spawn it so let's call
incentious we don't want to spawn on
this counter's origin remember that the
counter the way we set it up the origin
on the actal objects over there on the
bottom we don't want to spawn the tomato
inside the mesh that would not make
sense instead what we want is to spawn
up here so the next question is okay so
how do we get this point on top of the
counter one approach would be to use a
vector 3 directly in the code that would
work but not very usable so a more
designer friendly method is to Simply
use an empty game object as a Target so
on the counter let's first go inside our
prefab and over here let's create an mty
game object inside of it let's call this
the countertop Point let's make sure to
leave this one as empty so no components
just a transform and now let's just
position it so let's lift it up just
about enough so let's make sure we see
so there you go just about that so let's
put it on position a y of 1.3 all right
so this point is going to be our spawn
point let's make sure to save the prefab
then back in the code here let's add a
reference to our point and for reference
let's also use a transform reference
call it the countertop
Point okay now let's just come this line
just so the code compiles so we can drag
the reference back in the editor inside
the pref let's just drag the counter
toop Point reference reference okay
great so now here when we call
instantiate let's instantiate it inside
the counter top point so this will spawn
the object so let's say the transform
for the Tomato
transform and then we go inside this one
and let's just make sure we position it
correctly so let's put it on a local
position of vector 3.0 so this will put
the object exactly on top of our
countertop point also here very
important don't make a mistake make sure
you're modifying the local position and
not the global position okay so with
this let's test over here in the editor
let's go back save our prefab and hit on
play so here we are let's approach the
counter and interact with it and Y there
you go it does work the Tomato was
indeed spawned all right awesome okay so
with this we have pretty much our Basics
working we can move up to a counter we
can interact with it and spawn an object
but now let's say that we want to spawn
a different object so let's say now we
want to spawn some cheese first of all
let's make the actual object so on the
Tomato let's press contr D to duplicate
this one let's rename this to the che
cheese block and let's go inside of it
now in here inside of the Tomato visual
let's drag here it is the cheese block
visual so let's use this one instead
okay there's our nice visual let's make
sure to save the prefab and go back out
and now let's say that we want this one
to spawn a tomato and this one on the
left to spawn some cheese so let's
override the prefab and over here drag
the cheese block and now if we h on play
can go up to this one yep there's a
tomato go up to this one and yep there's
some cheese okay so it all looks great
but now let's say we want to know what
object we just spawned like what object
is on top of this spawn transform just
like this in the code all we have is a
transform reference so with this the
only way to know what type we spawned
would be if we had different prefabs for
every single object then we could
compare them one by one and see which
one this matches but then let's say what
if we wanted an actual string for the
object well then we would need to add
tons of fields for all these strings for
all the objects then what about an icon
for each type once again we would need
tons of fields each one for each icon
but if we did it just like that with a
bunch of lists then they would be
separate that's not very good we should
have a proper way of defining our object
types and all the data related to them
so this is exactly where scriptable
objects come in these are objects you
can create in your project files which
are perfect for anything where you have
multiple instances of a type like for
example multiple weapons multiple armors
multiple recipes or maybe multiple
ingredients as usual I have a dedicated
video on scriptable objects they are
super useful definitely watch that for
more detail over here and let's just use
them so the first thing we're going to
need is to actually Define the type and
we do that in a c script so in our
script folder let's create a new C
script call this the kitchen object so
now personally so is just what I like to
append to my script B object definitions
just to make it very clear that it's a
script ball object however this is not a
requirement it's just a naming rule that
I like to follow and we're calling this
kitchen object because we're going to
use this to Define any kitchen object we
want to interact with so that's going to
be our ingredients like for example the
tomato and cheese but also things like a
plate and then potentially you could
Implement things like a frying pen or
frying signature or anything like that
so this going to represent any kind of
kitchen object the player can interact
with Okay so let's make the script and
now let's open it and over here okay
first things first is this is not a mono
Behavior instead let's extend script
ball object and then technically you can
have functions inside a scriptable
object but for now let's just get rid of
this so just an empty class and over
here let's just Place whatever fields we
need to store whatever data we want so
like I said first we want a prefab so
let's make a public transform for our
prefab by the way here note how I am
indeed using public this is pretty much
the one exception to the rule I only use
scriptable objects as read only data
containers I never write to them so
since I follow that rule I usually make
the fields in the scriptable object
public that way I can access them
directly without having to make a public
G but if you want do feel free to keep
following the general rule of not making
anything public you could definitely
make this just a regular serialized film
and expose with a get function that
would work personally I just find it
simpler to make it public since I know
that as a personal rule I will never
write to a scriptable object field okay
so we have a transform for our prefab
let's also add a Sprite for the icon
Sprite and finally let's just add a
simple string for the object name all
right so we have our scriptable object
definition we have all the fields for
all the data we want to store now how do
we actually create a script object for
that let's go up here before the class
name and we're going to add the
attribute so let's add the square
brackets and the attribute is the create
asset menu this takes some optional
parameters again I cover them in detail
in the dedicated scriptable objects
video for now let's just leave all the
parameters as empty just use default and
close the attribute okay so that's it
let's save this and go back into the
editor and over here if we go into the
project window click on the plus icon
and right up top yep we do see a kitchen
object as so so if we select it yep
there you go it creates a brand new
object inside of our project files let's
name this one tomato and obviously let's
keep our project nice and organized so
we don't want this inside the script
folder instead let's make a proper
folder so create a new folder call it
our scriptable objects and then inside
let's put a different folder for each
type so let's make another subfolder
call it the kitchen object so and let's
place the tomato inside out of it okay
now with the Tomato selected we can look
in the inspector and we can see yep it
does have all of the fields that we
defined okay great so now we can just
assign them so this is the Tomato let's
drag the Tomato prefab for the econ
Sprite let's find it so that are Sprites
included in the regular assets so here
is the Tomato Sprite so it's inside the
assets then inside textures icons and we
have all the icons and finally for the
readable name let's just call it tomato
all right so that's it here we have a
really nice script object containing all
the data required for our tomato okay
awesome with that done we can now go
back into our clear counter script and
here instead of adding a field for our
tomato pream instead of this let's sort
a reference of type kitchen object so
and let's call it kitchen objecto and
then when spawning let's go inside our
script B object and just spawn the
prefab reference so this is going to be
the kitchen object transform then over
here in the editor let's go inside the
clear counter and let's assign the
Tomato Kitchen object okay so let's save
it and test so here we are let's
approach hit and yep there you go it
still spawns e tomato okay great now
let's make another type for our cheese
block so let's create a brand new
kitchen object as so qual it the cheese
block and again let's assign first of
all the prefab there it is then for the
Sprite of the cheese block and finally
this is the cheese block okay so now for
example let's go into the second one and
on the second counter let's override and
say this one spawn a cheese block Let's
test so here we are approach this one
yep there's a tomato this one and yep
there's some cheese okay great so
everything is working so far however the
original problem that we were trying to
solve identifying the spawn prefab we
still don't have a solution for that
basically when we spawn a prefab we need
to know from which scripal object this
prefab came from so essentially what I
like to do is just attach some reference
to the scripal object in our prefab
however again remember that scriptum
objects are not mono behaviors so if I
select the prefab and I try dragging
these script object nope it does not
work so what we can do is just create a
new script so let's make a brand new C
script let's call it kitchen
object let's attach this to both prefabs
so both the cheese and the block attach
the same one to both them and let's open
and over here very simple let's just add
a serialized field for a kitchen object
so a serialized field of type kitchen
object so for the kitchen object so then
let's also make a quick function to
expose it so we're going to return kit
object so get kitchen object so and we
just return the kitchen object so yep
just like this so now here in the editor
for the Tomato yep we've got the field
so let's say this one is a tomato and a
cheese block this one is a cheese block
now here obviously we need to make very
very sure to drag the correct reference
to the right scriptable object if you
drag the wrong one like for example over
here on the cheese you would say this
one is a tomato if you did that then
obviously you would get some very weird
results so make sure to check and double
check that you drag the right reference
both over here on the prefiles make sure
they are referencing the correct script
object and on the script object itself
make sure they are referencing the
correct pref okay so now if we go here
on the clear counter we spawn our object
okay great then on this object we can do
get component of type kitchen object and
then we can just ask it to give us the
kitchen object so so for example let's
do a debug. log on this one so inside
get the kitchen object the so and then
let's print out the object name all
right so here we are here let's interact
with this one and yep there you go
interacted and spawned the tomato and on
this one yep interacted and spawned a
cheese block okay awesome we spawned a
transform prefab and we identify the
spawned object is indeed this type of
object all right so here we'll learn
about one of the most powerful Unity
features scriptable objects these are
extremely useful for defining a type and
then creating multiple instances of that
type with whatever data we want so that
can be some ingredients like we have
here or it could be some weapons could
even be some NPC data maybe some Quest
data and so on it really is an insanely
very useful feature definitely go ahead
and watch a dedicated video on script
objects then if you want you can also
watch some more videos where I've used
script Mo objects for example the
Minecraft crafting system using script
Mo objects or the hydr crafting system
which again also uses script objects
okay so this done it's working great now
let's continue to the next lecture where
we're going to help the kitchen object
know where it belongs and help each
counter know what kitchen object is on
top of it
hello and welcome I'm your Cod monkey in
this lecture we're going to create a
kitchen object parent meaning that the
kitchen object will know where it is and
the counter will know if something is on
it this is important so that later on we
can pick up a kitchen object from one
place and drop it in another okay so
here we have our player I can move
towards this counter interact with it
and yep spawn a tomato then on this one
spawn some cheese okay great but I
cannot do anything else in fact if I
interact a bunch more times really all I
did would just spawn a whole bunch more
cheese so instead I want to be able to
spawn some cheese and then pick it up so
let's think about exactly what that
means we want a kitchen object to
essentially be placed on a specific
Place based on the design that we're
trying to implement we're never going to
have a kitchen object just randomly
strown around the wall we're not going
to have tomatoes all over the floor
instead the objects will always need to
be placed somewhere and that somewhere
can be either a counter or it can be
being held by the player so essentially
that means that each kitchen object is
going to have some kind of parent that
it's attached to we're going to make
sure the counter knows if there is a
kitchen object placed on top of it and
we're also going to make sure the
kitchen object itself knows where it is
so first let's do that logic over here
on the counter so on the clear counter
script let's keep a field for a kitchen
object so just a simple private of type
kitchen object kitchen
object then when the player interacts
with it by the way we can get rid of
these debug transforms debug logs we no
long need them
okay so when the player interacts so if
the kitchen object is null if so then
we're going to spawn it then when we
spawn it let's assign it so this one
equals the kitchen object get component
of type kitchen object okay so if that
one is no we spawn it and we assign it
and just with this we should have fixed
the issue where we can spawn infinite
objects so over here I can interact and
I interact a bunch more times and I look
in the hierarchy inside the clear
counter and I go inside the counter top
Point nope there's only one tomato okay
great so with this basically we made the
clear counter know if there's something
on top of it now let's do the other side
so let's go into the kitchen object and
make sure that it knows where it is so
over here on the kitchen object script
let's set a simple field for a counter
so private of type clear counter for the
clear
counter and now let's just basically
make two functions one to set it and
when to get it so a public void set
clear counter
and we're going to receive a parameter
of type clear counter okay great and
then we're going to have a public return
a clear counter for the get clear
counter and we're just going to return
our clear counter and on this one just
set this do clear counter equals this
clear counter all right so on this
function we're assigning this field and
on this function we're returning this
field so now back on the counter script
we get the kitchen object reference so
on this one let's call set clear counter
and pass in the this one and if it is
not null so if there's something on top
of this let's just do a debug.log let's
go onto the kitchen object and get the
clear
counter so we should be able to click
once and spawn an object and click twice
and the second time we should be able to
see the name of this clear counter all
right so over here let's approach and
click and yep it's spawn now click again
and yep we've got the message this one
is on the clear counter okay great so
far so good so the counter knows if
there's a kitchen object object on top
of it and the kitchen object itself
knows where it is now let's set some
logic to be able to change a parent
counter so over here on the clear
counter script we basically just need to
call the set clear counter function with
a different counter reference so just
for testing let's add a serialized field
for the second counter so clear counter
for the second clear
counter now we're doing this just for
testing just make sure the logic Works
before we come up with a more General
system so just for testing let's come up
with with some input and again for
testing using the Legacy input manager
to get something quickly up and running
is a great thing so let's quickly get a
button input on the counter so let's
make a private void update and for
testing we only want the testing to work
on one counter so let's also add up here
just say B testing and then on update if
we are testing and we have the input.
get key down on let's say the T key so
if you have that then we can run some
kind of testing code so let's say for
example if the kitchen object is not
null so if we have something on top of
this kitchen counter let's go into the
kitchen object and call set counter and
let's pass in the second clear
counter so basically with this we should
be able to interact to spawn an object
and then press the T key and we should
be able to see that object be set to a
different parent so here in the editor
let's just set that let's say this one
is our main counter so let's drag a
reference to the second one the second
clear counter drag it and make this one
the testing SC s and also just to verify
that it worked over here let you a get
on the clear counter all right so let's
test and see okay so here we are let's
approach this one interact and there you
go spawn tomato and now if I interact
again yep it says tomato is on this
clear counter now if I press the testing
key yep there you go the Tomato was
moved onto the other counter okay so the
parent changed the logic worked however
obviously we have two big issues the
first one is just the visual you can see
the object is still placed on top of
this counter even though techly now it
belongs to this one and the second issue
is that this counter still thinks that
it owns this kitchen object and this
other counter does not know that it now
owns this object so we need to sort all
of that first for the visual it's
actually very simple here when spawning
we are spawning it inside the counter
top point and then setting the Lo
position to zero so whenever we move to
a different second parent when we do
that we can just ask that second parent
to return the counter top point and move
it there so for that let's make a
function to return that
so public we're going to return
transform so get the kitchen object
follow transform so this going to be our
counter top point so let's return the
counter top
point then let's go into the function on
the kitchen object when we set the clear
counter so over here on the kitchen
object on this function so we set the
clear counter then let's modify this
transform. parent go into the new clear
counter in order to get the kitchen
object follow transform and again let's
make sure to set the local position
position back into Vector
3.0 okay so with this when we set the
clear counter to a different one it
should automatically teleport to the
other counter so let's test so here we
are and first let's interact with this
one there you go it's spawn now if I
press the testing key and if there you
go it does move visually okay great so
far so good however the counter still
have the wrong data by the way here's a
quick in tip on the inspector you
already know that you can only see the
public and the serialized Fields however
there is actually a way to look at
private fields on the inspector on the
top right there's these three dots and
if you click on it over here you can
modify it into a debug inspector and
when you go into this one Yep this one
does show all the private Fields so you
can see for example on the clear counter
so that's the right one this one over
here the kitchen object is indeed
assigned and we can go into the other
one and we can see this one has it as
null so debug inspector is really useful
in these kinds of cases if you want to
inspect any kind of private Fields you
can go to this and see it now let's swap
back into the regular inspector
and let's fix that issue by notifying
the counters that the object is changed
so over here basically we have two
options over here on the clear counter
when we modify the parent when we tell
the kitchen object to go to a new parent
when we do that we can make the new
parent responsible to updating itself or
we can just make the kitchen object
itself be the one responsible for
notifying the new parent both approaches
can work personally I think it makes
more sense for the kitchen object to
handle itself so we just call this
function to set set the new parent and
what this happens basically this kitchen
object needs to tell the old parent that
it is no longer there and needs to tell
the new parent that it is on there so on
the counter let's make some function to
set and get a kitchen object so over
here on the clear counter script let's
go down let's make first one to set so
polling void set kitchen object and
receive a kitchen
object and just do this. kitchen object
equals this kitchen object okay great
then let's make a getter so P return a
kitchen object get the kitchen object
and just return this kitchen object okay
then let's also make one just to clear
it so public void clear kitchen
object and this one just sets a kitchen
object into
null and finally just a nice simple
function to test if this counter has
anything on top so just a public bow has
kitchen
object and over here we just return if
the kitchen object is not n
okay so some four very simple functions
now if we go into our kitchen object
script over here when we tell it to
change the parent let's first go into
the current parent and clear
it so let's first of all do a quick test
for null so if this not clear counter
which is the current parent so if this
one is not null then we go into the
current parent so the clear counter and
we tell it to clear the kitchen object
and then we go into the new parent and
we tell new parent to set the kitchen
object and the kitchen object is this
one now here be very very important
don't make the mistake of clearing the
wrong counter keep in mind that over
here this not clear counter this refers
to the previous clear counter whereas
the one in the parameter this is the one
this is the new one so make sure you
clear the kitchen object from the
previous clear counter before you assign
it and then you set it on the new clear
counter so be very very careful here
make sure you don't make mistakes
between the quote unquote old clear
counter and the new clear counter okay
so that's it basically we have this
function to set the new clear counter so
set the new parent we clear the kitchen
object from the old clear counter we add
it to the new one and we update the
visual now we can also add some nice
safety checks here just to make sure we
never make a mistake the kitchen object
should never be set to a parent that is
already holding something so before we
set the kitchen object before we do that
let's make sure that one is empty so
over here just do an if if the clear
counter so that's a new one if this one
has a kitchen object then it already has
something on there this should never
ever happen so let's do a debug.log
error and say counter already has a
kitchen
object we're going to eventually ADD
test to make sure that this never ever
happens but having the error here will
be helpful just in case we miss
something so if it has a kitchen object
we're going to fire an error but this
should never happen so we just set the
error update Visual and so on okay so
finally let's just go over here into the
clear counter script and down here we
have the interact action so we insen the
kitchen object we're currently
repositioning it and then we're setting
this field assigning it to this one now
we made the kitchen object responsible
for doing all that for modifying the
position and for setting the field so we
don't need to do this instead we really
just need to go and get the component of
that and just pass in set player counter
and pass in as this one so we no longer
need all of this now our code is much
more simple also importantly up here we
were previously setting the clear
counter and then doing a debug on log
but when we set it to the new one that
is actually going to clear this field so
if we leave this then this is going to
throw a null reference exception so
let's just get rid of this log here we
no longer need it okay so let's test and
see if all of our logic is working all
right so here we are let's go to this
one interact spond it okay great and
once again we can look in the debug
inspector so let's put it on debug look
at this clear counter so that's the
right one and yep there you go it does
have the kitchen object and if we look
in the other one Yep this one has null
okay great now if I press the testing
key yep visually it did change and if we
look at the counter so if we look at the
old one so that's the right one this one
is at null okay that's great correct and
if we look at the new one Yep this one
does have the reference all right
awesome so now that we are correctly
changing the kitchen object parent for
example we can now interact again with
this one and yep it does spawn a brand
new one and of course if we try moving
it to the other one then we should have
our error as intended this one is
currently already occupied with catchen
object so we should not be able to drop
something on there but if I press the
testing key yep there you go nice ER
okay so that's great we're basically
going to fix this era later on when we
had checks to make sure the object can
only be spawned when it can be spawned
but for now all of our basic logic is
working we can spawn an object and
change the parent all right so with that
here we have added a really important
feature to our game that is the ability
to know where a kitchen object is now
the next step is to enable the player to
be able to pick it up and drop it
somewhere so let's do that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
enable the player to pick up a kitchen
object and in doing so we're going to
learn about another awesome C feature
called
interfaces okay so right now with our
game I can already move the player I can
approach a counter interact with it to
spawn an object and with a testing key I
can move it to a different parent so all
that logic is working now let's make it
work actually with the player let's say
when we interact once we want to spawn
it and if there's an object already on
top of it and I interact again then I
want to give it to the player okay so
here on the clear counter script we've
got our interact function and in order
to make that work we need to have a
reference to the player so I just pass
it in over here as an argument for our
interaction so just pass in the player
reference now over here let's do the
logic that I said so if the kitchen
object is null so if there's nothing
here then let's spawn it okay great but
if there is
something then let's give the object to
the player
so how we change the object parent is
just like what we did up here so let's
go into that one set the clear counter
and pass in the player reference except
of course this obviously does not work
the parameter on this function is
supposed to be of clear counter it does
not work with the type of player
basically on the logic that we built for
setting the parent and change the parent
this whole thing only works with a
counter so it does not work with any
other type so we cannot set the player
as a parent now to solve this problem is
exactly where C interfaces come in
again I have a video going through them
in detail definitely watch it to learn
everything about interfaces basically
what it is is a contract you define some
functions in the interface and then any
type can Implement that interface and
you can write some code that works with
the interface which in turn means that
the code won't work with any type as
long as it implements that interface so
in this specific example we're going to
make an interface to represent a kitchen
object parent then we're going to
implement that interface on both the
counter and the player and that way both
of them won't be able to be parents of a
kitchen object so let's do exactly that
now the first thing we do to Define an
interface is Let's Make A C script so
let's right click create new C script
and now the standard is to start
interface names with the capital I and
then the name so in this case let's name
it I kitchen object
parent and let's open it okay so now to
make an interface first of all this does
not extend mon Behavior nope and
secondly this is not a class instead
this is an interface now like I said an
interface is essentially a contract
where each class that implements that
interface must follow that contract what
that really means that you can define a
bunch of functions here by the way quick
note you can also define properties but
not Fields I cover all of that in the
dedicated interface video but for now
here we just want some functions like
for example let's just put all of the
parent functions that we made previously
on the counter so over here on the clear
counter a while ago we made all these
functions that we needed to make it work
as a kitchen object parent so we got the
transform set kitchen object get it
clear it and has it so let's just copy
all of this and paste it over here on
the interface however one important note
is on the interfaces you don't actually
include any function
implementation the implementation is up
to the class that implements this
interface although again I should also
point out another quick note as of c 7
you can include a default implementation
but that's for more advanced use cases
so for here let's just use the basic and
not apply any default implementation
right here here so we just Define the
function and put a semicolon so just
like this just a function definition
with the exact signature so just like
this okay so now that we have defined
our interface and all the functions that
we want to have with this now let's go
onto the counter script so over here on
the clear counter script over here let's
implement the interface and the way we
do that is pretty much exactly the same
as by extending class so over here we
are already extending mod Behavior then
let's set a common and let's say we are
also implementing the IIT object parent
interface so right now you might be
wondering so this is pretty much the
same thing as extending a base class and
kind of except for one huge difference
when extending a base class you can only
have a single Base Class like for
example over here we have monob Behavior
you cannot extend multiple base classes
there can only be one however when it
comes to interfaces you can Implement as
many interfaces as you want so over here
we have defined our interface and right
now we don't even have any errors that's
because we already implemented pretty
much all the exact functions also Visual
Studio has a really nice Sile icon over
here on the left side it is basically
saying that this function this
implementation is based on the interface
but let's see what happens if I decide
to comment out these functions so if I
comment out all of this and if there we
go over here we have an error it is
telling us that this class does not
implement the members for the interface
like I said an interface is like a
contract so you must write all of the
functions included in the interface so
we must Implement these so let's get rid
of the commments okay with this our
interface is perfectly working over here
on the clear
counter now let's just go into the
kitchen object over here on this script
for now we're still working with the
type clear counter so let's just
refactor this to instead of working with
a clear counter let's make it work with
a kitchen object parent so let's just
change this from type that to Kitchen
object parent let's also rename this so
let's let's Us control RR for the
kitchen object
parent then we got a function to return
the kitchen object okay that's good for
this one instead of set clear counter
let's once again rename this to set
kitchen object parent and inside again
we receive of type I kitchen object
parent then let's also rename the
parameter to Kitchen object parent okay
so all the names here I have changed
okay they're all correct we set it we
assign it over here instead of counter
let let's say kitchen object parent
already has that so just like this and
finally down here let's return I kitchen
object parent and rename this to get
kitchen object parent and we return that
all right so we have changed everything
I can even do control F to search for
counter and nope there's no instance of
any counter so all of this code has now
been Rewritten to work with a kitchen
object parent so like this everything
should be working exactly the same as
previously we have no errors here and
over here on the clear counter we just
have this error on the player let's fix
this in a little bit for now let's just
comment it let's just test it out to see
if everything still works exactly the
same as previously also one final thing
since we modify the interact function
over here on the player class when we
have the interact we just need to pass
in this reference okay so let's test all
right so here we are let's approach this
one interact yep there it is now let me
press the testing key and Y there you go
it does move okay so everything is still
working exactly the same as previously
once again another successful ref
factoring now here comes the magical
moment so right now again everything is
still working exactly the same as
previously so we can only have counters
as parents but now let's go over here
onto the player script and over here
let's also implement the same interface
so let's implement the i kitchen object
parent and again as usual we have our
error so we need to implement this also
again Visual Studio is very helpful so
we can click on the light bulb icon and
let's say implement the interface and if
we scroll down here it will
automatically create all these functions
so let's just actually Implement them so
for implementing this interface the code
is really going to be exactly the same
so let's go up here into the clear
counter let's go down find all of these
functions let's copy them and on the
player let's paste them down here at the
bottom so we just need to also pick up
the kitchen object as well as a
reference to the top point so over here
on the clear counter let's just grab
both those so let's just grab the
kitchen object so go into the player and
over here let's add a field for the
kitchen object and finally let's add
another one for the counter top point so
over here a serialized field for the
counter top Point except obviously the
player is not a counter so this name
makes no sense on the player so let's
just quickly rename this and set call it
kitchen object hold
Point okay here we have our new name
we've got the kitchen object and down
here all of our functions they're all
working no errors all right now let's
just assign this in the
editor so over here let's just go into
our player there's the player script and
requires a reference to the kitchen
object hold point so for that let's do
it just like we did for the Counterpoint
so inside the player let's create an
empty game object call it the kitchen
object hold point and now Bas let's just
position it just slightly in front of
the player so let's put it on a x of
zero on a y of 1.3 and on a z of one so
there you go just ahead that's where the
player is going to be holding the
objects finally over here on the player
let's just rag that
reference okay so far so good
also one note here like I mentioned
previously in order to implement the
interface it requires you to write the
function code basically what this means
is that different objects can implement
the exact same interface whilst having
different implementations so for example
over here on the player when setting the
kitchen object perhaps over here you
could play some kind of item grab
animation or maybe when clearing a
kitchen object you could do some kind of
logging the only thing that needs to
match perfectly is just the function
signature and the function signature
that means the return type as well as
the name and any parameters the
implementation itself that is up to the
class that wants to implement that
interface but in this case we wanted to
behave pretty much exactly the same way
so like this it should be working so we
can now go back here onto the clear
counter script and okay we have our
interaction all right great so if
there's nothing we're going to spawn it
and if there is something on top of it
we want to give it to the player so now
let's go into the kitchen object and
call the function set kitchen object
parent and pass in the player reference
and that's it no errors because again
this takes a parameter of type kitchen
object parent and the player does
implement that interface so that's all
valid now with this let's test and see
if our code is working all right so here
we are and let's interact with this
counter and there you go the object has
been spawned and now if I interact again
yep there you go look that the player
picked up the object and since our logic
is using a transform hold Point as the
parent the player is automatically
carrying this tomato all right awesome
so this is really great now over here on
the counter we no longer need all of
this testing code we now have the
ability to actually pick up objects from
the player so let's get rid of all this
so we don't need this testing code don't
need a reference to the second clear
counter or the testing okay great so
here you can see the power of interfaces
by just implementing the interface we
can now place an item anywhere we want
and importantly on any type we want so
the counter can hold a kitchen object
the player can also hold it we could
make a dog character and make it hold a
kitchen object we could make a vehicle
hold it or anything again interfaces are
really really awesome one of the best C
features definitely go ahead pause this
course for now and watch a dedicated
video on them you should be very very
familiar with interfaces they will help
you in making all kinds of systems and
games if you want to see a clear example
of the power of interface you can go
watch my how to interact with NPC's
video that video takes advantage of
interface to make sure that the player
can interact with any kind of object all
right so thanks to interface we can now
change the parent of the kitchen object
and put it on either a counter or the
player now in the next lecture let's
make a proper different counter type
hello and welcome I'm your Cod Maki in
this lecture we're going to create a
different counter type from where we can
grab some
ingredients okay so far here we have our
character working and we have an empty
counter and by interacting with it we
can spawn an object but obviously that's
not the behavior we want in the finnal
game we want different counter types
that do different things the clear
counter should only be used as a place
for putting down and grabbing objects it
should not spawn anything so let's build
a new counter type and for that one
option is to make a brand new prefab and
build it on from scratch another option
is we can duplicate this counter and
change a bunch of things or there's a
third option that was added in recent
Unity versions you can now have what is
called prefab variance meaning that we
can have a base counter and then we can
make variance for all the types so let's
do exactly that to learn about prefab
variant now first let's duplicate this
one just so we don't lose any changes
let's rename this prefab toore base
counter now I like to add an underscore
just so that the base prefab is on top
since this window is sorted
alphabetically now let's go inside the
base counter let's go into the scene
view so here it is and basically over
here we only want to have all the things
that all of the counters will have so
all the counters will have a boxer all
with the same shape so that's good they
will also all have a counter top
point however for the visual different
counters will have different visuals so
let's get rid of this same thing for the
selected let's get rid of this and on
the actual object different counters
will have different scripts so let's
also get rid of this okay so that's it
this is the base counter it only has all
the things that every single counter
will have so let's go ahead save this
prefab go back outside and now let's
right click on the base counter and go
into create and over here let's scroll
down and find the prefab variant now
let's name this the clear counter except
obviously we can't have two different
names so let's put this one into backup
we're going to get rid of this one in a
little bit so on the variant let's name
it clear
counter let's open up this variant and
now here let's add everything just like
we had on the old clear counter so since
it's going to be exact let's actually go
inside the backup one so here let's just
copy the visual and the selected so
let's copy this
go back inside the clear counter variant
and over here let's space it so contrl +
V save there it is the selected and the
visual finally just script so over here
let's have the clear counter
script and now let's just drag the
references so the kitchen object we're
actually going to remove this in a
little bit but for now let's assign it
the counter top Point Let's drag it and
on the selected we also need to drag the
kitchen counter reference okay so here
is our clear counter as a variant of the
base counter so let's go ahead save this
and go back
outside and now we can finally delete
the old prefab of the clear counter so
let's go ahead and delete this and of
course over here on the scene we've got
some broken prefabs so let's get rid of
both these and let's drop the clear
counter variance so let's drop it place
it over here so let's put it on X of 0 y
of 0 and Z of
3.5 okay so that's see clear counter
let's just put another one to the side
and perfectly on the side so on an X of
minus 1.5 okay now we can begin making
our container counter so for that once
again let's make a variance so right
click on the base counter go into create
and let's create a prefab variant call
this the container counter and let's go
inside of it now here first thing we
need is the visuals so let's go inside
our assets we've got the prefab visuals
inside we have the counters visuals and
let's find the container counters so
let's drag it inside again for the loc
comp position make sure it's all in 0 0
0 okay great then we need to make the
selected so let's duplicate this visual
let's rename this to
selected let's go inside on all of these
then let's modify the material for the
selected material so let's click on the
circle icon and select the counter
select material okay we've got our nice
little ghost icon and just like we did
previously let's start with these
disabled so all these game objects
disabled so they are hidden and on the
selected let's make sure the scale is 1%
bigger so
1.01 also selected this one does not
need animator so let's get rid of this
now let's add the selected counter
Visual and obviously for this one we're
eventually going to need to refactor it
to support multiple visual objects as
you can see this selected has multiple
but for now just make sure that it works
let's just drag just the first one okay
great so our container counter has been
built the only thing that we need is the
main logic script so let's do that let's
go into our script folder let's create a
brand new C script name it the container
counter and let's select the main game
object attach a script and let's open it
all right so now here let's first think
what we want for this counter we want
the player to interact with it and when
it does we want to spawn an ingredient
and give it to the player so that means
that we're going to want pretty much the
exact same behavior that we made over
here on the clear counter so when the
player interacts we spawn and we give it
to the player so let's actually copy all
of this code let's go into the Container
counter and over here let's paste this
we just need to grab the references to
the kitchen object and the kitchen
object so so again just like we did on
the container counter let's copy all
these references and over here let's
paste all of them and of course here we
have an error in order for this to work
this needs to implement our interface so
let's do exactly that so let's implement
the I catchen object parent and back in
the clear counter let's just copy the
exact same code so all of these
functions let's just copy them and on
the container counter just paste them
okay great so we don't have any more
errors here so everything should work we
should be able to interact with the
container counter and we should be able
to see an object being spawned on top of
it over here in the editor let's just
make sure to assign it so let's assign a
default kitchen object so let's say
tomato and the counter top Point Let's
drag the reference and okay everything
else should be working so over here on
the selected we've got the visual game
object on the container counter we've
got this okay great so let's go outside
into scene View and over here let's just
Place some container counters so let's
drag one up there
let's place it on an X of 1.5 on a y of
zero and Zed of 3.5 and let's also Place
another one down here so let's rotate it
to face it
upwards okay so on position 0 0 - 5 okay
great and let's make them spawn
different things so on this one up here
let's actually spawn a cheese block and
on this one down here let's spawn a
tomato so let's also modify the icon
here so from cheese block and let's put
a tomato icon so here it is
okay we've got two counters and two
clear counters so let's test so here we
are and if I approach a container
counter and I press the interact button
and nope nothing happened we cannot
interact with it at all even the
selection visual even that one is broken
so as I approach nope the visual is not
showing up now the reason for this is
actually pretty obvious if we go over
here on the player script down here when
we're handling our interactions so let's
go into the handle interactions function
over here we are doing a rate recast and
we are trying to get component of type
clear counter so basically we're not
doing anything if that object has a
container counter instead of a clear
counter so again we have a similar issue
to the one that we had in the object
parent logic basically we have two types
a clear counter and a container counter
and we want the player to be able to
interact with both them so as a solution
for this exact same problem we could
also Implement an interface just like we
did that would work that would enable
the player to interact with multiple
counters but in this case since the
counters are all very similar very
related objects they're all going to be
kitchen counters as opposed to object
parents where the player and ENC counter
are completely different in this case
since they are all very similar a better
approach is actually to use inheritance
now here I should point out that
inheritance is one of those things that
is simultaneously very powerful but also
very dangerous usually beginners get
really excited when they first hear
about inheritance but after gaining some
experience they start to see the massive
downsides one funny joke about it is
let's say you want to write some code
that all it needs is a Banana class but
because of messy inheritance you end up
with a monkey and the entire jungle
behind it basically the banana extends a
monkey which extends a tree which
extends a jungle and so on so you just
want a small thing but because of a
complex inheritance you end up picking
up a huge object so all that to say
inheritance is something you must use
very very carefully it's a powerful tool
definitely but you need to make sure to
absolutely use it in the right approach
for the problem you're trying to solve
now in this case like I said since all
of the counters are going to be very
closely related in this case it does
make sense and of course in the future
if that does change we can always
refactor if you're a beginner definitely
go ahead and research a bit more on C
inheritance the pros and cons I don't
have any dedicated video on that topic
myself but if you search I'm sure you'll
find tons of content again it's a very
powerful but also very dangerous tool so
definitely use it wisely over here let's
make sure we're wise so let's use it
first thing we need to do is Define the
base counter class so let's create a new
C script let's call it the base
counter so over here on the script let's
get rid of the functions we don't want
any default functions and let's also
make sure that we do extend mono
Behavior we do want that we still want
to use this as a component so let's
leave the script just like this let's
save it then let's go over here into the
clear counter script and on this one
instead of extending mon behavior let's
extend the base counter okay that's it
that's the only change and now let's go
into the Container counter and over here
same thing let's extend the base counter
instead of mon Behavior so now both
these counters extend the exact same
base counter script so now if we go into
the player script so here we are on the
player script and on the handle
interactions function over here instead
of trying to get a component of type
clear counter let's try to get the
component of type base counter so let's
also rename this so control RR to rename
rename this to base counter and of
course we need to rename all these
references that expect a clear counter
instead of a base counter so over here
for the selected counter let's modify
the type to base counter then also up
here when we've got the event ARS let's
modify the type okay so over here we
have the interactor let's leave this for
a bit let's go down and let's fix this
issue so let's go down into that
function to set the selected counter
instead of this type let's receive a
base counter okay so all of these errors
have been solved there's only one left
and it's this one the interact we see
this error because obviously the base
class does not have any kind of interact
method so let's add
that now for adding methods to a base
class actually very simple it's really
just like any other method so first the
accessor for the interact we want the
player to be able to access it so let's
make it public and also since we're
talking about inheritance I should
probably mention the other accessor now
you already know about public and you
also already know about private but
there's another one you might not know
which is called
protected basically this one means that
whatever function we Define with this
accessor it is going to be accessible to
this class and any class that extends it
so for example if we had a function that
was protected the clear counter could
call this function because does extend
this Base Class however the player would
not be able to call this because it is
protected now in our case for the
interact action we do want a player to
call it so let's make it public just
like we had previously then another
keyword for every function that we want
the child classes to be able to
implement in their own way we can Define
it as virtual and finally the functions
signature as normal so for the interact
we made a return void call it interact
and we received a player
argument okay so that's it that's our
basic signature for the implementation
let's leave it empty over here on the
base counter so by default it's not
going to do anything in the game design
that we're building we're never actually
going to end up with anything like this
so if we want for safety we can just add
a debug.log
error to say just base counter. interact
because this should never be triggered
also I should point out for a more
advanced method instead of making it
virtual you could make it abstract and
basically what that does is that forces
of the classes to implement their own
implementation so you would make this
abstract and just put it just like this
as if this were an interface but in
doing so you would also need to define
the base counter as abstract and so on
so obiously this is a more advanced
method so don't worry about it for now
let's keep it a bit more simple so let's
make it just virtual void interact okay
great so we have this let's save this
and now if we go on the clear
counter over here on the interact notice
how we have a green squiggle line
basically this is a warning it's telling
us that we are hiding the base function
now in reality we don't want to hide it
instead we want to override it so before
the void before the return type we just
add the keyword
override and Yep this will now override
the base function so when the player in
interacts with an object of type based
counter and that object is actually a
clear counter when the player calls the
interact function instead of running
this code it's actually going to run
this code now let's do the same thing on
the container counter so over here let's
also add the keyword override to
override the base function okay great so
we have no errors here and on the player
we also don't have any more errors since
that one does now implement the interact
function so with this let's test and
everything should still be working so
over here let's approach the counter and
let's interact with it and yep it does
work it spawned some cheese and down
here yep it spawned the tomato and then
if we go onto the empty counter and
interact and yep it still works okay so
here we added the ability to interact
with two different counter types all
right great now know how the selected
logic isn't really working well you can
see the container counters they are both
selected even though the player is not
looking at them and actually if I
approach it then it actually becomes
deselected basically the reason for that
is because these selected script that
one is still referencing the clear
counter inside of the base counter so
right now it's only being selected when
the selected counter is null so that is
why as I approach it actually hides
itself so let's fix this let's go inside
the container counter prefab and inside
we've got the selected and yep over
there we have a reference to that so
let's open up this script and over here
all we need to do is just modify this
type so let's make it of type base
counter and let's rename this to base
counter okay that's the only change we
need
and by the way since we're here let's
also fix the other issue the issue we
had where we need to support more than
one visual game object so instead of
having a field of type just game object
let's receive a game object array so
let's modify this to game object array
and then down here on the show hide is
actually very simple so let's just do a
4 in game object for the visual game
object in the visual game object array
we go inside set it to true and on this
one we set it to
false okay that's it super simple now
let's just update the prefabs so first
over here on the container counter let's
rag the container counter reference as
the base counter okay great and for the
visuals let's just drag all of them so
let's drag the counter solid drag it on
top then the counter hole drag it on top
then the single door drag it and the
black drag it and also by the way over
here on this counter this one actually
has a object Sprite this is the actual
Sprite in there but for the selected we
really don't want that so if I enable
this game object here we've got the
object Sprite let's actually delete this
we don't need the actual icon Sprite to
be highlighted so let's leave it just
like this so we only have these four
objects and all four of them are on the
list okay that's great so all the
references in here they're all working
perfectly so let's go back outside let's
save the prefab let's go inside the
empty clear counter and on this one same
thing on the selected let's Drag The
Insider reference and for the base
counter let's also drag that
reference okay so let's go outside save
it and let's test and now let's see if
the selected works so as I approach this
one yep it works yep it works and on
this one yep it works and down here yep
it works all right awesome so we can
interact and we can highlight our
selection okay everything is working
great so now that all the code is
working we can inspect the code to see
if we can refactor
anything we can see for example if
there's any kind of common logic that
all of the counters share that we should
probably write in the base counter and
you can see right away that both the
clear counter and the container counter
both of them implement the kitchen
object parent interface that behavior is
something that all of the counters won't
share so instead of defining it on each
counter itself let's actually do it on
the base class instead so let's get rid
of the interface implementation here and
also on the container counter let's get
rid of that and said on base counter
let's Implement that one so I kitchen
object parent and for the functions
let's do the same thing so let's cut
this one from here and let's bace it on
the base counter it's okay now we need
these two points so let's go ahead copy
all of this let's go into the base
counter paste it except for the base one
doesn't need a kitchen object as so so
just the counter top point and the
kitchen object okay so there are no
errors on this one let's go into the
Container let's get rid of the kitchen
object and the counter top Point okay
great now we see an error but before we
worry about that let's actually go into
the clear counter and let's do the same
thing so let's get rid of this get rid
of this and down here get rid of all
these
functions okay so now the counter
scripts are much much more simple all of
the common code is now written directly
on the base counter now for solving this
the container counter needs to know if
there's a kitchen object on top of it so
now here we have an interesting question
with two possible
approaches basically we need access to
this object so one approach would be to
make this protected like I said
protected means that any classes that
extend this base counter class any of
those classes can then modify that field
so like this yep there is no more errors
that's one approach and the other
approach is to instead keep this one as
private and whenever we want to interact
with it we simply interact through these
functions both approaches can work and
when in doubt as usual you should
probably go with the more limited option
so let's leave it as private and work
with these functions instead over here
here on the container counter instead of
testing if the kitchen object is null
let's just test has kitchen object so if
it does not have a kitchen object then
we're going to spawn it and for spawning
over here we could grab the actual
transform follow so this one up here we
could call this function to get it or
since that is actually going to be
handled automatically when we call this
function to set the parent then let's
actually not use this at
all so we just spawn it and set the
kitchen object parent okay great so now
let's just look at the clear counter for
this one like I said it's not really
meant to spawn anything so let's
actually remove all of this
code this one is only going to serve to
pick up and drop items we're going to
handle that in the next lecture but for
now let's just go back into the
Container counter and let's do the
proper logic that I mentioned in the
beginning basically on this one we want
to spawn the object and we want to
immediately give it to the player so
when we call set kitchen object parent
instead of passing in this let's pass in
the player reference and that's really
it for the container counter this is all
we're going to do so the player
interacts and it spawns an object and
gives it to the player okay so that's it
with this as you can see the code for
all of our counters is much much more
simplified so basically it only handles
the logic related to that specific
counter everything else is on the base
counter so let's test this so here we
are and if I approach the counter
interact and yep there you go spawn some
cheese and gave it to the player okay
great now just for fun when I made these
assets I actually included a nice
animation so if you go inside the
container counter over here on the
visual note how this already has an
animator with an animator control
attached to it you can double click to
open it up and over here you can see
it's very simple basically just has two
animations one is the container close
and one is the container opening and
closing these transitions are basically
triggered by this parameter this is a
trigger parameter so when triggers goes
into the open close and when this one
ends goes back into close so let's just
quickly add these nice animations
however again as usual let's make sure
to write some good clean code so let's
not add the visual over here on the
logic script instead let's make a proper
new script over here let's create a new
script call this the container counter
visual okay now we want to attach this
only to the visual game object so only
this one let's attach okay and over here
the first thing we need is to get the
animator so let's sort a field for the
animator and since it's on the exact
same object we can just make an awake
and get component of type
animator and we just assign this field
okay so with this we have the animator
now we just need to know when we should
play the animation so let's go over here
on the container counter script and
basically let's make an event that we're
going to fire when the player grabs an
object so let's make a public event of
type let's stick with the standard so
let's use event handler inside using
system okay let's name this on player
grab object
and then down here when the player
interacts and gets an object let's fire
off this event so invoke let's invoke
with this an event rx.
empty okay so we are firing off this
event and over here on the visual first
we need the field for the container
counter so let's add it up here let's
add a serialized field of tripe
container
counter okay we have this field now
let's listen to the event but again
we're accessing an external reference so
let's let's make sure to do it on start
and not on awake so let's go into this
one and listen to the on player grabed
object event okay so here we have the
event and it's over here that we want to
access the animator and call set trigger
in order to play the animation again
when working with animator parameters
suddenly we do need to use strings
there's no way around that but at least
we can make it a bit more clean by
defining a constant so up here a private
con string call it open close and let's
make sure to use the exact same
parameter name so open close
and then down here on the set trigger
let's call this
trigger okay so that's it some very
simple Vision logic and now over here
inside the prefab all we need is to drag
the container counter reference so let's
drag it also make sure that it has the
animator and the animator controller so
with that everything should already be
set up so let's go back into the scenes
save the changes and let's set on play
so here we are and if I go towards the
tomato and interact and there you go it
plays a nice little animation all right
right awesome okay so here we created a
brand new counter type and we refactored
our interact code to be able to interact
with any counter type the player can
interact with the container counter to
pick up an object now the next obvious
thing that we need is to enable the
player to drop an object on the clear
counter so let's do that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
enable the player to pick up and drop
objects okay so we already have the
player working I can approach this
container counter interact with it and
yep the player picks up something now
that's left is being able to put a clear
counter and being able to drop this
object so let's do that let's go over
here on the clear counter script and
when we interact with it we're going to
do a bit of logic first let's just check
if this counter is empty meaning if
there's no kitchen object on it so let's
test if has kitchen object or if not so
let's say if we don't have a kitchen
object then there is no kitchen object
here
and if not then there is a kitchen
object
here okay these are the two valid
options so if there is nothing here then
let's check the player itself so we go
into the player and we can ask the same
question so has kitchen object so if the
player is carrying
something so over here the player is
carrying
something if so then basically we just
want to drop that object from the player
and drop it in here so that's very
simple we just go into the player we get
the kitchen object that the player is
holding and we just modify the kitchen
object parent onto this
object all right so that's it just with
this it should already be working let's
do a quick test before we handle the
rest of the
interactions okay so here moving the
player and if I just interact with the
clear counter and nope nothing happens
okay great since the player is not
carrying anything nope nothing happens
all right great now let's pick up
something from the container counter
okay so now the player is carrying a
tomato approach a clear counter press
the button and yep there you go there it
is all right Awesome everything worked
now this is an excellent point to know
just how easy this was to implement and
the reason why it was so easy was
because we focus hard on writing some
good clean code for how the object and
the parent system works because we took
some time to think about that it was now
very easy to implement this brand new
action so this is a very very clear
example of the power of writing good
clean code okay so with that now let's
implement the rest so over here there's
no kitchen object here and the player's
carrying something but if not we've got
the else so player has nothing so if the
player doesn't have anything so let's
not do anything so player not carrying
anything so those are all the possible
States up there then down here if there
is a kitchen object on this clear
counter if so then let's check if the
player has a kitchen
object so in this the player is carrying
something and and if
not then the player is not carrying
anything so basically if there is a
kitchen object here and the player is
carrying something if so then we don't
want to do anything since we can't give
the player two items however if there is
a kitchen object here and the player is
not carrying anything then we want to
give it to the player so let's just get
the kitchen object the one that is on
this clear counter and let's do the
exact same thing so set the parent and
set the parent off to the player okay so
that's it as you can see some very
simple logic so let's test okay here we
are and if we interact nope nothing
happens okay great now pick up a tomato
go there drop it yep there it is now if
I interact again yep there you go I
picked it up again so I can go somewhere
pick it up drop it and everything works
perfectly all right awesome now the last
thing that we need to fix is the
container counter right now it's giving
out an object every time even if the
player has something so if I pick up yep
it works now if I pick up again there
you go we've got our nice helpful error
this should never happen so let's set
some nice checks so over here on the
container counter okay we have our
interaction and before we spawn anything
let's just see if the player can pick up
something so once again very simple
let's just go into the player and we
check does the player have a kitchen
object if so we're not going to give it
anything but if the player does not have
a kitchen object then yep the player
picks it up and we give it the
object okay so that's it it's this
simple Let's test so here we are let's
pick up some cheese okay great now pick
up another one and nope nothing happens
okay great we're already carrying
something so we cannot drop anything now
drop it in there now pick up a tomato
and yep it works I can pick it up drop
it and yep everything works okay great
let's just see one more thing over here
the container counter is spawning the
object and the object is the one that we
assigned so over here in scene view
we've got the container counter this one
is placed on the scene and we' made an
override to spawn a cheese block
technically we could keep doing this
pretty much just duplicate objects
modify the Sprite modify over here the
kitchen object that would work but
another better approach would be to
Simply make some prefab variants and yep
that does work you can make a variant of
a variant so let's do examply that over
here on the container counter let's
right click go into create let's create
another prefab variant and let's say
container counter this one will be the
Tomato now let's go inside the prefab
and over here make sure it has the an
object for tomato okay great and over
there on the Sprite so let's find the
object Sprite and choose the Tomato
Sprite so there you go this one okay
let's exit and save all right now once
again let's right click on the container
and let's make it another one this is
going to be the one for the cheese block
so let's go inside of it and over here
modify it for the cheese block and
inside the actual visual let's modify
the Sprite and it's actually that one so
the cheese block okay great let's go
back outside
and since we're here doing this let's
make all of the other grabbable objects
from the containers so let's first make
the kitchen object as so so let's go
over here we can right click go into
create create a new kitchen object as so
let's make one for the
bread then let's duplicate this one
we're going to have a cabbage and
finally we're going to have the meat
Patty
uncooked all right so now let's make
sure to assign all the data for all
these scriptable objects first we need
to make the actual kitchen object so
let's duplicate get tomato name this one
bread let's go inside of it and first
for the kitchen object as so let's make
sure to drag the correct one okay
there's the bread and for the visual
this one is not a tomato so let's go
inside our visual assets inside the
prefab visuals let's pick up the bread
visual okay there it is that's all we
need so let's go outside save the
changes and then select the bread script
object drag the prefab reference okay
for the Sprite this is the bread and
finally just call it bread okay let's do
the same thing for the other one so next
up for the Cabbage let's do the Cabbage
drag the Cabbage script object let's go
inside and modify the visual so the
Cabbage
visual okay that's it then on the
Cabbage script object drag the reference
for the prefab let's assign the Sprite
and finally give it a name
cabbage and finally the meat Pion cooked
so let's do that one so let's duplicate
it name it meat Patty
uncooked let's go inside modify the
kitchen objecto for this one and for the
visual let's select here it is the meat
Patty
uncooked okay let's go back outside and
on the script M object let's just drag
the prefab assign the Sprites so this
one is the uncooked so it's this one and
finally meet Patty uncooked okay great
so we added all of these script M
objects we also have the prefabs with
the visuals and the logic script now
let's just make the container counter so
once again let's create another variant
so prefab variant this one is for let's
say for the bread then let's make all
the other ones already so let's go make
another prefab variant this one is going
to be for the meat Patty
uncooked and finally another variant
also here make sure you're creating a
variant of the container counter don't
make an accident of creating a variant
of something else let's make another
variant one final one and this one is
going to be for the cabbage
okay we have all the variants now let's
just assign them so let's go inside the
bread and over there modify the
scriptable object for the bread and for
the icon modify for the bread icon okay
let's go to the Cabbage save the changes
modify that one for the Cabbage go into
the icon and modify the icon and finally
the meat Patty uncooked let's go ahead
modify this one for that one and the
icon put it on that one all right
everything is working now let's just
place some over here in our scene so
let's get rid of the ones that we made
some overrides so let's get rid of that
container counter and said for that one
let's drag the cheese block put it right
in there let's put it on X 1.5 y of z z
of 3.5 okay then down here for this one
let's put the Cabbage next to it let's
rotate it to face upwards so like that
let's put it on X of - 1.5 y of 0 and- 5
on the Zed then for tomato let's get rid
of this one and use the proper tomato
one so let's rotate it put it on an X of
0 y 0 and - 5 okay next we want some
bread so let's put the bread up here on
the left side let's put it on X of minus
3 0o on the Y and 3.5 on the
Zed and finally the meat Pat and cook
let's put it over here a bit more on the
side let's put it over here on X of 7.5
0 and 3.5 all right so we have
positioned all of them let's just make
more clear counters so we can actually
place the objects so let's put this one
over here on minus 4.5 this one over
there let's also put some counters let's
say one on the right side and a bunch
more down here let's rotate them
upwards let put this one on 1.5 minus
5 and one more over here on the
side okay great so we have all of our
container counters as well as a bunch of
clear counters so let's test make sure
that everything works okay so here we
are let's go down pick up a tomato yep
there's a tomato now a cabbage yep
there's a cabbage now some bread there's
some bread and some cheese there's some
cheese and some meat and yep there's
some meat all right Awesome everything
works so with this over here we added
the ability to pick up and drop objects
on an empty container and spawn them
from all kinds of container counters now
in the next lecture let's build a
counter we can interact with in a very
interesting way hello and welcome I'm
your Cod Maki in this lecture we're
going to create a cutting counter so
this is going to be a counter where we
can place an object like for example a
tomato and after doing a secondary
interaction we can slice it however
before we do that let's just fix one
slightly annoying issue so right now the
player is walking around okay that's
great I can approach a counter and
interact with it that's great however if
I approach a counter from the side look
how the player is pointing towards the
right and if I press the double key I
can indeed select it but the player does
not rotate to face the counter so that's
just a minor visual issue but still I'd
like to fix it so let's do that very
quickly basically the issue is over here
on our player script so we scroll down
and find our handle movement function
okay so here we were doing a bunch of
capsule cast in order to fix the problem
with the diagonal movement so you try to
move in One Direction if not try to move
in just one of those and if we can move
then we assign the move Direction and
then move it basically the problem that
we have here is that if I press dou to
face towards the counter then over here
when we do this logic so it's going to
first attempt the X movement only and
the x is going to be zero so the move
the x is going to be 0 0 0 so it won't
actually move anywhere which means it
won't be able to move so this one
becomes true which then sets a move
direction to 0000 0 which then down here
when we have our rotation it's not
actually going to rotate to anything so
we want the player to still not go
through any objects but we only want to
modify the move Deer over here if we
actually move in any of these directions
so the solution is actually super simple
so over here for the can move we can
move if there's nothing on there and and
if the move direction dox is not
zero so that's really it if we are
attempting to move in the X at all and
if there's nothing on there then we can
move which means we then assign the move
direction if not then we don't touch
this and same thing down here so we can
move if there's nothing on it and if the
move deer. Z is not
zero so that's it just this one simple
change and now the player should be able
to rotate so here we are and if I over
there and the player is currently
looking to the left and if I press W to
point towards the container counter and
you there you go the player does rotate
a little bit so that feels a bit more
natural all right so that's just a tiny
visual thing that I wanted to fix okay
so let's keep going now let's handle the
actual cutting counter so first of all
as usual let's make a counter variant so
let's right click on the base counter
create a new prefab variant call it the
cutting counter let's go inside of it
and over here for thing we need is the
visual so let's pick up from the assets
The Cutting counter visual so here it is
then we need the selected so let's
duplicate this one let's rename this one
to selected and on the animator let's
get rid of it and instead at the
component the selected counter visual
okay great now let's wrag the visuals
for the visual game object array and by
the way here's a quick tip on the right
side on the inspector you can see this
nice little lock icon so if you click on
it then that means this inspector will
not change as you select other objects
so I can click on and select something
different and this one does not change
it is still showing the selected object
now this is useful when you want for
example to drag multiple things so you
can lock the inspector then the Hier key
you can use shift click to select
multiple objects and then just drag them
all directly inside the array that's it
just a nice quick tip so everything is
done let's unlock it there it is okay so
that said let's just assign the selected
material so the counter select material
let's make it just 1% bigger so let's
lock them all 1.01 okay and let's start
with all of them disable Okay so the
basic setup is done now let's make our
script to run this so let's go down
let's create a brand new C script for
The Cutting
counter let's select the parent game
object and attach a cutting counter and
let's
open now here as usual in set of all
this let's start off by extending the
base counter
okay once again thanks to how we set
things up using such clean code this is
pretty much all we need to make a
counter with this the counter already
works as a counter then next thing we
need is to customize any logic specific
to this counter by just overwriting the
interact function so that's it now over
here we can put whatever logic we want
just for the cutting counter and for
this one for star is actually going to
be just like the empty counter meaning
we're going to be able to drop objects
on this so let's just go directly into
the clear counter so here it is and
let's just copy all of this code going
into the cutting counter and and past it
okay so the exact same logic so checks
if there is a catch an object or not
checks if the player is carrying
something or not and picks up or drops
it with this let's do a quick test just
to make sure this one is working exactly
like the clear
counter so over here let's just make
sure to drag the last references so on
The Cutting counter let's make sure to
drag the counter top point so drag that
reference and then on the selected Drag
The Cutting counter reference okay
everything is good let's exit this
prefab make sure to save all the changes
and over here in the scene view let's
Place one of our cutting en counter so
let's paste them right in there let's
put it on X of 4.5 0 and
3.5 okay so let's test all right so here
we are now if I approach and I interact
nope nothing happens okay great pick up
some cheese and drop it on there and yep
there it is I can pick it up I can pick
up some bread drop it and yep everything
works okay so far so good now the next
goal is to use the knife and actually
slice the object that is on there and
for that the first thing that we need is
we're going to need a different input
right now we only have the movement and
the interaction so let's add another alt
interaction for that let's go into our
input action so let's open it up and
over here let's make another action so
create a new action call it interact
alternate and for The Binding let's put
it on another key so let's listen and I
think on F makes sense so let's go ahead
select this one then as usual let's make
sure to save the asset which in turn is
going to generate C class and compound
the code okay great now we can go here
into our game input class and let's do
the exact same thing we did for the
interact action so first of all let's
listen to it so let's go inside the
player input actions inside the player
action map so this one is the interact
alternate and let's listen to the
performed event okay and when we have
that let's fire off an event pretty much
the same thing so interact alternate
action and down here and let's just fire
off this event so let's invoke using
this and event arsmt
okay so we have the input for the
interact alternate now let's go on the
player to listen the same way we were
listening to the regular interact
action so over here on the player script
let's see how we're doing things so we
go into game input and listen that so
let's do the same thing game input and
on interact alternate action let's
listen to this one and when this one
happens let's do pretty much exactly the
same thing except we're just going to
call a different
function so instead of interact let's
call interact alternate
which in turn obviously means we need to
Define this function so let's go into
our base
counter so here we are on the base
counter we've got the interact and let's
make another one exactly the same just
different name interact
alternate okay that's it and now we are
only going to implement this in the ones
that need
implementation so for example on The
Cutting counter over here let's override
that one so public override and let's
override the interact alternate
and now here let's check check if
there's something placed on here so if
there's a kitchen object placed on this
counter if so then let's basically cut
it and for cutting it the simplest way
is really to destroy whatever object is
on there and just spawn the sliced
object so let's handle destroying a
kitchen object for handling that let's
go over here on the kitchen object
script and let's make a simple function
for this object to destroy itself so
let's go up here make it public return
void and for the name I like to use the
name destroy self to make it destroy
this
object and really all we need to do is
just destroy and call destroy on this
game object however before we do let's
make sure to clear the parent so let's
go into the kitchen object parent clear
it and then destroy the game object okay
that's great it's really this simple and
then on the cutting counter let's get
the kitchen object that is on here and
tell it to destroy itself okay so that
destroys the object and after we do
let's just spawn the slices object so
for now just keep things simple let's
make a direct reference up here so let's
make a serialized
field let's make it of type kitchen
object so and for the cut kitchen object
so okay so we have this then here in the
editor let's make sure drag reference so
let's go inside the cut en counter let's
open up the prefab and inside let's
assign this one that means we need to
create the object so let's actually do
that
first so let's create a brand new
kitchen object so let's call it for the
tomato
slices then if we do this we need to
create the prefab so let's once again do
the same thing tomato slices make the
prefab let's go inside this prefab let's
modify the visual so use the tomato
slices visual okay and drag the
reference for the other kitchen object
for the tomato slices okay so the visual
prefab is good and let's just go into
the kitchen object let's just just make
sure to drag the prefab reference then
let's assign the tomato slices icon and
just call it tomato
slices okay so we have the kitchen
objecto now we can go into the kitchen
cun encounter and over here let's open
up and set this one to the tomato slices
okay so we have all the references let's
go back outside save it and back over
here in our code so we have this now we
just need to spawn this object so we're
really just going to spawn it pretty
much EXA like we did over here on the
container so we just go into the scripal
object spawn the prefab and set the
parent so let's do exactly that over
here we destroy the object then we ineni
the cut kitchen object and instead of
getting into the player let's put it on
this okay so that's it we should be able
to place a tomato directly on top of the
cutting counter and it should be able to
transform from a tomato into a tomato
slices okay so here we are let me pick
up a tomato go up there drop it and okay
that works now if I press the alt trct
key press it and Y there you go it did
work the Tomato was destroyed and the
tomato slices were spawned and now I can
pick them up place them anywhere and yep
everything works all right awesome so
with this the basics are fully working
let's just briefly clean up this code we
already saw a little bit of code
duplication so the cutting counter is
going to spawn an object and the
container counter is also spawning an
object so we're copy-pasting these two
lines of code in multiple places so
instead of doing that let's put it in
just one place and actually a good place
to put this is on the kitchen object L
itself so it makes sense that this one
is responsible for spawning more objects
so let's put it over here however let us
not make it a regular function instead
let us make it a static function again
just like we saw for the Singleton by
making it static it means that the
function is going to belong to the class
itself as opposed to any instance so
let's go all the way down to the bottom
of the file person I like to put Statics
at the end and over here let's make
public make it static we're going to
return a kitchen object and let's call
it just spawn kitchen
object and for our parameters let's
receive the kitchen object as
so and let's also receive the kitchen
object
parent okay so that's it and we're going
to do the exact same thing so let's go
into the cutting counter and copy the
code that we were using and over here
just paste it in there so we go inside
here spawn the prefab and set it on this
parent and finally let's return
it so let's return the kitchen object
over here let's pick it up so the
kitchen
object we get it and then we do kitchen
object set the parent and finally we
return the kitchen
object all right so that's it here we
have a super simple function that we can
call very easily it will automatically
spawn an object and set to parent so now
let's just call this from somewhere so
over here on the cutting counter instead
of doing all this let's just go into the
kitchen object again remember let's go
through the class name itself and not
any instance
and over here let's call the function
pass in the cut kitchen objecto and for
the parent it's going to be this all
right so that is now much much simpler
and let's do the same thing over here on
the container counter so if the player
is not carrying
anything let's give the player this
object and give it to the player just
like this as usual when we do some kind
of refactoring let's do a quick test to
make sure everything still works exactly
the same okay so here we are and if I go
to the counter and pick it up yep it
does work does on the object now I can
drop it in there I can cut it and yep
there you go everything does work all
right so far so good so with all this
basically we have created a brand new
counter where we can cut objects however
right now there's obviously one huge
laying fall if I now pick up a cabbage
and I drop it on the cutting counter and
I interact with it that cabbage has
suddenly magically turned into tomato
slices now that is obviously not
intended so for that let's define a
proper cutting recipe and let's do that
in the next
lecture hello welcome I'm your Cod
monkey in this lecture we're going to
create another scriptable object type
this one is going to be for handling our
cutting recipes so here's our game I can
pick up a tomato drop it on the cutting
counter cut it there you go slic
Tomatoes however if I could pick up a
cabbage go there cut it and there you go
cabbage turns into tomatoes so we have
an obvious issue The Cutting object is
currently hardcoded instead of being
based on the object we put on top of it
so to solve that let's make another
script ball object type like I mentioned
script B object objects are excellent
for storing and organizing data so it's
perfect for this use case basically we
want a scriptable object to hold a
reference to the regular object and the
cut object so we can then identify the
input in order to spawn the output okay
so let's build that let's create a brand
new C script call it the cutting recipe
so and let's open it okay so now here
let's do exactly that so something
extremely simple so instead of mono
Behavior this one is a scriptable object
let's add the create asset menu
and finally for the fields let do just
an input and output so we've got of type
kitchen object so let's go for the input
and another one for the
output okay so that's really it super
simple now here in the editor before we
create let's keep things organized so
let's make another folder let's make it
for the cutting recipe so and inside
let's right click create a new cutting
recipe let's call it tomato to tomato
slices and over here let's select the
reference so the input is going to be
our tomato and the output the tomato
slices okay so this is how we're going
to handle things so let's go ahead and
make actually the final kitchen object
Asos so let's make yet another one a
kitchen
objecto let's make it for the Cabbage
slices and then let's have another one
for the cheese
slices okay so now let's make these so
as usual let's duplicate tomato make the
cheese slices and another one for the
Cabbage slices
let's go inside of it and first of all
drag the kitchen objecto so this one is
the Cabbage
slices and let's go modify the visual so
instead of this one the Cabbage slices
okay so we have this let's save the
prefab go outside then the other one we
made the cheese slices so let's swap
this out let's find the cheese
slices and modify the kitchen object
asell
okay so finally just assign the
references
so on the cheese slices drag the cheese
slices prefab let's assign the icon and
call it cheese
slices okay so finally on the Cabbage
slices so these are the Cabbage
slices let's pick up the icon and let's
drag the prefab reference okay so far so
good we have created our new icons and
over here let's just make all the other
cutting recipes so we've got two more so
one is going to be the cheese block on
onto cheese slices and the other one is
going to be cabbage onto cabbage slices
so all we need is just to drag drop the
scriptable objects so for this one
cabbage let's drop the cabbage on the
input cabbage slices on the output for
cheese block that's the cheese block on
the input and the cheese slices on the
output okay great all of our data is now
stored in some really nice scripal
objects so now let's go here into our
cutting counter and instead of having a
hardcoded kitchen object
let's receive a field of type cutting
REO except we're going to have multiple
so let's actually make an array of this
call it the cutting recipe so
array now for the interaction this is
picking up and dropping things so let's
leave that the same for now and over
here on the alternate basically we need
to find out which recipe we should apply
to this so how I identify that is pretty
simple so we've got the kitchen object
that is placed on this object and we've
got a list of cutting recipes which in
turn has the input so we just need to
cycle through all the recipes in order
to find the one where the input matches
okay so let's go down here make a
function to do just that let's make it
private we're going to return a kitchen
object so so let's call it get output
for input so we give it a certain input
and Returns the one that matches that
one so it turnes a kitchen object so for
the input kitchen
objecto and now here let's cycle so do a
for each cutting recipe so in the
cutting recipe so right so let's cycle
through all these and just check if the
cutting recipe so if this one do input
matches the input that we received if so
then this is the one we want so let's
return the cutting recipes so. output
and to make sure that the function Works
down here let's return
no okay so that's it we give it an input
and we get back the output so now here
we just need to make sure to do it
before we destroy the current kitchen
object so let's store a kitchen object
as so for the output kitchen object so
so and we just get the output from the
input and for the input pass in the get
kitchen object so that's the one inside
of this cutting counter and let's get
the kitchen object so so that gives us
the output and then we just spawn that
output okay so that's it let's test
finally back in the scene let's just go
inside the prefab and over here on
cutting counter we need to make sure to
add all the recipes so let's add so the
Cabbage then a second one for cheese B
and finally for the Tomato okay so there
are all of our recipes let's go outside
save the changes and let's test okay so
over here let's pick up a tomato go up
there slice it there you go got some
tomato slices now pick up some cheese go
here slice it and there you go got some
cheese slices and finally the Cabbage go
up there slice it and there you go some
cabbage slices all right awesome so
everything is working perfectly however
now let's say that I want to pick up
some bread and bread should not really
be able to be cut so if I go ahead and I
cut it and there you go there's our
error we have no recipe that takes bread
as an input So that obviously leads to a
non reference exception now here we have
two options for solving this problem one
option is simply over here when we do
the interact alternate we get the output
for the input and if this one returns
null then we just don't cut it so we
don't destroy it and we don't spawn it
or alternatively we can actually add
some validation over here when dropping
objects so we can make sure that we only
drop valid cutable objects now both
approaches are valid and actually we do
need to implement both of them we'll see
why in a bit so let's do both starting
off with the validating the drop so
first we check if there's no kitchen
object on this cutting counter then we
check if the player is carrying
something and then we drop it from the
player on this so over here let's just
check if there's any recipe that has
whatever the player has as an input so
let's go down here make a function to do
that private let's return a bow and call
it has recipe with input
and we're going to receive a kitchen
object so for the input kitchen object
so so and over here let's do pretty much
literally the same logic so we have this
and if we find a match then let's return
true so there's a recipe with that input
if not return false so now up here when
the player is carrying something let's
check if has recipe with input and give
it the player get the kitchen object the
player is holding and get the kitchen
object so so if there's any recipe that
takes whatever the player is carrying as
an
input if so then we drop
it okay so like this let's sayest and
see if we can drop the
bread okay so let's pick up some bread
go ahead drop it and nope does not work
pick up some cheese and yep that one
does
work however now we actually also need
the other validation that I mentioned
the reason is because if we place Val
object like for example the cheese there
so that works and I can cut it and yep
that does work however Now the recipe
the cheese block became cheese slices
and now cheese slice is no longer an
input to any cutting recipe so now if I
try cutting again y there you go I've
got another non reference exception so
we need to validate putting objects on
top of it and also actually cutting them
that logic is also pretty simple so
let's go down to the interact alternate
so we just check if there's a kitchen
object on The Cutting counter and
has recipe input and let's get this
kitchen object get kitchen object so
just like this so we're only going to
cut if there is a kitchen object here
and it can be
cut okay so let's test so first of all
the other one let's pick up bread and
nope Cannot drop okay great now pick up
some cheese and I can drop now interact
cut now cut again and yep there you go
no more errors all right awesome okay so
here we have everything working perfect
perfectly I can pick up a cabbage go up
there cut it into slices I can slice
some cheese and I can even slice some
Tomatoes everything works perfectly now
the one thing missing from our design is
we don't actually want this action to be
instant we don't want to just press a
button everything slices instantly
instead we want to have the player press
the button a few times in order to
actually cut so let's do all that in the
next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
add the mechanic for the player to be
able to cut multiple times in order to
actually cut an object okay so we have
our cutting counter I can drop a tomato
and press a button there you go it cuts
it straight away now we want the exact
same logic but we want it to take a few
Cuts before the cut object is spawned so
let's start off by going here onto the
cutting counter and basically let's keep
track of some kind of progress basically
the way we do that is pretty arbitrary
it's up to you to decide for example you
could use a normalized float however for
cutting since this is going to be a
discrete action let's actually count the
numbers with an INT so let's store a
private end just call it cutting
progress okay so now let's begin by
actually initializing this progress so
when the player drops something on there
let's set this one to
zero and then down here when we have the
interact alternate we do our logic and
when we do let's just increase this by
one and now we need to know if the
object has been cut so we need somewhere
to Define some kind of Maximum and for
that we can actually do it directly on
the recipe so so inside the The Cutting
re so over here we've got the input
we've got the output and let's also
Define an INT for The Cutting progress
Max okay that's it and back here in the
editor let's go into the Tomato to
tomato slices let's say this one takes
just three Cuts then for the cheese
let's also take three cuts and for the
Cabbage let's say it's a bit thicker so
let's say it takes five cuts okay so
back in the cutting counter here down
here we are adding to our cutting
progress so we just need the recipe so
in order to grab the maximum so let's
actually go down here and actually make
a different function so this one just
returns a bullion this one a kitchen
objecto let's make another one this one
is going to return a cutting recipe so
so get the cutting recipe so with
input and we're going to receive as
usual the kitchen object so for the
input and really going to do the exact
same thing that we did up here next time
instead of returning the output let's
return the recipe itself okay so now
that we have this more logical one we
can actually get rid of all this copy
paste code so over here we just get the
cutting recipe
so and we just get it and pass in the
input so we have this one over here if
this one is not null then we're going to
return this one. output and if not we're
just going to return null okay so we're
doing the exact same one logic just a
bit simpler okay and up here pretty much
the same thing so has recipe with input
let's get the cutting recipe as so and
basally just return if this one is not
null okay so we have our three nice
helper functions so let's just use this
one to get the cutting REO so let's
actually copy this and go up here so we
do the cutting progress then let's pick
it up the one for this input so the
input is going to be this one the object
currently on the cutting counter
and over here we already know that
there's going to be a recipe with this
input since we've gone through this F so
then we can just check if the cutting
progress is bigger or equal to The
Cutting recipe so and let's grab the
maximum if so then yep we do spawn it
okay so that's it some very simple logic
Let's test so here we are let's pick up
a tomato go up there and okay now I'm
going to press the AL toct okay press
once and yep okay so far good nothing
now two times and if I press a third
time boom and yep there you go got the
nice slices now for cheese same thing
one 2 three yep it works and finally for
the Cabbage this one should be five so 1
two 3 four and five and yep there you go
everything does work perfectly all right
awesome so with this we now have
progress in our cutting logic although
of course just like this it's not very
good for the player the player has no
way of knowing what exactly is going on
so we need some kind of visual feedback
so for that let's set a really nice
visual progress bar and for doing this
we're also going to learn about a really
awesome Unity feature these are World
canvases so before we make the world
canvas on The Cutting counter let's
actually set something up over here on
the scene itself let's first create a
regular canvas we're only going to use
this in a couple of lectures but let's
first do that one just for
now so let's go on the plus button go
into UI and let's create a brand new
canvas okay so there you go that creates
a canvas and event system
now like I said we're only going to
worry about this in a little bit but for
now let's just leave those as is and
also since we're here creating some
objects let's also take some time to
organize our hierarchy Unity Sly doesn't
really have any folder objects so you
can't organize the hierarchy in any
folders however you can use empty game
objects essentially as folders so let's
make a brand new empty game object let's
call it
counters and now very importantly for
empty fer objects make sure you put them
on 0000 so nothing breaks
so make sure you put it on there before
you drag the counters and now let's just
drag all the counters inside so all the
clear counters put them all inside this
one also drag it inside and all of these
counters put them all inside so there
you go now our hierarchy is quite a bit
more clean okay so now let's make the
cutting progress so let's click on the
cutting
counter and let's go inside our prefab
so let's go inside of it now over here
let's right click on the Hier key and
we're going to create a UI let's create
another canvas
now for this one let's give it a name
let's name it the progress bar UI and
for this one over here on the inspector
for the settings instead of being screen
space overlay let's make this one a
world space canvas basically screen
space means that it would occupy the
entire screen whereas World space means
that this exists in the world in
whatever position it is so let's make it
World space and over here the fields
actually unlock so let's put the
positions all on zero and for the width
and height let's also put it on
zero so basically the canvas is going to
be exactly over here by the way the
shortcut that I just used was the F in
order to focus on the object so this
useful if you're zoomed out or zoomed in
way too much okay so we have this and we
want the bar to be a little bit above so
let's actually lift it up on the Y by a
little bit so over here let's put it on
a y of 2.5 okay now like I said the goal
with this is to make a progress bar so
inside the progress bar UI let's create
a new UI image let's name this one our
bar let's put it with the width of one
and the height maybe
of2 so there you go just a really thin
bar and for the color you can play
around tinted with any color you want
now for progress I think maybe a blue or
a yellow something like that makes sense
so let's go with a yellow kind of like
this okay so there's our really nice
progress bar and for this let's actually
use one really nice trick for making a
super easy progress bar the image
component has a really easy way of
making a sler image however it only
actually works if you assign an image
over here so let's assign one in order
to be able to see those options and for
that in the included project files
there's a texture white 1ex one this is
literally just a 1 by one white pixel so
here it is just a 1ex one image fully
white and as soon as we assign it we do
see over here the image type so we see a
bunch more options and the one that we
want is to set the Sprite as filmed this
one lets you do some really cool really
easy effects for example you can make it
radial and look at what happens in there
as I modify over here on the fill amount
so as I go down look that it's radiantly
filling so for some kind of circular
progress bar this would be excellent but
in our case what we really want is just
a horizontal bar so over here for the
film method instead of radial let's go
with horizontal and if there you go now
by playing around this we have a really
nice progress bar then if you want you
can modify left to right right to left
but yep like this it looks great now in
order to modify this visual really all
we're going to need is modify over here
the fil Mount this one is a normaliz
value so between 0 and one so Z is
completely empty one is completely full
however one issue with this is when the
bar is empty then we can pretty much not
see so we can't see the actual size of
the bar we can't see what size it should
be so with this it's pretty difficult to
see how far along we are but solving
that is pretty simple we can really just
add some kind of background so let's
duplicate the bar let's name this one
the
background for this one for the image
type we don't want anything so let's
leave it on SIMPLE and for the color
let's put it on kind of a dark dark gray
okay great and now here's one very very
important thing is over here on the Hier
key let's click and drag and place it
above the bar the reason why that is
super important is because the Sorting
order and how it works in unity
basically when it comes to UI elements
inside a canvas the Sorting order is
based on the hoard in the Hier basically
it renders from top to bottom so the bar
on top the background this is going to
render first and then the one below it
the bar is going to render afterwards
which means it's going to render on top
so for the background we want it to be
behind so place it above on the Hier and
that way it renders the background and
then renders the bar also by the way for
2D Sprites Unity has another different
sorting method it's all based on sorting
layers and sorting orders I have video
on that topic if you're interested in to
the games okay so with this we have the
background and then we have our film bar
this way we can see if the progress is
being fillmed or not also one more tiny
thing that I like to add is Unity has
some really nice really easy to add
effects so you can go going to add
component and let's search for a
shadow this one does exactly what you
expect it adds a nice drop shadow over
here on the effect distance let's put it
on 0.1.1 in order to see and actually
let's not do it on this one but do it on
the background so let's get rid of this
instead going to the background over
here let's add the same Shadow so if you
put it on 0.1 and minus .1 y there go a
nice simple drop shadow or the other one
that I prefer so inside of the Shadow
let's add a really nice outline once
again for the effect distance point
0.1.1 or maybe actually 05 just to be
just a tiny bit and let's raise it on
the alpha so there you go nice little
outline to our bar this is just a visual
thing so you don't have to add this but
personally I find that looks pretty good
so with all of this we have our visual
perfectly set up we've got our nice bar
all we need to do is play around the
fill mount in order to fill it so now
all we need to do is to connect this to
the logic but as usual let's make sure
to write some good clean code so we do
not want the cutting counter to directly
touch on this image
instead let's make a script to handle
that so let's right click create a new C
script call it the progress bar
UI and just personally as a rule I like
to append UI to any UI script you don't
have to do that it's just a rule that I
personally find helpful to follow that
way just by looking at the scripts I can
immediately see this one is a UI this
one is script logic and so on so on the
progress bar UI on the main game object
let's attach the script and let's open
it okay so now here we're going to need
a reference to our
image so let's add a serialized field
private and we're going to need the
image type and importantly this is
inside using unityengine.ui so let's go
up here using
unityengine.ui so we have our image
component okay great let's call it the
bar
image so we have our reference and now
with this obviously we need to have some
kind of reference to the counter so we
know when the progress changes so it's
really the same thing that we've already
done so many times throughout this
course so let's set a field up here
serialized field private cutting counter
for our cutting
counter then over here in the editor
let's rag the references so drag the
reference to The Cutting counter and
another one to the bar image okay great
now we just need some kind of event to
update the bar image so let's go over
here into our cutting cter script let's
make an event to spawn that so public
event let's use the event handler the
default standard let's call it on
progress
changed and let's also make a nice event
AR to be able to send the current
progress amount so let's make a public
class on progress changed event arcs and
let's extend event
arcs and then inside let's put the
current progress however let's also pass
in the progress as normalized since
that's the what the bar one will use so
public float progress
normalized and we're going to make this
event of this
type okay great so we have our event now
whenever we modify the progress we just
need to fire this event so over here
when resetting the progress let's fire
it so let's invoke pass in this intiate
our event ARs and pass in the progress
normalized and to get the normalized
progress actually very simple basically
we just need to divide the current
progress by the maximum so cutting
progress divided by cutting progress Max
which is actually inside the recipo so
we need to pick that one up so so let's
go down there to pick up the cutting
progress
recipe so we pick this one up and we go
in there and get the
maximum however over here we also need
to be very careful because there's one
sneaky issue here this has to do with
how C works and how ins are divided with
other ins for example if we had a
cutting progress of one and cutting
progress Max of five you would think one
divid by 5 would equal 0.2 however if we
actually did that over here we would
actually get a zero and the reason for
that is because we are dividing two inss
cutting progress is an INT cutting
progress Max is also an INT and if you
divide an INT by an INT then the end
result will also be an INT since you
cannot Define 0.2 in an INT the decimal
gets cut down and you end up with just
zero so that would not be correct in
order to get the right value from this
calulation we need to make sure to
convert one of these values onto a float
so that's really simple we just cast one
of them so just cast this one to the
float just like that basically now this
one will first we cast to a float and
then we're going to have a float divided
by an INT and the end result will be a
float so if you ever do some math and
you get some weird results always make
sure to check the type of your numbers
okay so here we are correctly firing the
event and then down here when adding our
progress let's do the same thing let's
also fire on the
event so now we can go back into our
progress bar UI and over here let's
listen to the event and again remember
that if we're accessing an external
reference let's do that on start and not
an awake so cutting counter listen to
the on progress changed
event when that happens let's just go
bar image and set the fill amount to
what we receive from the event so the
progress normalized okay so that's
really it and also up here on start
let's initialize it as ZF so the bar is
nice and empty okay so let's test back
in the editor let's just go back into
the scenes make sure the prefab has been
saved and let's set on play and right
away yep we do see the bar yep it is
empty now pick up some cheese drop it
and if I cut and Y there you go add a
little bit of progress now a bit more
and there you go there's our cheese okay
great everything does work now let's add
just one more tiny bonus thing we can
add some extra logic in order to hide
this visual if the bar is either
completely empty or completely full that
is actually pretty simple over here on
the progress bar UI script let's just
make some basic show and height
functions so private void show and then
we're going to have
a private void
hide on these one just game object set
active this one set it to true and this
one set it to false now on start we
subscribe to the event and then let's
hide it
okay also here it's very important make
sure you hide it after you listen to the
event if for example you called hide on
awake that would disable the game object
and the start would never run so it
would never listen to the event so if
you have set the game object as inactive
make sure you do it only after you're
listening to whatever events you want so
we have this that's great and then when
the progress changes let's just do a
basic test so if e. progress normalized
equals 0f or if the progress normalized
equals 1f so if the bar is empty or
completely full if so then let's hide it
and if not then let's show
it okay that's it let's test okay and
yep by default starts off hidden let's
pick up a tomat go up there and yep
still hidden now I cut and there you go
there it is cut again and yep there you
go it hides itself okay great so we've
got a nice little visual let's do just
one more final thing let's add a really
nice
animation if we go inside the cutting
counter and we'll look at the cutting
counter visual over here note how it
already has an animator just like we did
for the container counter it's all very
simple so basically just has a cut
parameter when that happens it just cuts
the counter so it just plays a simple
animation since it's going to be pretty
much EXA like the container counter
let's actually duplicate that script so
let's go down find that script so the
container counter visual let's duplicate
this so contrl D let's rename this to
The Cutting counter visual okay let's
open and over here let's rename the
script so the cutting counter visual
okay great then for the parameter let's
rename this instead of open close is
going to be called cut and for the
string it's cut again make sure you
write it case sensitive make sure sure
it's all correct then instead of having
a container counter we've got a cutting
counter and a cutting
counter and finally we just need to
listen to the correct event so
technically we could listen to the
onprogress changed however that one also
gets fired over here when the cutting
progress is zero we don't want the cut
anation to play when this happens so
let's just make another simple event so
a public event event handler let's call
this just on
Cut okay and then down here when we have
our cutting progress so we cut and let's
just invoke this
event okay that's it super simple so now
on The Cutting counter visual let's go
into the cutting counter and into the
uncut event let's listen to this and
we're going to set the trigger exactly
like this so get rid of the container
counter like
this okay there you go a very simple
script so now here back in the scene
view inside the container counter prefab
let's just go inside the visual let's
attach a cutting counter visual just
need to drag The Cutting counter
reference and that's it let's exit the
prefab save it and let's play okay so
now let's pick up a cabbage go up there
drop it and out interact and if there
you go we've got a nice little animation
all right awesome so I can drop things I
can cut them and everything works
perfectly all right so here we added a
cutting progress to our cutting counter
and we also learned about yet another
very useful Unity feature called World
canvases and at the at the same time you
might have also noticed that the canvas
is looking at the camera in kind of a
weird way basically just pointing
straight forward this can sometimes make
it difficult to see so let's work on
that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
build a very simple but very useful
script to make an object look straight
at the camera with various options okay
so we previously made the cutting
counter and when I play something yep
there's a nice progress bar so now that
this is working let's do one more thing
right now look at how the bar is
oriented it's looking quite a bit
slanted that's because we have a
perspective camera and it's looking from
top down now this is one of those things
that is kind of personal preference so
maybe you'll like it just like this but
a lot of the times you want these World
UI elements to face the camera just like
a regular UI one example of this problem
is for example let me pick up the
cutting counter duplicate it and let's
put one down here so rotate it
upwards okay let's put it on 4.5 0 and
minus 5 now if I place something on
there and I cut it yep look at that the
bar is Now inverted so let's make a
simple script to solve this
problem let's go into our scripts create
a new C script call it look at
camera let's go onto the cutting counter
prefab let's open it up go inside on the
progress bar let's attach this script so
the look at camera okay now let's open
so from here let's use an interesting
function so let's use a private void
late up update so not update we have
theate update so if this is the first
time you're hearing about this like name
implies this one is going to run after
the regular update so every single
update and all the objects is going to
run and then all the late updates so
kind of like you've got awake and start
you have update and late update why this
is useful specifically for this script
is because for this element you really
want this to run the orienting logic you
want that to be done after whatever that
object does in the update in this case
this object will never move so it's not
really an issue but for example if you
had some kind of moving vehicle with a
world canvas on top if you had that you
would want to set the world canvas
location to look at the camera after the
vericle had moved otherwise the canvas
would not look perfect so anyways
because that here we're doing on late
update and now we can just look straight
at the camera so we can just do
transform. look
at and for Target pass in the camera.
main.
transform this function makes this
transform look at another transform or
another point so this will make it look
straight at the camera also by the way
one quick note here in some older
tutorials you might see people telling
you not to use camera. main the reason
for that is because this field did not
used to be cached so every time you use
this it would cycle through every single
game object in the scene until it found
the main camera so that was obviously
really bad for performance but nowadays
this field is now cached by default on
the unity back end so you no longer need
to cat it yourself accessing it directly
just like this is now fine okay so with
this let's test just make sure to save
the prefab and let's set on play Let's
go ahead pick up a cabbage put it up
there and yep there you go look at that
how it's looking straight at the camera
and for this one down here same thing
cut it and yep there you go both of them
are looking straight at the camera okay
so that's great you can also see exactly
what it's doing if we try to move the
camera again we're using cinem machine
so let's move the virtual camera so over
here if I just play around with the
positionx look at that look how as I
move the camera yep the objects are
perfectly looking straight at the camera
so that's great that's what we want but
also you might notice one thing notice
how the bars are actually inverted
instead of going left to right they're
actually going right and left basically
this has to do with how the canvas by
default assumes you are essentially
going to look at it from behind instead
of looking forward so that is why when
this game object is pointing straight at
the camera it's essentially inverted so
to solve this actually quite simple we
basically just need to look in the exact
opposite direction but at the same time
sometimes we might want this exact
Behavior having something look straight
at the camera maybe we do want it to be
inverted sometimes so for that let's
make a nice complete script with all of
our possible options and for the finding
options this also an excellent way to
learn about one more thing which are C
enums enums are an enumeration meaning a
fixed set of options that you can have
of something so these are really useful
when you have a fixed set of something
like for example maybe a fixed number of
options so for example up here let's
let's make it private make it an inum
and let's call it mode and then inside
we can Define all of our options so
let's say we have the regular look at
and then look at
inverted okay so we have these two
options in our enum now let's do a field
of this type and exposed in the editor
so let's make a serialized field private
of type mode and call it
mode okay let's save this and look what
this looks like in the editor and if we
go inside the cutting counter and we
look at the progress bar
you a look at that the mode shows up and
it shows up as a really nice drop- down
menu so since we have a limited number
of options we've got a really nice menu
where we can choose each one you want so
that's really awesome that's one of the
benefits of enums they are really easy
to use over here in the
editor now back in the code here let's
decide which one to use so on The Late
update let's just do a switch on our
mode in case we are on the regular look
at mode then let's do exactly this let's
simply look at it in case we are on the
look at
inverted for this we just want to look
at the inverse position so that's
actually pretty easy we just calculate
the direction Vector from the camera to
this object so a vector 3 call it deer
from
camera and to get direction from the
camera we start from this object so this
transform. position subtract the camera.
main transform
position so this gives us the direction
pointing from the camera and then we
just do transform.
Lookout and instead of looking at the
camera let's look at the opposite
position so let's look at transform.
position so our current position plus
the direction from the camera so we're
going to be looking at the exact
opposite Point okay so that's it let's
test and right now by default we have
the regular look at so let's just see it
let's just Place some objects okay so
right now it's still
inverting and something really nice is
you can play around the inom even as the
game is running so let's go inside the
cutting counter on the progress bar UI
for this one let's SW from look at to
look at inverton any look at that that
one is now looking perfectly so this one
is using look at and this one using look
at
inverted okay great it's all working
however yet another thing that is all
about personal preference note how the
visual has a slight slant this is due to
how the visual is actually looking
directly at the center of the camera so
you can really see it if I move the
camera left and right how it Ls going
left or going right again this is all
personal preference it's just a visual
so maybe you do want this look but but
let's see another method so over here in
our modes let's add two more let's add
camera forward and Camera forward
inverted and then down here on our late
update let's add those so the camera
forward and then we have the camera
forward
inverton so for this one for the camera
forward super simple let's just say this
transform use the forward which again
you can get or you can set it and let's
set it to the exact same one as the
camera. main. transform. forward and for
the inverting exactly the same thing
except in setad of forward we do minus
forward okay so let's see what this
looks like okay so here's the game with
both counters they're both currently
using the look at mode now if I put a
look at inverting yep that one goes left
to right okay great now if I put camera
forward yep look at that now that one is
perfectly straight so even as I move the
virtual camera left and right look how
that is always perfectly facing the
camera as if it was a regular UI
element and for the inverton does the
exact same thing but invert so just like
that so that's it these are the four
modes again these are all just visual
elements so pick whatever you prefer for
me I'm going to be using this one the
camera. for so that everything is
perfectly horizontal so I'm just going
to make sure to go inside the prefab and
on the prefab itself modified and set it
as camera. for and now if I add a cheese
there yep looks great and if I add a
cabbage here and yep it also looks right
all right so here we created a really
nice useful generic script to make an
object look straight at the camera in
various ways note how this this one has
nothing to do with canvas or a progress
bar or anything it's really a generic
script to look at the camera so you can
apply this to anything where you want it
to look at the camera okay so with that
the cutting counter is fully done now
let's handle the trash counter in the
next
lecture hello and welcome I'm your code
monkey in this lecture let's create the
trash counter this one is actually
pretty simple it's how we're going to
drop something and just destroy it okay
so making the trash counter is going to
be super super easy once again going to
be another great practical example of
the power of writing good clean code and
having good organization in your project
so let's do the same thing that we've
already done a bunch of times so first
of all let's make the prefab variant so
let's right click on the base counter
and create a brand new prefab variant
call it the trash
counter okay let's go inside and first
of all let's drag the visual so find the
visual prefab on the trash counter okay
then let's duplicate it to make the
selecton so let's rename this to
selected let's add the selected counter
visual let's add the visual inside of it
and on the visual let's select the other
material so the counter selected and
finally on the selected put it 1% bigger
1.01 and start off with visual disabled
okay so that's the basics just like
we've already done so many times now
let's make the script to run this so
let's right click create new C script
script call it the trash
counter and by the way here we're
already starting to have quite a bunch
of scripts so we should probably
organize the scripts folder so let's
make a new folder let's call it
counters and let's make another one and
call it scriptable
objects so on the counters let's drag
the base counter clear counter the
container the container visual The
Cutting The Cutting visual then down
here the trash counter okay let's drag
them all onto the counters folder and on
the scriptable objects let's put the
cutting recipe and the kitchen object
ASO okay now our folder is a bit more
organized so let's open up the trash
counter and over here as usual let's
begin by extending the base counter okay
great then let's implement the regular
interaction so override the
interact and on this one again it's
going to be super simple we just check
if the player is holding something and
if so we destroy it so just check if
player that has kitchen object so if the
player is holding something go into the
player get the kitchen object the player
is holding and simply call destroy
self and that's it it's this simple back
in the editor let's just attach a script
let's make sure to drag the counter top
Point reference and on the selected drag
the base counter reference okay with
this it should be working so let's exit
the scene let's save the prefab and
let's drag it over here onto our scene
so let's drag the trash counter and put
it maybe somewhere over here on the
corner so let's put it here on an X of
seven y0 and minus
3.5 then let's also fill up these spots
down here so let's duplicate a clear
counter put one in there put another one
in there let's put another one on the
side and for the trash counter and let's
align it so let's put it a bit more to
the side so on 7.5 okay great and let's
put it inside the counters and now we
can test okay so let's see if we can
interact with it and yep as I approach
yep I do see it highlighted okay great
and if I if I interact obviously nothing
happens since the player isn't holding
anything now if I pick something up
let's say a tomato and I don't want this
tomato so I want to trash it and if
there you go it does get trashed all
right awesome so this is literally it
like I said this is once again another
excellent example of the power of
writing good clean code this was super
simple to implement because we have a
really nice structure for how all of our
Counters work also because our
interaction system is very well built
also because the kitchen object system
is very well made it's because of all of
the that great very clean code that we
were able to implement a brand new
counter in literally about 60 seconds so
once again I hope that by following this
course you know understand why I'm
always talking about the importance of
writing good clean code it's exactly
because of this if you write your code
correctly it makes developing the game
so much easier at first it might seem
like the quick and dirty approach is
faster and usually in the beginning it
is faster but as soon as you add some
complexity the quick and dirty approach
suddenly won't scale whereas the
well-built clean Cod approach this one
won't continue scaling very well so here
we have a fully functional trash bin so
we can dispose of unwanted objects next
let's build a much much more complex
counter let's build a stove counter
which also requires building a really
nice State machine so let's do that in
the next lecture hey again another quick
intermission you're past the halfway
point so congrats again by now I really
hope you've already learned a ton from
the course we've already covered lots of
topics and built a ton of systems I hope
you've been following the website as you
go through the lectures and I I hope
reading the frequently asked questions
has helped you in some way let me know
in the comments how you've used the
course website did you just read the FAQ
or did you also download some project
files let me know I'm curious to know if
you enjoy my teaching style also look at
my other courses after finishing this
one especially the turn-based strategy
course that one is an excellent followup
for this one okay there's still quite a
bit more for us to build and learn so
let's continue in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
build the stove counter so we want to
place some uncooked meat then we wait
for a bit for it to be cooked however if
we wait too much it's going to get
burned so let's Implement that all right
so as usual let's first begin by making
our counter so let's go inside the
prefabs the counters let's right click
on the base counter and create new
prefab variant call this the stove
counter and as usual let's go inside of
it let's find the visual so inside the
prefab visuals the counters visuals here
is the stove counter so let's drag it
then let's duplicate this rename this
one the selecton
let's set the component the selected
counter visual then let's go inside on
all of these and by the way this visual
actually has some nice visuals that
we're going to implement in a little bit
but for the selected we really just want
the static objects so let's pick up all
of these and let's select the counter
select visual okay nice and white then
let's lock over here the parents so I
can select all of these and drag all of
them okay great and start off with all
of them disable Okay so that's the basic
setup as usual just for the counter
point since this one has a nice little
sub on top let's lift it up by a little
bit so put it on a y of 1.
1456 okay that looks pretty good just
move it a little bit to the center okay
great so now let's make our script so
let's go inside our script folder we've
got our counter so in here let's create
a brand new C script for the stove
counter let's wait for it to compile
let's attach the script and open okay so
here as usual let's extend the base
counter now like I said the go for this
one is to be able to cook our meat and
for that it's going to be based on a
timer and to actually cook the meat
we're going to need to know which one is
the uncooked meat type and which one is
the cooked meat type so for that we
really want the exact same logic that we
did for the cutting action we want some
kind of place where we can sore an input
and output as well as a cook timer so
for that let's actually just duplicate
so let's go inside our scriptable
objects for The Cutting recipe and let's
duplicate this one so contrl D and let's
name this one the frying recipe so okay
let's go inside and over here let's
rename the object then we have an input
we have an output and then set of
progress let's have the frying timer Max
and since this one is a timer instead of
an in let's make it a float okay so
that's it pretty simple then back here
in the editor let's create our script
object so let's go inside let's make a
nice folder so a folder for the frying
recipe
so and inside let's create one so let's
create a brand new frying recipe so for
this one let's call it meat Patty
uncooked into meat Patty
cooked then for the inputs let's choose
the meat Patty uncooked now we have to
make the other one so let's go ahead and
make that one let's duplicate this one
rename it to the meat Patty
cooked and the object name meat Patty
cooked let's select the different Sprite
so this one is going to be the meat
Patty cooked okay and finally for the
prefab let's also make it so for the
meat Patty cooked let's go inside of it
and also make sure to save the changes
on our stove counter so okay now in here
let's get rid of this Visual and use the
other visual so we want the meat Patty
cooked and let's make sure to drag the
script ball object okay so it's all good
here let's go back outside save it and
finally over here on the meat Patty
cooked let's just grab the prefab
reference so there you go that one okay
so this one is working and since we're
here let's actually make the other one
right away so let's make the meat pack
Patty burned so the prefab and let's
also duplicate this to make the meat
Patty burned then on the text let's
rename this to burned let's choose the
burned icon and for the prefab let's go
into our meat Patty burned and swap it
out for the burned one so there you go
nice and Char and over here swap it for
the meat Patty burned okay let's save it
and finally down here just make sure
everything is correct so me Patty burn
just drag the SC script M object the
transform prefab just like that okay so
all of our burn references over here all
of our cooked and over here all of are
uncooked and again when going through
this process always make sure that you
match all the references on the script
objects and also over here on the
kitchen objects so meat Patty burn yep
meat Patty burn for the uncooked the
uncooked and for the cooked there it is
okay everything is good great so now we
can go back over here into our frame
recipe so and for the output let's
output the meat Patty cooked and for the
fry timer let's put it on 3 seconds okay
so that's it great now back in the code
here on the stove counter let's set an
array of our Frank recipes so a
serialized field private it's going to
be an array of frying recipe so so
frying recipe so array and call it
frying recipe so array okay great then
back here in the editor let's go inside
the stove counter let's make sure to
drag that so let's drag the meat Patty
from uncooked into cooked okay let's
also drag the counter top point and
finally since we have already made the
script over here on the selected we can
also drag the selected okay so our stove
prefab should be working okay let's go
outside make sure to save the prefab
okay now let's continue with the rest of
the script so let's make our override so
override the interact action and when we
interact with it let's validate dropping
the object just like we did on the
cutting
counter so let's go over here into our
cutting count script and let's just copy
pretty much the exact same thing so
let's copy all of this into Dr code
let's go over here in the stove counter
and just paste it now we also need to
copy in our recipe so over here on the
cutting counter let's copy paste those
functions so these functions go into the
self counter and over here let's paste
them they're going to work pretty much
the same thing so we got an input except
instead of being a cutting recipe so
we're going to have a frying recipe so
so let's replace all the cutting recipe
references with frying recipe reference
then for the array this one is a frying
recipe array and let's rename these so
control RR to rename all of them into
frying recipe so let's also rename the
function instead of get cutting recipe
so it's the frying recipe so okay so
there's no more mentions of cutting over
here so let's use this function up here
and up here and just make sure to rename
these the frying recipe
so and down here all same thing so the
frying recipe so okay so down here we
have no more mentions of any cutting
let's just go here and solve all these
problems so first we check if there's no
kitchen object here and if the player is
carrying something then we see if what
the player is carrying matches any kind
of frying recipe if so then the player
is carrying something that can be fried
then we set the parent and for now let's
not worry about the progress so let's
just get rid of all of this just like
this okay so with this we should be able
to drop but only an uncooked meat so
back in the other turn let's just set up
our scene so let's drag a stove counter
onto our scene let's put over there
there on X of 6 y of 0 and 3.5 all right
so let's test okay so now if I pick up
some cheese I go up there and I drop it
and nope doesn't work okay great but if
I pick up some uncooked meat and I go
and I drop it and yep that does work
okay great so it works and I can only
drop the actual objects that match the
recipe now unlike the cutting counter
this one will not be based on a player
alt interaction and actually over here
let's fix this minor issue basically we
added this debug. log error to the base
interact because pretty much every
single counter is going to implement
this interact function but not all
counters are going to have the interact
alternate action so this one let's just
do nothing let's not spawn an error okay
just a quick fix so like I said the
stove counter this one is going to be
based on a simple timer and for making
some time based logic basically we have
two approaches one approach is to use a
simple flow timer or you can also use a
Cod routine now a lot of tutorials will
teach you how to use a code routine
and that's not necessarily a bad
practice it does work it does achieve
desired result so to do that you would
just make a function like fry
timer so you'd make a private you have
to return I in
numerator then call it something like
handle fry
timer then inside you can do a yield
return and return a new weight for
seconds and to start this C routine you
would do maybe on start you would call
start Co
routine and start the handle fry
timer so this is one approach this is
definitely perfectly valid timer code
however personally I am not a fan of Co
routines it's not because of performance
or anything it's simply because I don't
like the pattern that they force you to
use I don't like being forced to make a
function that returns I numerator I
don't like using Guild return I don't
like having to use the start co- routine
function I don't like being forced to
use this on a monob behavior object
those are all requirements for making a
co- routine work and personally I find
those are way too many requirements that
create a very strange pattern that I
really don't like so that's really the
only reason I don't like co- routines
because I find this pattern to be quite
a lot convoluted so instead of Co
routines what I like to use are simple
basic flow timers so just make a simple
private void update then we just need to
keep track of a certain timer so for
examply simple private float frying
timer then on the update let's first
check that we have an object so has a
kitchen object if we have a kitchen
object then let's increase the timer by
time. off time by the way here when
working with a timer you can increase or
decrease it's pretty arbitrary both ways
work the obvious difference is only if
you test if it's above the max or if
it's under zero in here for frying it
does make sense to start at zero and
then the frying timer Max so you do that
and if the frying timer if it is bigger
than the maximum so let's get the frying
re so frying recip so let's get the
frying re so with input so let's get
this kitchen object and get the kitchen
object so okay so we go into the fry
recipo and we get the fry timer Max okay
so if it's above the max then this one
has been fried so here let's just see
what we did on the cutting counter so
let's get this kitchen object and tell
it to destroy itself and then let's go
into the kitchen object class in order
to spawn another kitchen object let's go
into the frying recipe and spawn the
output and we're going to spawn it
inside of this
counter all right so that's it this
should already be working we don't have
a visual yet so let's add a debug log so
up here just a debug.log on the frying
timer and up here let's also just reset
the timer so frying timer let's put it
on zerf and let's also do a debug.log
and sa Pride however like this you might
already be guessing that we're going to
have a bunch of bugs but still let's
just test it just like this okay so over
here I can move around I can pick up
some uncooked meat I can drop it there
and after a little bit there you go
there's the timers and Y there you go it
did work you can see the timer increase
until 3 then it was fried then it was
reset and then we've got a null
reference exception basically this is
the exact same problem that we had on
the cutting counter where first we put
an object like tomato and that is indeed
an input for a recipe so we cut tomato
into slices but then the slices are not
an input for any any recipe so over here
we put some uncooked meat so that's
great we fry it which means we destroy
the uncooked meat and we spawn the
cooked meat but then next time the
cooked meat is not an input for anything
so obviously this one is going to return
null one thing we can do to sort of
solve this problem which is also going
to be beneficial in terms of performance
is simply caching this field so let's go
up here Define a frying recipe ASO
frying recipe ASO instead of constantly
getting it on every single update which
might be a bit costly in terms of
performance instead of this let's just
get it over here when the player drops
something so the player drops something
and we assign the Frank recipo so we
assign it cach the value and then do
this okay that should have fixed the non
reference problem but we still have a
bunch more problems but still Let's test
it out okay so here let's pick up some
meat put it there and let's look at the
timer and yep there you go everything is
cooking great and yep there you go it
finished it cooked and the timer was
reset and now it's finishing it's
cooking and so on so this is obviously
another Prett serious problem basically
it's constantly frying the meat and
spawning more and more objects instead
of constantly spawning from the same
recipe what we want is for the stove to
First fry the object but then if the
object is fried then we want to burn it
so really that means that we want the
stove to have multiple States meaning
that we're going to need to make a
simple State machine so let's do just
that now if you're a beginner the
concept of a state machine might seem
daunting at first but it's actually
extremely simple at least to make a very
basic one all we need is really just a
bunch of States so to define those
States let's go up here and make a
simple enum so let's make a private enum
call it
State and now let's put all the states
for our state machine now for the S
let's say we have idle when there's
nothing on top then let's say we have a
frying state for when the ingredients is
actually being fried then we have fried
for when the ingredient has already been
cooked but it's still getting some heat
and finally if we leave it too long in
that state then everything ends up
burned okay so these are all of our
states for our state machine and now to
make the State machine it's actually
quite simple first of all we just need
to store the current state so up here
make a private of type State and store
the current state and then on update
let's just do a switch on the current
state and now here basically we're going
to do different logic depending on the
state that we're at so let's say if
we're idle we do something then if we
are frying we're going to do something
else then if we are on the fry also
something else and finally if we are on
Burn do something else so here are all
of our States and the logic that we did
down here this is the Frank logic so
let's actually just copy all this and
let's paste it inside the Frank logic
and for the state machine we're only
going to run any of these states if
there's a kitchen object inside of it so
let's actually put that switch in there
just like this okay so that's it so when
idle we're not doing anything and when
frying we're going to run our frying
timer we're going to fry the object
let's also get rid of the log we no
longer need this then we destroy the
current object and we spawn a brand new
object now what we need is to handle
over here the State field we need to
modify this when changing states so
first of all let's handle the start so
let's make a private void
start and on start let's begin with the
state on state. idle okay great then
down here when we interact when the
player drops something when the player
drops something that can be fried over
here let's set the state and put it on
state. frying and over here we should
also probably reset the timer so let's
set the frying timer back into zerf okay
we the timer and we reset the state
finally up here let's not reset the
timer since we're resetting the timer
down there since it makes more sense
down there so we do the frying the
frying timer we end up frying and then
obviously we need to modify the state so
modify State and put it on state. Fry
okay so that's the basics of our saate
machine with this everything should be
working just the same as previously
except we're only going to fry once so
let's actually just put a log here debug
on log object
fried and let's put one down here
outside of the state machine just do a
debug. log on the
state okay like this let's test okay so
here we are let's pick up some meat and
drop it on there and there you go goes
from idle directly into frying and then
it's fried and yep there you go now it
stays on fried so it no longer goes on
frying and it's no longer spawning any
more objects it went from frying into
fried and yep everything worked all
right awesome so we have the fry State
working perfectly now let's handle the
the burning in terms of logic it's
really going to be the exact same thing
we're going to have a frying timer so
let's copy this code and paste it down
here now technically we could reuse the
exact same float timer but that would be
a bit confusing so let's keep our code
as clear as possible and really just
make a different timer with a more
descriptive name so here a private float
call it the burning
timer then let's initialize this timer
so when we go into the Fright State
let's set the timer the burning timer
into to zero then down here let's use
this Burning timer okay great when timer
is left and the object is spawn let's go
into the burn Sate and obviously we need
another recipe so let's make another
scriptable object back in the editor
let's find the frying recipe so let's
duplicate this call it the burning
recipe so then over here let's modify
the name instead of frying timer Max
let's call it burning timer Max okay
great so now over here on the stove
let's use pretty much the exact same
thing and let's make over here private
of burning recipe so the burning recipe
so then down here we just need a
function to get the burning recipe so so
let's copy this and paste it over here
this one is going to return a burning
recipe so so let's replace this and this
rename this into burning recipe so we're
going to need an array and over here
let's just change the name instead of
frying recip so the burning recipe
so and finally let's just find a new
array so let's go all the way up here
make another array an array of burning
recipe so and this is the burning recipe
so array and finally if we go down here
let's use this array okay that's it so
now let's use this function to set our
burning recipo so when we set it to find
let's set the burning recipe so and
let's get it with the input and the
input is going to be the object that is
on here so the kitchen object. get the
kitchen object as
so okay so we're initializing our fright
State and setting up the burning rest PS
so and over here we use that one Max and
we go into that one and use the output
so over there object fried and over here
object burned all right so that's pretty
much it we modified everything to say
burning timer over here we are correctly
initializing so we go through the
burning timer through the burning rest
PSO which we are grabing up here then we
spawn the output on the burning rest PSO
and we go into state. burn okay so all
that's left is just filling in this
array so back the editor over here let's
make the object so let's make a brand
new folder for the burning recipe so and
now inside let's create a new Burning
recipe so call this one the meat Patty
cooked into meat Patty burned and over
here let's set the input so the meat
Patty cooked onto the meat Patty burned
and for timer let's make it take a bit
longer to burn so let's say 5 Seconds
okay that's great let's just drag the
reference so let's go into the stove
counter and let's make sure to open up
and get go inside the prefab and over
here on the prefab just drag the burning
recipe okay that's great let's go
outside save the prefab and let's test
all right so here we are let's pick up
some meat drop it on there and look over
there it's frying and after a bit yep
it's fried there you go it's spawned
that one and now if we wait for 5
seconds it should go from frying into
burn and yep there you go that one is
charred everything is burned everything
is great all right awesome so everything
worked as intended with this all of our
logic is working now let's handle
picking up objects from the stove now
technically it's already working so I
can approach the so and pick it up the
object and there you go drop it in there
so that does work however if we look
over here in log the state machine is
now in the wrong state so over here
let's do a quick fix let's go down into
the interact action okay so here it is
so if there's no kitchen object then the
player places it okay that's good but if
there is a kitchen object so if there's
something on the stove counter when the
player picks it up let's also manually
set the state and put the state back
into idle just like this okay that's it
so let's test okay so over here let's
pick up some meat put it in there it's
cooking and let's wait until it gets
finished yep there you go it's done pick
it up and there you go out now if I want
I can put another one and yep there you
go the logic is reset and everything is
back to normal okay great so all the
logic is working perfectly now let's
just get rid of our log so we don't need
this so let's get rid of that debug log
this one and this one okay great
everything is nice and clean and now
let's add some nice fun visuals so if we
go inside the stove counter and over
here is the visual and I include these
two prefabs inside the visual so one of
them this one the stove on visual this
one is just a glowing red square now
again there's a weird bug on this
specific un version so post procing
isn't showing over here on scene view
but if I leave it enabled and I go back
outside and now if we look in the game
view yep there you go there's a nice
glowing red square if you don't see
glowing make sure you add the bloom post
rossing effect so if you missed
something you can go back into the
postprocessing lecture and make sure
everything is set up correctly so
there's a nice glowing red square and
there's also a bunch of particles so you
can enable this one press on restart and
there you go just some nice particles
just jumping up this was made with the
unity particle system so for example on
the Hier key you can right click go up
here into effects and you can create a
particle system so that's what this is
it has a particle system over here you
can see all of the various settings for
these particles they just jump up and
fall down so for jumping up that is the
emission you can actually see a visual
over there of the cone that is the
spawning cone which you can find over
here on the shape so in the shape it has
the shape of a cone then you can see the
radius radius thickness and so on so
that is from where the objects are being
spawned then up here you can see the
lifetime of each object so each particle
is going to last for 7 Seconds you can
also see the speed so that's speed at
which they come from there the start
size that's how big they are on start
and note how the particles are spawning
jumping up and and falling down so that
Falling Down is over here the gravity
modifier if you put it at zero then they
just keep going up and if you put at two
yep they go up and they fall down next
down here on the emission this is how
many are being spawned so if I put this
on 200 there you go tons and tons of
particles next is over here the size
over lifetime so this one has just a
basic curve so they start off on full
size and over the x-axis this one is the
lifetime so as the particle goes from
the beginning until the end of their
life they basically go down on size so
that is why they become quite a bit
smaller also by the way this window down
here this one is called an animation
curve this is another really useful
Unity feature I have a dedicated video
on animation curves and finally down
here just have the renderer so we're
just using some basic particles so we
can inspect the material it's including
the assets and there you go we're just
using the default particle material just
with the alpha on half and that's pretty
much it so as you can see just a very
basic very simple particle system now
all we really want to do is just for
both of these we want to enable or
disable them depending on if the stove
is on or not so let's make a script to
handle the visuals so let's go down and
create a brand new C script let's call
it the stove counter visual then let's
go into the stove counter Visual and
let's attach the script so here it is
attach it and open all right so now here
we just need references to those two
objects so as usual let's make a basic
serialized field let's make it of type
game object for the stove on game object
and the other one is the particles game
object okay let's save and back here in
the editor let's rag the references so
the stove on Visual and the sizzling
particles okay great so now all you
really need to know is know when to turn
these on or off and for that is really
going to be based on the state over here
on the stove counter so if it is on the
state frying or fry then we want to show
them if it is on idle or burned we want
to hide them but as usual we don't want
to mix the logic and visuals directly so
let's do that through a really nice
event let's make a public event let's
use a standard event handler let's call
it on state
changed and let's also include the state
on the event arcs so let's make a public
class call it on state change event arcs
and let's expand event ARs and then in
here let's just put a public state for
our state however here we also have a
really nice error so this one is telling
you there's inconsistent accessibility
basically that's because we made this
one public so any class like for example
our visual class can indeed see this
class however from outside that class
cannot see the private state so that is
why we have inconsistent accessibility
we cannot have something public which
inside has something of a specific type
which is private so in order to make
this work we need to modify this state
and make it public so that the other
classes can see it okay so that's great
now let's just fire this event whenever
the state changes so over here when you
go into the frying State let's go and
and invoke and as usual just
this and I actually forgot to add that
so let's go up here let's use the one
with generics so the on state change
event arcs okay great so then down here
when invoke the event let's create of
this type and inside passing the state
equals this state okay so this all we
need so then down here going into the
burn State let's fire the event and down
here frying fired the event and on idle
fr the event all right that's it so we
have all our state logic and over here
on the stove counter visual obviously we
need a reference to the counter so let's
add that so A serialized field private
make it up type stove counter for the
stove counter and then we can do and as
usual for accessing external references
let's do it on start go into the stove
counter and let's listen to the on state
changed
event and over here it's going to be
very simple we just want to show if it's
on the state frying or fried and if not
we don't want to show so let's define a
B call it show Visual and this one is
going to true if the e. State equals the
state. fry or e. State equals D state.
frde so if it's out of these and this
going to be true if not it's going to be
false so then let's just go into the
stove on game object and call sent
active and pass in this and same thing
for the other for the particles game
object okay that's it super simple let's
just drag this reference so over here
inside the prefab just drag the
reference let's leave the prefab save
the changes and let's set on play and
all right so it starts off disable Okay
so there's no visual now if I pick up
and I drop it and there you go a nice
visual so the glowing red hot and the
particles and now it's frying and if I
leave it until it burns when it burns
then it's going to turn it off and there
you go it turns off all right awesome so
now if I pick it up wait until it gets
cooked so it's cook pick it up and there
you go turns it off all right awesome
we've got a really nice visual all
that's left is to have a proper visual
progress bar and with this we actually
have another interesting clean code
question right now the progress bar that
we made over here on the cutting counter
that one is great so we would like to
reuse that however if we look over here
on the progress bar UI we can see this
is only working with the specific type
cutting counter so by default this will
not work with a stove counter so as
usual we have multiple approaches to
solving this problem one option would be
to Simply complely duplicate the script
then we would make a completely
different progress bar UI class that
would work only with the Ste counter so
that's one approach that would work and
that approach might be good if you want
the progress bar to behave very very
differently but over here I want both
them to behave exactly the same so
instead of having some code duplication
we can write some good clean code but
doing exactly what we did with regards
to the kitchen object parent meaning we
can use a nice interface we can then
Implement on anything that has some kind
of progress so let's do exactly that
first of all let's actually go inside
the cutting counter so let's go inside
the prefab and over here we've got the
progress bar and this one is just a
regular game object but since we're
going to reuse this let's make this a
proper prefab so let's find over here
all of our prefabs and just drag the
progress bar UI inside the prefabs
folder okay great so this is now a
proper prefab now let's define our
interface so let's create a brand new C
script as usual interface start with I
so let's call it I and for this one we
wanted to represent anything that has
progress so let's just call it literally
has progress personally I like to use
the word has to indicate that a certain
object has certain Behavior so in this
case objects that implement this
interface will have some kind of
progress Behavior so now over here for
the interface let's first make it so
this one does not extend mod of behavior
instead of a class this one is an
interface okay great so now for the
functions that we're going to need if
we'll look in the progress bar and we'll
look at the cutting counter references
we can see the only one is literally
just this so we just have to listen to
the event and then the rest of progress
bar Works inside of it so real the
interface is the only thing we need to
Define so let's actually go inside the
cutting counter so here we have the on
progress change event and then we have
this so we can literally just copy this
go into the I has progress and let's put
exactly this okay that's it that is
literally all we need now if we wanted
we could also make a function to expose
the progress amount but since we
included over here on the event then we
really don't need it just this is enough
now let's go over here on the progress
bar UI script and instead of working
with the type cutting counter instead
let's work with a type that has I has
progress so let's rename this to has
progress and it's going to have the
exact same event the only difference is
over here instead of the event RX being
the one inside the cutting counter is
the one inside the I has progress so
let's make sure to change this I has
progress okay so the signature matches
let's just obviously rename this so
let's rename instead of cutting counter
let's rename has progress on progress
changed and that's pretty much it we
don't have any more errors so everything
over here is now working nicely with our
interface and back here in the editor
once we're still inside the cutting
counter suddenly interfaces do have one
downside when it comes to Unity if we
look in the progress bar UI down there
we can see the progress bar UI and
previously we had the counter field
exposed in the editor however now by
changing into an interface there we have
the issue the field does not show up
here interfaces do not show up in the
editor because Unity basically has no
way of knowing that the interface will
be implemented by some kind of game
object so sadly this is the one thing
that doesn't work very well with unity
the solution that I normally do is
actually pretty simple instead of
exposing the interface which does not
work instead let's just make this a
regular private field and then let's
make a serialized field and for this one
let's make it of type game object and
let's call it has progress game
object okay so like this we have a
regular serialized field with a regular
game object so if you look here yep we
do have that field so now we can indeed
Drag The Cutting counter reference and
then over here in the code in order to
get the has progress that is super
simple has progress we just go into the
has progress game object and get
component of type I has progress okay so
that's it now our code does work however
of course one big potential issue with
this is that over here we have a field
of type game object meaning that we have
no guarantee that this field does have a
component that implements the interface
so we cannot make sure that we drag the
correct reference we can drag any
reference doesn't have to have our
progress interface so in order to keep
ourselves safe let's add a nice safety
warning so over here if has progress
equals null so if this one is n that
means that that game object does not
have any progress interface if so let's
do a debug.log
error and let's say the game object and
let's pass in this game
object does not have a component that
implements I has
progress so this way if we make a
mistake we will have a nice error
message basically this is the one
workaround that you need to use since
city does not support dragging
references in the editor if they are
interface references okay so with that
everything is good so all of our
progress bar UI this should all be
working perfectly we just need to go
over here into our cutting cter script
and let's make it so that we Implement
our interface so I has progress and we
got an error just because even though we
did Define that interface member the on
progress change again keep in mind that
the the types depend on not just their
name but where they're at so this type
that we have here is the one that we
Define here which is not the same one
that we have here so even though they
have the exact same name because they
are in different places they are
actually different types so we need to
make sure to use the type in the
interface over here let's just go into
the I has progress and use that exact
type and get rid of this one okay so
that's it that's the change we need and
down here when firing let's just fire
with that type and down here the same
thing with that type okay great so like
this The Cutting counter should still be
working exactly the same as previously
again when refactoring any code always
do a quick test so let's do that let's
make sure to save our counter save the
prefab go back outside hit on play now
let's pick up some cheese put it there
cut and there you go the progress bar
still does work okay great now let's
apply to the stove and that is actually
going to be very simple first let's go
inside the stove so let's find the stove
counter let's open it up go inside the
prefab and over here let's drag the
progress bar UI prefab so let's drag
that then down here we already has the
has progress game object so let's drag
the stove counter and that's it there's
nothing else we need to touch here we
just need to go over here into the stove
counter and it's usual let's implement
the interface so the I has progress and
now let's implement it pretty much just
like we did on the cutting counter so we
can actually just copy this so we just
need to implement the event so that's it
and now for firing the event let's go
down and see where we are modifying all
our timers so let's go down to when the
player drops something so we do the
onite change and now now let's invoke
this event so this and for the progress
bar for the progress normalize this one
is very simple so just frying timer
divided by the frying
recipo do frying timer Max okay that's
it we are modifying the progress now
let's go up here when we are in the
frying State and when we do let's fire
off the on progress change event okay
great and finally down here when we have
the FR over here let's also fire except
obviously we have the burning timer and
and the burning timer Max and then just
to make sure that the bar actually hides
itself when we go into burn let's also
fire an event this one doesn't have a
timer so let's just put it on zerf okay
that's really it we don't need to touch
the progress bar UI at all Let's test
this just make sure to save the prefab
let's go back outside and head on play
and right away yep the bar is inde need
hidden now if I pick up some meat and I
drop it and there you go got a really
nice bar going up and yep going up on
the burning State and as it gets to the
end let's see if the bar hides so it
gets to the end and if there you go the
bar does hide all right awesome and if I
pick up something actually this was the
one event that we forgot so let's fix
that so let's just copy the one where we
set the progress normalize to zero and
over here if the player picks up
something let's set the progress back
into zero so here we are let's pick up
some meat drop it on there okay let's
wait for it to be cooked okay it's
cooked now before it burns pick it up
and there you go the bar is gone all
right awesome okay so here we have again
another example of the power of writing
good clean code we made a nice generic
progress bar and we very easily made it
work with a completely different counter
which of course would also work with
literally anything that implements that
interface doesn't have to be a counter
now let me make one note here basically
I showed you how to make a generic
progress bar and reuse it but let's say
you want to do something specific just
for the so well one approach like I
mentioned is to duplicate the code and
make a progress bar that works only with
stove but another approach is to Simply
add more elements on top for example
during the Polish stage we're going to
do exactly that we're going to add an
extra UI element that will show up to
warn the player when the food is about
to burn so I just wanted to point that
out how you can mix and match both them
you can have both generic components
coupled with specific components but for
now our progress bar everything is
looking pretty good so let's leave that
burden warning just for the poly stage
now the next very important thing we
need is some plates so let's do that in
the next lecture hello and welcome I'm
your Cod
in this lecture we're going to create
the plates counter this one is just
going to spawn some plates which we can
then pick up to grab some objects okay
so let's begin making the counter as
usual so let's go inside our prefabs
inside our counters right click the base
counter make a new prefab variant called
the plates counter let's go inside and
let's drag the visual for the plates
counter let's go into scene view so we
can see it okay let's duplicate this
make this the selected let's go inside
side and we can actually hide the cirle
Sprite we only need this one so on this
one let's modify it for the counter
selected on the selected let's make it
just 1% bigger and let's add the
selected counter visual okay then inside
obviously drag the reference for the
kitchen counter okay that's our basic
setup now let's make our script to run
this so let's create a brand new C
script for the plates counter let's
attach the scrip to the plates counter
and open okay now here as usual let's
extend our base counter and then first
let's handle the spawn timer logic so
basically we want to spawn some plates
every once amount of time so let's s a
simple float for the spawn plate timer
then let's make a simple update on timer
let's increase SP Point timer by time.
Delta
time and then just check if it's above a
certain
maximum so if it is above something in
this case we're going to have a fixed
value but still like I mentioned in the
very beginning of this course let us not
use magic numbers here you should never
use magic numbers instead if you wanted
to make it editable you could also make
it appear as a serialized field but in
my case for design that I'm going for
I'm perf content with having a fixed
value so just appear pretty simple the
spawn plate timer Max and let's defa it
to
forf and let's use it over here okay
great so this what we want however for
spawning it's actually going to be a bit
tricky the the plate is supposed to be a
kitchen object the player should be able
to carry the plate and right now for
design that we Define is that each
kitchen object can only have one parent
and each parent can only have one object
but over here we want to spawn multiple
objects now let's quickly see what
happens if we try spawning multiple as
usual so let's just go into the kitchen
object spawn a kitchen object which
means we need the plate so so let's do
it up here as usual a serialized fi
private kitchen objecto for the plate
kitchen object
so so we're going to need to make this
and then we're just going to spawn this
object on
this okay so this is going to throw an
error but still let's see let's first
create the object over here let's go
inside our script M objects our kitchen
objects let's create the brand new
kitchen object call it just the plate
for the object name this one is a plate
for the Sprite let's go with the plate
Sprite and for the prefab let's make it
so let's see duplicate one of these call
it the
plate let's go inside it and obviously
make sure to change save the changes
then over here let's drag the plate
visual get rid the tomato and on the
plate let's make sure to assign the
plate and finally let's exit this let's
make sure to save it and on the plate
let's drag the plate prefab okay so we
have the kitchen object ASO now let's
just go inside our plates counter and
over here let's drag the reference so
the reference to the plate kitchen
object let's also drag the reference to
the counter top point then on the
selected drag the reference to our base
counter and finally start off with the
selected disabled okay so this should be
working let's just add a plate counter
over here onto our scene so let's pick
up a plates counter and put it somewhere
in here over there on the side so on an
X of 7.5 then zero and let's say on zero
maybe let's make sure we have space for
one more counter over there so let's
duplicate this empty counter and let's
put it over there pointing to the side
so this one is on 7.5 0 and minus
2 okay so now let's just make sure that
they perfectly match so let's put this
one on a set of
minus5 okay so let's test all right so
here we are and look at that and after 4
seconds yep there you go it spawns the
object and then it immediately tried to
spawn another one and there you go we
have the error kitchen object parent
already has a kitchen object basically
the way we designed our game and set up
the code assumes that a single counter
will only hold a single kitchen object
so we cannot have multiple plates on the
same counter now one solution for this
problem is actually quite simple when we
spawn the plates instead let's not spawn
a kitchen object instead we're just
going to spawn a dumb visual then when
the player interacts with the counter
that is when we're going to spawn the
proper kitchen object so let's do that
although again let's keep the logic and
the visual separate so over here let's
first just handle the logic so we just
need to keep track of how many plates we
spawn so for that let's sort up here a
private t for the plates spawn amount
and let's also do another private in for
the plates spawn amount
Max and let's say we can spawn at most
four plates okay so over here instead of
spawning the object let's first of all
actually reset the timer so let's put it
back to 0 0 and on the plate spawn
amount let's check if this one is under
the plate spawn
Max and if so
let's go into the plate spawn amount and
increase it by one okay so that's a
logic super simple now let's send the
visual so let's first make our script so
let's create a brand new C script for
the plates counter
visual now let's make sure to the visual
so let's go inside the prefab and over
here we've got the visual let's attach
it okay open now here basically the
first thing we need is we need to know
where to spawn the visuals so let's
actually add a reference to our counter
top point so let's add a serialized
field for private transform for the
countertop point then let's also add a
reference for the prefab we're going to
spawn so let's call it the plate visual
prefab then here in the editor let's rag
the references so the counter top Point
Place it in there and for the plate
visual prefab let's go up here and find
the visuals for the kitchen object so
these are just the visuals and let's rag
the plate visual so the plate visual not
the plate citch an object okay now back
in the code here we obviously need to
know when it plate is spawned so let's
go into the plates counter and make a
nice event so public event event handler
as usual on Plat
spawn and down here let's just fire the
event so we just
invoke with this and event.
empty okay that's it very simple and
then on the other script over here let's
just listen to it which also means that
we need a reference to our counter so
let's add up here the plates counter for
the ples counter so we're going to need
to drag the reference and then on start
let's listen to the on plate spawn event
and when that happens then let's Spa so
let's call instantiate on the plate
visual prefab let's put it inside the
counter top point so this the transform
for the plate visual transform and
that's pretty much it okay so like this
it should be working when the plate is
spawned we should be spawning a brand
new visual back in the editor we just
need to drag the plates counter
reference like that
let's exit save the prefab and let's
test okay so here we are and if we wait
for 4 seconds we should be able to see a
PL spot yep there you go and if we wait
for a little bit more we should also be
able to see some more plates being spawn
except we can't really see them that's
because we're spawning them on the exact
same spot every time but if we pause the
game and over here look in the Hier key
and find the plates counter and inside
the counter top Point yep we do have
four visions and if we wait for longer
then nope it's not going to spawn
anymore it's only going to spawn four
plates okay great so to solve the vision
let's just offset them by a tiny bit to
know how much we should offset let's
keep track of how many plates haven't
spawned so let's store up here on the
visual script a list of Game object call
it the plate visual game object
list let's also make sure to initialize
this so let's do on awake let's
initialize this list and then when we
spawn them okay so here we have the
object that we spawned now basally we
just need to modify the local
position and let's put it on new Vector
3 on the X let's put it on zero then on
the Zed we're also going to have zero
and then over here on the while let's
offset it by a certain amount and
basically it's going to be based on how
many plates have been spawned so let's
define up here a float for the plate
offset y let's put it at say
0.1f and over here we're going to offset
it by this much multiplied by how many
plates have been spawned so we can go
into our visual list. count so you can
do like this and then we just need to
add it to the list so let's add this
plate visual transform. game object okay
so now each game object should spawn at
a different height so let's see so here
we are and if we wait for 4 seconds we
should be able to see a plate and there
you go and now after 4 seconds we should
be able to see another one place
slightly above and yep there it is okay
great so everything is spawning
perfectly both in the logic as well as
the visual now let's actually pick up a
plate so on the plates counter as usual
let's implement the interact
so let's do a public let's override the
interact function and now for picking up
let's first see if the player is
actually
empty-handed so if and we check the
player has kitchen object so if the
player does not have a kitchen
object then the player is empty-handed
okay great then let's see if we have a
plate that we can give them so if the
plate spawn amount if it is bigger than
zero then there's at least one plate
here and if so let's give it to the
player so how we do that is well over
here for the logic let's just increase
it by one then let's actually spawn the
object so on the kitchen object let's
spawn the Plate Kitchen object so and
spawn it on the player and finally we
just need to update the visuals so let's
make another event so up here on PL
spawn and on plate
removed okay we have this event and then
down here let's just whenever the player
picks it up let's invoke this with this
in event
arsmt okay great so now on the visual
let's listen to this so over here on
start for the plates counter listen to
this event and when this event happens
we just want to destroy the VAR last
plate so let's grab the game object for
the plate game object and we're
basically just going to go into our list
so the plate visual game object list and
let's pick up the very last one so let's
go into the list. count minus is one so
this is going to be the very last
element of the list then let's remove
this one from the list so plate. remove
this one that we just grabbed and then
we simply call destroy on this
one all right so that's it super simple
so we on the plates counter we do all of
our checks we cut it down by one we
spawn the actual kitchen object and we
fire the event and over here the event
listens and updates the visual okay
let's test so here we are let's wait for
a plate to be spawned and when it
spawned there it is I'm going to pick it
up and Y there you go the player is now
carrying a plate let's drop it here and
there you go there's another one now
let's wait for a bunch more to be
spawned okay so the plat counter is full
now if I pick up it should only
eliminate the last visual pick it up and
yep there you go it eliminate that one
now I can drop it in there and Y there
you go another in onean all right
awesome okay so that's really it for the
basics of the plate counter it
periodically spawns some plates which
the player can then pick up now in the
next lecture we're going to add the
ability for the player to be holding a
plate and pick up another object onto
the plate
hello and welcome I'm your Cod monkey in
this lecture we're going to add the
ability for the player to be carrying a
plate and pick up objects onto that
plate okay so here we already have the
plate counter working it has some basic
logic after a bunch of time it spawns a
plate it spawns up to a certain maximum
and I can pick up a plate and yep the
player is carrying a plate so I can put
it anywhere then I can for example pick
up some Tomatoes slice them and pick
them up however now I am not able to
place the tomatoes on the plate so let's
add that logic let's begin over here on
the clear counter script first we're
testing if there's no catching object
here and the player is carrying
something that the player drops
something in there but then we're
testing if there is a kitchen object
here and if the player is carrying
something so it's over here that we want
to check if this something that the
player is carrying if it is a plate now
our plate is also going to have a bit of
custom logic so to help both identify
and hold that custom logic let's make a
proper script to handle it so back in
unity let's create a brand new script
script call it the Plate Kitchen object
and let's open this now over here on
this one instead of extending mono
Behavior we're going to extend kitchen
object so the plate is really just a
more specific type of a kitchen object
again like I mentioned quite a while ago
you want to be very careful with
inheritance you need to have a very good
reason to do it here we want the play to
behave exactly like a kitchen object
just with a tiny bit of extra logic so
in this case it makes perfect sense
let's just go ahead and save this and
wait for un to compile and over here
let's find our kitchen object with the
plate so here there's a pream as you can
see we have a kitchen object now instead
of having that one let's replace that
with the Plate Kitchen object and since
we are extending kitchen object we have
the same Fields so let's make sure to
add the kitchen object as so and get rid
of the other one okay great so now back
here on the clear counter when there is
a kitchen object here and the player is
carrying something we can check if the
player is holding a plate and for that
we can check the type
so if let's go into the player and let's
get the kitchen object the player is
holding and we test if this object is of
type Plate Kitchen
object if so then that means player is
holding a plate and if that is the case
then we basically want to give the
player whatever object is over here we
want to add it to the plate so let's go
into the plate script to add that
function so over here let's make a
public void let's call it add
ingredient and as a parameter we're
going to receive a kitchen object so so
we really only care about the type we're
going to destroy the actual kitchen
object like we've been doing when
creating different types so the plate is
really just going to store a list of
types so up here let's store a list of
kitchen object so for the kitchen object
so
list then when we add the ingredient
let's just add it to the list so this
kitchen object so let's also make sure
to initialize list so let's do it on
awake let's initialize our list and now
from the other side we just need to call
this so over here on the clear counter
if the player is holding a plate let's
first get the type of plate so Plate
Kitchen object or the Plate Kitchen
object we go into the player to get the
kitchen object and we cast this as a
plate kitchen object okay so we have
this and then over here let's call add
ingredient and let's add whatever is
currently on this counter so let's get
the kitchen object and get the kitchen
object as so okay so we're adding it to
the plate and then let's destroy what is
here so get kitchen object and destroy
itself okay so that's it so if there is
something here and if the player is
holding something and that's something
the player is holding is a plate if so
we're going to add that ingredient to
the plate and then destroy the object in
here so let's test okay so here let's
pick up a tomato let's slice it let's
put it on a clear kitchen counter
because that's the only one where we
added the logic so on this one let's
pick up a plate and now once I'm
carrying the plate and if I approach and
I interact with it and Y there you go it
does work the object vanished from the
counter and supposedly was added to the
plate again we can use a really nice
debug inspector to see it so let's pause
the game Let's select the plate let's
see the Plate Kitchen object so here it
is this one and let's change the
inspector into debug mode and down here
yep we do see the kitchen object that's
on list and it does have some tomato
slices okay awesome so with this here we
have our Basics we can have some
ingredient and we can basically pick it
up from a plate now one thing about our
plate this is where we're basically
going to carry the final recipe that
we're going to deliver to the customers
and based on the design that I defined I
want something pretty simple meaning for
design that I'm going for there won't be
any kind of double burgers or double
cheese so each final recipe will only
have at most one of each ingredient so
let's add some basic logic just to
prevent adding duplicates over here on
the Plate Kitchen object when we add an
ingredient since the function will now
not necessarily succeed every time let's
actually rename this and again use a
very useful Visual Studio shortcut so
again press control RR or right click
and let's rename since this function
will no longer succeed we're just going
to try to add an ingredient so try add
ingredient and then let's also make it
return a b basically for any function
where you're not sure if it will succeed
I like to add try and make it return B
so this way works pretty much exactly
like the Trion component that we've
already seen so many times so it tries
to do something and returns whether it
succeeds or not so over here instead of
always adding the ingredient let's see
if this one is a duplicate so let's do
an if and let's go into the list and
check if the contains and if the list
already contains this kitchen object as
so if though then already has this type
so let's return false and if
not then that means this is a brand new
ingredient so let's add it and return
true okay so that's it now let's go over
here onto the clear counter so we try to
add the ingredient but then we only want
to destroy if this one succeed so let's
put this one inside an if so if we do
manage to add the ingredient then yes
let's destroy itself if not then we
don't destroy anything okay so let's
test so let's go ahead and slice two
tomatoes so one slice it put it here
then another one slice it and put it
here now let's pick up a plate go up
here try to pick up this one and yep it
does work now for this one and nope it
doesn't work okay great now one more
thing in our logic we only want to pick
up certain things like I said only
things that won't be used in the final
recipe for example no customer is ever
going to request a full entire tomato
the recipes only have sliced tomatoes so
we should not be able to drop a full
tomato directly on top of a plate so
let's change that so over here on the
plate script let's basically just create
a list of our valid
ingredients so let's make a serialized
field private make it a list of kitchen
objecto and call it the valid kitchen
objecto list okay so we have this list
and over here in the editor let's just
drag the ones that we want so let's
first of all select the plate object
okay here is the plate pream and over
here we've got all of our kitchen
objects so let's just rag the ones that
we want to add to the plate so the final
recipes will have some bread yep but
they will not have entire cabbages they
will only have cabbage slices same thing
no cheese only slices for the meat we're
only going to be able to add meat cooked
but also meat burned then we're not
going to be able to add a plate onto a
plate of course not and finally inside
of a tomato just tomato slices okay
that's our valid list and over here
again it's very simple so we can just go
if the valid kitchen object is a list if
this one contains the one that we want
to add then we can add it but if not
then let's return false not a valid
ingredient okay so let's test all right
so let's pick up a tomato and also some
tomato slices and now if I pick up a
plate and I go into the Tomato nope
doesn't work but the slices yep it does
work okay great so here we have all of
our basic plate rules everything is
working perfectly but it's only working
over here with the clear counter so
let's do a little bit of code cleanup
and then let's add this logic to all the
other counters so first to clean up this
code over here we are testing if this is
a plate kitchen object then we cast to
an object and then we call the function
so let's simplify all this and let's do
it just like un does with their triy get
component function so let's make a
custom function that takes an output
parameter best place to put it is on the
kitchen object so here we've got the
kitchen object script okay great let's
scroll down and making nice function
here so let's make a public we're going
to return bullion in case this succeeds
or not let's call it try get plate and
over here let's make an out parameter so
don't forget the out keyword let's
return of type Plate Kitchen object for
the Plate Kitchen object and over here
we do exactly what we did so we test if
this object is a plate kitchen
object if so then let's set the Plate
Kitchen object equals this as a plate
kitchen object and we return true but if
not then this is not a plate so let's
return false and one thing when working
with output parameters you always need
to make sure to set the output before
you exit the function so over here
that's the error that it's telling us we
must assign it to something when we
return so over here we don't have a
plate citchen object so to solve this we
just set this to null okay great now
over here on the clear counter instead
of doing all this basically let's ask
the player if this is a kitchen object
so let's try to get the plate
out Plate Kitchen object for the Plate
Kitchen
object so you try to get it then we try
to add the ingredient and so on now
obviously we could further simplify
things by making a function that would
try to get the plate and try to add the
ingredient that could work but since
some counters are going to have a bit
more custom logic I think keeping them
separate like this makes more sense so
first we try to get the plate then we
try to add the ingredients so let's
apply the same logic to The Cutting
counter so over here on the cutting
counter let's scroll down to where there
is a kitchen object here and the plate
is carrying something so on the counter
we just want to copy all of this so
let's go over here and we do the exact
same thing okay that's it and the other
counter from where we can pick up things
is from the stove
counter so here we are on the stove
let's scroll down until we find the
interaction okay there's something here
the player is carrying something so it's
over here let's do that and do the exact
same thing except on the stove again
let's remember that this is using a
state machine so when we pick up
something let's do pretty much the same
thing that we did here so so let's make
sure to reset the State Fire the events
and so on okay so those are the only
counters that we need to implement we
cannot drop things on top of a container
we cannot drop things on top of the
plate counter or the trash so these are
the only three types that we need to
implement so with this let's test okay
so let's begin with some meat so let's
pick up some meat put it on the stove
let's pick up a plate wait for it to
cook pick it up and yep there you go it
does work now let's test The Cutting
counter so let's pick up some cheese
let's slice it pick up some plate and go
and yep there you go it's it doeses work
and again if we inspect we can make sure
that it is indeed working so let's go
into the plate and let's put this on
debug inspector and Y there we do see
this one has a meat Patty cooked and
some cheese slices okay great now the
last piece of logic that we need is
pretty much the opposite so right now it
works if there's a sliced object on the
plate and the player is holding a plate
object but now we want the opposite so
let's say there's a plate in here and we
slice some cheese and now I want to drop
the cheese on the plate so let's do that
and basically for this one this one is
only going to happen on the clear
counter that's the only counter type
that can have a plate on top of it so
over here on the clear counter then we
check if there's no object there but
that's not what we want we want if
there's a plate on the counter so if
there is an object there and if the
player is carrying something then we
check if the player is holding a plate
but if not so if the player is not
holding a plate so player is not
carrying plate but something else over
here we need pretty much exact same
logic except just testing for the object
on this counter so let's do if let's get
the kitchen object on this counter this
one try to get the plate so out Plate
Kitchen object for the Plate Kitchen
object so if so if so there's a plate
over
here that means the counter is holding a
plate so then let's go into this Plate
Kitchen object let's add the ingredient
and we're going to try to add whatever
the player is currently carrying so the
player. get kitchen object
and get the kitchen object as
so so we're going to try to add
this and if we can't add then we're just
going to destroy whatever is on the
player okay that's it and over here
we've got a nice error just because we
defined with the same name up here so up
here we're already defining the variable
and over here we're defining the same
variable with the same name so we can
either give this a different name or
just not Define a brand new variable
here so just it's defined up here and
we're using it here
okay so on logic is working now here
make very sure that you're not mixing
references keep in mind when you're
referencing the kitchen object on this
counter and the one on the player those
are two different things so over here if
the player is not carrying a plate but
something else then you check the
kitchen counter so over here you're not
checking the player but checking the
counter then you go into that plate and
you try to add the ingredient and you
try to add the one that the player is
carrying and then you destroy the one
the player is carrying so again be very
careful here make sure you don't mix
references so with this it should work
so let's make sure to save our script
and let's test okay so here we are let's
first pick up a nice plate let's drop
the plate in there pick up some bread
drop the bread and yep there you go it
does work all right so now we can do a
bit more natural interactions so for
example let's pick up some meat and put
it on cooking and there you go the meat
is fried so now I'm currently carrying
just some meat so I place it there then
I pick up some bread and put some bread
on top of the meat and yep everything
does work FY okay so here we created a
plate and we created some custom logic
to Define what the plate can and cannot
pick up now that's left is actually
being able to see what is on the plate
so let's do that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
add a nice visual to our plate okay so
right now we can already pick up
ingredients onto the plate so if I pick
up the plate and I pick up some cheese
there you go there's some cheese on the
plate but we cannot see it so let's
solve that and way we're going to do
that actually in a very simple way if
you look in the included assets inside
the prefab visuals there's this nice
plate complete that I built basically
it's a full burger that contains all the
ingredients what we're going to do is
actually very simple we're just going to
enable or disable these game objects
that's it so let's do exactly that let's
make a new C script quality plate
complete visual let's attach a script
over here and let's also make sure to
put this one inside the plate so let's
save this prefab let's go inside the
plate prefab so inside the prefabs here
the kitchen objects we've got the plate
so inside the PL let's drag that let's
drag the plate complete visual okay
great so now let's open up this script
over here let's first add a reference to
our Plate Kitchen object so we serialize
field private for the Plate Kitchen
object for the Plate Kitchen object back
in the editor let's drag the reference
okay great so now here basically we need
to update this visual whenever the plate
gets any ingredient added to it so let's
go over here into the plate script and
basically just need to fire off an event
when that happens so let's make a public
event event event handler and let's call
it on ingredient
added okay and for this one let's also
make an event ARS to contain the data of
what object we added so let's make a
public class on ingredient added event
args let's extend event args and inside
let's make just a kitchen object so
kitchen
objecto okay great and let's make the
event of this timee all right so now
let's just fire off this event so down
here when we try to add an ingredient if
we do add the ingredient let's fire off
this event so let's invoke with this and
let's create a brand new one passing the
kitchen object so as this kitchen object
so okay so we have our event correctly
being sent now over here on the plate
complete visual let's listen to it again
as always let's make sure to do it only
on start so the plate cchen object on
ingredient added let's listen to this
event and over here we just need to
either enable or disable the visuals
that Rel to the kitchen object inside
over here the event ARS however of
course the question is how do exactly do
we find them the plate complete visual
has all of these game objects how do we
know which one belongs to that kitchen
object now technically one way would be
to do a simple transform find and find
the child objects by name technically
that would work but like I mentioned in
the beginning of the course strings are
a horrible way to identify things they
are very air prone so let's not do that
instead let's use a proper approach
where we can Define some kind of link
between a kitchen object so and a game
object and we can do that very easily by
just defining a struct so up here in our
script let's do exactly that let's
define a public make it a
struct and name it kitchen object soore
game
object then inside it's very simple we
just have a kitchen objecto
field and then also a game object field
that's it super simple by the way if you
don't know what is a struct basically
it's very similar to a class except it's
stored in different places in memory and
behaves somewhat differently I have a
very very important video on that
subject what is the difference between
value types and reference types classes
are reference types so when you pass in
a class into a parameter you are passing
in a reference to that object whereas
structs are value types so when you
passing a struct onto a parameter you
are passing in a copy it's a bit of a
tricky thing so definitely make sure you
go watch that video for more detail so
you don't get confused in the future
here I defined it as a strug simply as
kind of a teaching moment but also
because it just makes sense that if I
just want to store some data without any
logic then it should probably be a
struct and not a class although in this
case a class would work just as well
anyway so here we have a struct inside
the struct we have a field of type
kitchen object so and another one of
type game object so now let's just make
a list of this type that we can expose
in the editor so here a serialized field
private let's make it a list of kitchen
objecto game object and call it kitchen
object so game object list okay that's
it super simple so let's save and make
sure this compiles so actually let's
just comment this out just make sure our
code compounds okay and over here in the
editor we see the tricky thing when it
comes to using fields of custom types if
we look in the inspector nope we don't
see anything so we cannot see our custom
type in the inspector if you make a
custom type like this struct and you
want to show it in the inspector then
you need to add the attribute
serializable which exists inside system
so let's go up here using
system and let's add the attribute
serializable just like this okay so do
this save and let's look and if there
you go now we do see our custom struct
so we've got a list and we can click on
the plus icon and there you go we've got
an element and it does have a field for
a kitchen object as so and one for a
game object so that's great with this
now we have a really nice place where we
can link one object to another so let's
just do exactly that so for example
let's put the bread over there and let's
assign the kitchen object as so for the
one with bread let's do the same thing
for all the others so let's add a whole
bunch more Okay so we've got the bread
then we're going to have the meat Patty
cooked then the tomato slices then we
have the cheese slices the Cabbage
sliced and finally the meat Patty burned
so we've got number 0 through five so we
have six elements and over here yep we
do got six so we have all of them we can
get get rid of these last two okay great
and now let's assign the proper objects
so this one for the meat Patty cooked
then we've got the tomato slices then we
have the cheese slices then the Cabbage
slices and finally the meat Patty burned
okay great so all the references match
now back in the code here so we have
this List fully filled out and when we
have this really very simple we just
cycle through the list to find the right
game object so let's do a 4 each of type
kitchen object so game object in our
kitchen object so game object list and
we check if this kitchen object so.
kitchen object matches the one that we
received in the event if they do match
then go into this one grab the game
object and set active into
true okay so that's it some very simple
logic and also we can start with them
disabled by default in the editor or
just over here just do something very
simple just do a four each cycle through
every single one of them and set every
single one of them to false so that they
are HID okay so with this all the
ingredients on the plate should be
visible so here in the editor let's just
make sure all the references have been
set let's go back save the prefab and
let's set on play okay so here we are
and by default look at that an empty
plate and yep it is empty and now let's
slice some cheese now let's Place some
cheese on there and yep there you go
we've got some cheese now let's pick up
some bread drop some bread and there you
go got some cheese and some bread then
let's cook some meat so let's cook it
and let's pick it up with a plate and as
soon as I go boom there you go I've got
a nice cheeseburg all right awesome so
with this I can now do a complete Burger
so let's finish it let's just add some
more tomatoes so slice them and add the
tomatoes and finally some sliced
cabbages slice them put them there and
there you go here we have a fully
complete Burger okay so that's great all
of our visual logic is indeed working
however this visual is a bit hard to see
it's not very clear to the player so
just looking at it from this distance
does that have a tomato or not there's a
tiny sliver of red in there but you
can't really see it so we should
probably add some nice clear icons on
top to clearly indicate what exactly is
on this plate so that's exactly what
we're going to do in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
add some really nice icons on top of our
plate so we can easily see what is on
there okay so for the icons let's do the
exact same thing that we did for the
progress bar meaning let's use a world
space canvas so let's go inside our
Plate Kitchen object prefab and over
here let's right click let's create a
brand new canvas let's name this the
plate icons UI then for the settings
let's make it World space put it on 0 0
everything width and height also on zero
then let's lift it up a little bit so
put it on a y of one okay like that now
inside let's define an icon so let's
start by making an empty game object
call this just the icon template let's
put it with a size of 3.3 it's okay
something like that then inside let's
add a new UI image name this the
background and make it stretch to fill
the parents so put zero on everything
okay there's our background for the
background image instead of a square
let's actually go with a circle for that
un actually has a bunch of built-in
Sprites that it added in the last
versions however it's not actually over
here by default in order to see those
default Sprites we need to install the
2D Sprite p package so let's quickly
just go into window package manager
let's make sure we are in the unity
registry make sure we are looking at all
and over here let's find the 2D Sprite
package okay so let's install this okay
there's the package so now if we go into
the background and we search for a
Sprite and over here make sure you click
to actually show the assets from the
packages and now we see a bunch of
default hexagons a bunch of isometric
tiles the square so on and if we search
for Circle yep here we've got a bunch of
circle so let's use this one over here
on this path so let's use it there you
go we have a nice circle now let's
duplicate this image and for the second
one let's name it icon and for this one
let's assign just a random Sprite so
let's say the bread and again remember
how the Sorting order on the UI this one
is based on the ordering the Hier so
make sure that the icon is underneath
the background the Hier that way it
shows up on top okay so we have our icon
template that's great of course we're
going to dynamically generate all of
this through code we're going to have
multiple icons and for positioning them
Unity actually has some really useful
components let's select the plate icons
UI and over here let set a component now
for example a built-in component is the
grid layout group this basically helps
you position all the child objects so
let's put the size of the canvas over
here on
0.9.9 okay so there you go a nice Square
window then over here on the settings
for this for the cell size let's put it
at 3.3 and if there you go already shows
up over there on the corner and we can
see what it will look like if we just
duplicate this object so let's make a
bunch more templates and yep there you
go that's what it looks like so as you
can see this component is super useful
for automatically positioning all the
child objects now if we want we can play
around all of these we can add a little
bit of spacing on the X or on the Y but
let's actually leave both those with
zero let's leave everything on defaults
just over here on the child alignment
let's put it on middle Center okay so
there you go that looks pretty nice so
you can see how this built-in component
is super useful there's actually two
more so this one for the grid layout C
this is great when you want to put
things horizontally and vertically but
if you just want horizontally then there
is the horizontal layout group and if
you just want vertically there's the
vertical layout group so all these
components are really awesome really
useful okay so with this our objects are
placed and note how I name this an icon
template basically a template is just
what I call something that is kind of
like a prefab but not really a prefab
through code we're going to duplicate
this template and dynamically modify the
icon so we're going to use it very much
like a prefab we could actually make
this into a proper prefab so I could
just drag it over here onto the project
files and make a regular prefab that
could work and the only reason why I
prefer this method of not using a prefab
is just because this object this
template stays here on the object as
opposed to cluttering over here your
project files if you have tons of
single-use UI elements with tons of
objects you need to spawn you can end up
with tons and tons of prefabs and you
might not even know where each of those
is used whereas with this method the
template stays exactly where it's used
and does not take an asset slot over
here on the project files so personally
this is just the approach that I prefer
for spawning UI elements but like I said
prefabs work as well so if you prefer
using prefabs go ahead and make it okay
so let's make our script to run the
plate icon zy so let's go into our
scripts and on the scripts folder let's
create a brand new C script for the
plate icons UI over here let's attach a
script and open it okay so now the first
thing we need is a reference to our
plate so let's begin by making a
serialized field private for the Plate
Kitchen object for our Plate Kitchen
object okay let's save it and drag the
reference so over here there's the plate
icons let's just drag the plate
reference okay great now on the plate we
already made this event when an
ingredient is added so basically we just
need to listen to this in order to add
the new icon so over here on the UI
let's do as usual private void start and
on start let's go into the plate citchen
object and listen to that event
and when that happens let's spawn an
icon although here let's actually use a
different method from the one we used on
the plate visual over here on the plate
visual whenever we had the event we
really just modified the object that was
added so over here the equivalent would
be to spawn a new icon whenever that one
was added but instead of doing that
right now let's listen to this event and
when this happens let's update all the
icons in this display basically this
other method is useful when the contents
can be added as well as removed now in
this case there are never going to be
removed so in this case both methods
work fine but still I want to show you
the second method just so you can use it
when you need it so for that method we
just need to know exactly what is on the
plate so over here on the Plate Kitchen
object we just need to expose the
kitchen object as s list so let's do
example that so public we're going to
return a list of kitchen object so let's
call it get kitchen object so list and
we just return the kitchen object as
list okay very simple then over here on
the plate icons UI let's just make a
function to update the visual
so private void let's call it update
Visual and when we have the event let's
call our update visual
okay so now here let's basically just
cycle through all the ingredients so
let's do a 4 in kitchen object so in the
plate and get the kitchen object so list
okay so we're cycling through all the
ingredients on the plate and then we
want to duplicate our template so that
means we need a reference up here so
let's add AC field private type
transform call it the icon template okay
let's save the code and over here in the
editor let's drag the reference so let's
drag the icon template by the way I'll
left the others over here that's not a
problem since these are going to be
destroyed those we're going to see in a
little bit the only one that matters is
the first one okay so here we have the
icon template so to spawn it we do it
just like we do with any preone so we
just call instantiate pass in the icon
template and then transform parents so
let's put it as a child of this object
this part is important we need to make
sure the object is spawned as a child of
this object if over here you put
something like null then the template
won't be spawned as a global object so
it won't be somewhere in the world so in
order to make it position properly let's
make sure to use transform to become a
child of this object okay and then since
we're using the other script the GRE
layout group this is already going to be
automatically positioned so just like
this it should be spawning the icon and
with the icon spawned all that's left is
really just sending the image and now
again the quick andary approach would be
over here when we spawn let's say we
pick up the item
transform and over here we could go
inside and do a find in order to find
the image in order to get the component
of Type image and so on so that is one
approach that would be the quick and D
approach but again we want to do things
properly so let's do it the proper way
instead so instead of this let's make a
proper script that we're going to run on
the icon template so let's create a new
script so new C script call it the plate
icon single UI so this one represents
just a single icon let's go ahead and
attach it to the template so over here
let's drag it and now when using this
template method really the only one we
need to worry about is this one the
other duplicates we can just leave them
they don't really matter but still just
to avoiding confusion I'm actually going
to delete them so okay we just have one
icon template okay and it has our script
okay let's open now for here let's
basically just make a function to set a
kitchen object so so public void let's
call set kitchen object
so and we receive parameter of type
kitchen object so so okay great so then
we need to set the image so let's just
go into a serialized field private of
Type image which is inside
unityengine.ui so for this one for the
image we have a reference and then we
set the image. Sprite go into the
kitchen object and grab the
Sprite okay so all we need to do is drag
this reference so over here in our
template let's drag the icon image okay
great so now back here on the plate
icons UI so we spawn it that's great
then let's do a get component in order
to get our
script so the plate icon single UI okay
and then we just call set kitchen object
as so and pass in this okay that's great
this is much better now again you might
be thinking that this method is a lot
more for Bose and just setting the image
Sprite here we had to create another
completely new script we had to write
this logic over here get it and use it
the quick and dirty approach would
indeed be quicker but remember that
while the quick and dirty approach might
be faster at first it will mess you up
over time so just take a few extra
seconds to do things properly this
approach is much more scalable let's say
for example on this function you want to
change not just Sprite but also trigger
some kind of Spawn effect or animation
with this it's very simple we've got
this function right here we receive the
kitchen object as so and we can do
whatever we want with it so like this we
have this grip that is responsible for
anything related to the single template
and we've got the general one which just
spawns them and just gives them the
kitchen object so so all of our logic is
nicely separate okay so just like this
it should already work however like this
you might already be thinking won't this
spawn way too many icons and yep it will
basically every time we add an
ingredient we're updating the visual
where we're cycling through every single
one and spawning all of them so with
this we're constantly going to spawn
more and more items this is not what we
want over here on the update visual we
do want to update and spawn all the
icons but before we do that we actually
need to clean it up we need to clean up
the icons from the previous event so
before we do that let's just cycle
through all the children on this
transform so that's pretty simple you
can just do a for each transform child
in the transform so this way Cycles
through all the children and then just
call destroy on this child. game object
so that won't work that won't destroy
all the previous children however of
course we also have one issue the icon
template itself is also a child so if we
do this we're going to destroy the icon
template which then over here we're
going to have an error because we're
going to instantiate null so we want to
destroy all the children except for the
template so over here that's pretty
simple we just check if the child equals
the icon template if so then let's just
skip it so we can just call continue and
there you go it skips okay great so just
one more final thing if we leave the
template like this meaning the game
object is enabled like this the template
will always be visible plus whatever
ingredients we have we don't really want
the template to be visible this is just
meant to be a template that we can
essentiate so that's pretty simple to
fix let's make a private void awake and
on awake let's grab the icon template
grab the game object set active into
false okay so now the icon template
won't be disabled so it won't be visible
and then over here when we are insena
the intiated ones will also be disabled
so let's make sure we go in there and
enable these all right that should do it
so all of our logic should be working
there's only one more tiny thing we need
to take care of this one is a world
canvas so like we saw with the progress
bar we need extra logic to make it look
towards the camera and thankfully we
already wrote an excellent generic
script to do just that so let's go into
the plate icons zi and let's add a
component and let's add our very nice
look at camera so like this and let's
set the mode the same that we use so
let's put it camera. Forward okay so
everything is great everything should be
perfect so let's finally touch test
let's leave the scene save the prefab
and head on play all right so let's go
pick up a plate and there you go there
are no icons visible okay that's great
now I'm going to place a bread on top of
the plate and there you go I've got a
nice bread icon okay great now let's
make some meat cook it and as soon as
it's done going to pick it up and there
you go I've got a bread and some meat
now let's put some cheese slice it put
it there and there you go now I can
easily see that plate has some bread
some meat and some cheese now let's just
add the rest of the ingredients to make
a full Mega Burger so let's add some
tomatoes and add some nice cabbage
slices and yep there you go it works
perfectly so here we have a complete
burger with everything and we can easily
see on the icons everything this
contains all right awesome okay so here
you learn how to make yet another Super
useful element that you can easily add
to all of your games personally I use
this kind of logic a ton in all kinds of
UI things for example in my upcoming
steam game total World Liberation the
items in the inventory they're all added
using using this method so there's a
template and I duplicate that template
same thing for all of the action buttons
all of those are based on having a
template and duplicating it it's a
really easy way to do this kind of thing
with all that here we have a full plate
and we can easily see what is on there
so with this the next obvious step is to
actually deliver some orders so let's do
that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
build the delivery counter this is where
we're going to drop some items that the
customers have requested in order to
complete the orders also just for fun
we're going to learn how to use Shader
graph to make a simple custom Shader
okay so let's begin by making our
counter so let's go into our base
counter let's create a new prefab
variant for delivery counter let's go
inside and now let's find the visual the
visual for delivery counter let's
duplicate it to make the selected let's
go inside modify the material then on
the selected make it 1% bigger one1 add
the component the selected counter
visual let's drag the kitchen counter
like that okay that's our basic setup
and also start with the kitchen count
disabled okay great now let's make a
script to run this so let's go into our
counters folder let's create a brand new
C script for the delivery counter let's
attach it and open okay so now here as
usual let's begin by extending our base
counter class all right now let's
override the interact function and for
now let's let actually do it ex s like
the trash counter meaning let's just
destroy the object so we just check if
the player is holding something so if
the player has a kitchen object let's go
into the player the kitchen object and
let's destroy it however another rule
over here for the LI counter is this is
only going to accept plates so let's see
if the player is carrying a plate object
so player get kitchen object and test
try to get the plate so out Plate
Kitchen object for the Plate Kitchen
object we try to get this this and if it
is a plate then we destroy
it okay that's it here in the editor
let's just compile the script and drag
the references so the counter top point
and on the selected let's drag the
counter reference and let's exit this
save the prefab and let's drop it over
here on the corner so let's find over
here the delivery counter let's put it
over there angle it on this side put it
like this let's also just quickly
reposition all of our counters since we
already have all the types that going to
use so on delivery counter let's put it
over here on this corner so x 7.5 0 and
Z of two then next to it let's put the
plates counter so over there okay then
next to it let's put a clear counter
after that let's put the trash counter
and then let's also put another empty
one there so let's duplicate this one
move it up to about this and put it like
that now we just need to move all of
these down here so just select all of
these counters and let's move them down
by about this okay so on minus 5.5 like
this okay so everything is nicely
positioned just over there right now we
cannot access that container so let's
actually modify those as well which by
the way over here there's the canvas in
front so as I click I'm actually
selecting the canvas in the Hier key so
here's a quick in TP on the Hier key on
the left side you've got these two
buttons so one of them hides the object
and the other one simply makes it
unselectable so if I click on this and I
click through and you have the click
goes through the canvas so that makes it
much easier to select over here all the
items in our scene so let's just select
all of these okay all of these now just
push them all to the side and make
another empty one and put it over here
okay that's a nice layout now let's just
finish the rest so over here let's just
duplicate our empty counters and place a
bunch more let's put one more to the
side and now these ones over here so
let's put it over there and rotate it
here and duplicate another one and
another one and another one and just one
more and get rid of this one okay great
so here we have pretty much our complete
map let's also just move the camera tiny
tiny bit just make sure that it is
nicely organized so put it over there
just so everything is nice and centered
okay so there's our map now let's get
back to working on our delivery counter
we already added this code so let's just
quickly test so here we are and if I
pick up something like for example some
cheese going to delivery counter and
interact and nope nothing happens
because that one only accepts plates now
if I pick up a plate go there deliver
and yep there you go it does work okay
great so this is the basic logic that we
want for defining the actual recipe
logic we're actually only going to do
that in the next lecture but for now
let's add one more nice thing let's add
a simple custom visual over here using
Shader graph this is a great way for you
to learn the part of Shader graph and
just how easy it is to use this is a
visual tool for making shaders it's
really very easy personally I don't know
how to write shaders with code but I can
build some pretty nice things using
Shader graph as usual I have a dedicated
video on it I also have an entire
playlist showcasing how to make all
kinds of interesting effects and even
one special video covering some changes
in recent sharew versions so over here
let's learn the basics how to use it so
first here in our project window let's
create a brand new folder let's name it
just shaders and now inside let's create
one so let's create then go up here into
Shader graph then we're using urp so
let's go inside there and here we've got
a bunch of options now don't worry about
picking the quote unquote wrong option
all this does is just create a template
so for example if you accidentally
create an unlit Shader you can then
easily swap it out from l so right now
let's go with theit Shader and for the
name let's name it moving visual okay
there's our Shad graph file now now
let's just double click to open it and
up here we have the nice Shad graph
window by the way you can make this full
screen so you can either right click
over there on the tab and maximize or
alternatively you can just click on this
window and you use the hotkey shift
space y there you go it doesn't maximize
okay great now by default we have this
down the center this is called the
master stack these are the actual
properties that we're going continue to
use then on the left side we have the
properties Blackboard on the right side
we've got the graph inspector and
finally down here we've got the main
preview all of these windows can be
scaled and also if you don't see these
windows or if you accidentally hide them
they're all appear here on these three
buttons so the Blackboard that's on the
left the graph inspector and the main
preview okay so now here we've got a
nice empty board so we can add whatever
nodes we want so we can right click and
go into create node and then we can
write something or just click anywhere
and press on space and and there you go
now we can cycle through and browse all
of these menus to see all of the nodes
that exist there's tons and tons of them
or alternatively just go up here and use
the search bar so for example let's find
the sample texture to the node so here
it is this one okay we've got this node
what this one does is it takes a texture
and grabs the color from it so on the
left side of the node are the inputs and
on the right side are the outputs within
the parentheses you can actually see the
types so for the input texture this one
is of type T2 so that means it's a
texture 2D then on the output you can
see there's a four meaning it contains
four floats which in this case refers to
the four colors so that's red green blue
and Alpha so for an input we want a
texture so let's set it over here as a
property let's click on the plus icon
and we've got a whole bunch of types for
texture we want a texture 2D so let's go
with that and then for the name now
usually there are two standard names
there's one called main Tex or Bas map
main Tex used to be the more common name
but when working with urp for some
reason they decided to name the main
texture as base map so we're here let's
stick within the urp standard and just
call this base map okay there's our
property and if we click to select it
and on the right side we can see the
graph inspector and we can see all the
properties for this actual property so
we see a name reference and a bunch more
things now the really important one is
over here the reference this is the
actual name that you're going to use if
you want to interact with this Shader
through code the name on the property
this one is just a text ring so this can
be whatever you want you can even have
spaces and so on whereas the reference
name this is the really important one
and by default when you set up a name it
should already set the correct reference
usually the standard is to name it just
like the name both without any spaces
and with an underscore in the beginning
so just like this okay then we can give
it a default texture so let's go ahead
and select something for example over
here the bread texture remember this is
just a default this will not be
hardcoded directly into the Shader we
can then modify this okay so we have our
nice Bas map property definition now we
can just drag it over here on the board
and yep there it is and now we can just
click on the Cal icon in order to drag a
connection and let's connect it over
here onto the simple texture to the
input and yep right away we do see it
does work so we are correctly sampling
the texture however if you look on the
main preview over here there's still
nothing that's because we don't have
this node connect to anything we need to
connect it to the final Master sack in
order to render something so again on
the output over here we can see a four
so these are all of our colors and
actually one very useful note is the
preview since so many things in Shader
graph can be hard to visualize so we can
move these nodes around and let's add
the preview node and this does exactly
that so you can fit it an input and you
can see down here what that input
contains so for example let's drag just
the red Channel and Y there you go over
there we can see the red channel for
this texture we can drag the green
channel the blue Channel or look at the
alpha Channel yep there you go it does
work so this preview note is super
useful for being able to see what your
shaded is actually doing over here we
have the colors so let's get rid of the
preview right now and in order to make
it work we really just need to connect
the rgba and go up here into the base
color and right away it should work but
you might not be able to see anything
over here on the main preview I believe
this is a rendering bug in the current
Tech version so right now nothing is
shown so if you still don't see anything
it's actually pretty simple just go up
here on the top left side and make sure
to save the asset okay save it great
then let's exit from our maximize View
and now let's close this tab let's click
on Play Just to play the game now let's
stop playing and now if we open the
Shader again y there you go now we do
see the Shader compiling over there that
color that is the Shaded compilation and
after a little bit it should work let's
just maximize this see if there you go
there we do see our texture okay great
so again this just a simple rendering
bug on the current Tech version if
you're watching this video in the future
chances are you don't even have this bug
so there's no need to worry okay so
right now we do see it working we can
see our bread texture and it's currently
being applied on a sphere for a use case
where working with 2D textures so this
would be best to be seen on a quad so we
can right click over here on the preview
in order to select the preview mesh so
let's go with a simpon quad and Y there
it is we have our nice quad okay great
so over here we have our basic Shader
all it does is just shows a texture
that's it now let's actually use this
and first let's always make sure to save
the asset on the top left side on the
moving visual if you see an ass is here
that means you have unsaved changes so
always make sure to save them in my case
I don't but still never hurts to save
now over here in scene view let's go
inside our delivery counter so let's
open it and now for the display for our
Arrow let's make it a flat quad so let's
right click in the Hier key let's create
a new 3D object and let's make it a quad
let's call this the delivery
Arrow let's place this on top of the
counter so let's rotate it to face
upwards by the way on the rotation make
sure the color is facing upwards most
shaders by default they only render one
face and not the other one so make sure
you put the face with the collar upwards
and not the other one okay so let's
rotate this one upwards so there we go
90 over there and let's just put it just
exactly on top of the counter so just
enough so that it's visible okay great
so now let's make a material for our
Arrow so let's go inside the materials
folder and over here let's create a
brand new material let's call this the
delivery Arrow let's make sure to use
this material on the quad so let's just
drag it over there on the mesh render
okay so it's using our custom material
and over here on this Shad of graph drop
down menu over here we can select what
Shader we want to use so in our case
let's go inside the fer Shader graphs
and inside yep here we have our moving
visual Shader so let's go ahead and use
this and here right away we do see that
it does work here we have our texture
being drawn exactly on top of our
material okay so far so good now again
here remember one very very important
thing that I said the texture that you
define the Shader over here the default
for the property this one is only the
default the important one is the one
that we have on the material I'm
emphasizing this point because I've seen
a bunch of people make this mistake if
you modify default texture whilst inside
the Shader like for example if I change
here from bread let's say into the
Cabbage slices if I modify that note how
it does not modify any materials that
were created we are only changing
defaults so if you want to change the
texture that is actually used make sure
you change the one on the material that
you created and not the default I
changed the default but did not change
this Shader however if I now were to
make another material which by the way
here's a quick tip you can right click
directly on the Shader file and go into
create and create new material and it
will automatically create the material
using that Shader naturally here didn't
update default just because I didn't
save the Shader so I modified this one
for the cab slices and now if I save the
asset and now if I right click there and
I create a brand new material and yep
now that one does have the new default
but again remember what you said over
here is just the default what really
matters is what is on the material after
the material has been created modifying
default here does nothing so always keep
that in mind in most cases you want to
be changing the property on the material
itself not the default on the Shader
okay let's just clean up both these all
right so let's continue now here we have
our Sprite working okay except we don't
want to show some bread so let's
actually use the proper Arrow Sprite so
let's select this one and yep it does
work it is printing the Sprite however
one obvious thing is that the arrow is
not transparent like it should be so
let's solve that back in our Shader
graph in order to make this a
transparent Shader we need to actually
go into the graph settings so on the
graph inspector go into graph settings
and over here you see a bunch of
settings that relate to the graph itself
and not any selected properly so let's
go into graph settings for example like
I mentioned a while ago you can modify
between lit and lit and so on so this is
where you would change that you can also
up here add multiple targets so you can
create a Shader in Shader graph and make
it work with the universal render
pipeline or the high definition render
pipeline or the built-in R pipeline all
of those are supported through Shader
graph now for our goal in order to make
this a transparent Shader let's just go
over here onto surface type instead of
opaque let's change to transparent and
as soon as we do look what happens there
and if there you go it adds a brand new
Alpha Channel if we just save the asset
right now and no look at that it still
doesn't work it's still not transparent
basically we made this Shader
transparent but now we need to fit in
the transparent Channel over here onto
the alpha this is the one thing that is
different from a previous version of
Shader graph previously you could just
feed the alpha Channel over here onto
the base collar and Shader graph would
automatically apply it but in recent
version you need to add it over here
separately so if you have any issues
with transparency when following some
older share graph tutorials always
remember this change I covered that
along with some other changes in a very
useful video so if you're following
along some older shade graph tutorials
make sure you watch that video to learn
what you need to do to update them to
the latest version okay so here on the
sem texture we already have the alpha
channel so we just connect this onto the
master Alpha and right there we already
see it working let's just go ahead save
our asset and here in scene view yep
there you go now we do see our error
now one more small thing you might
notice that from some angles it's not
exactly transparent basically it
actually is transparent but since we
made this a lit Shader sometimes the
light might make the transparent Parts
visible one option to solve that is over
here on the graph settings instead of
making it lit let's make it unlit that
would work so yep with the unlit Shader
the transparency is perfect but if you
really want to keep it lit then the
other thing you can do is just over here
play around with these settings you've
got smoothness AO and so on and over
here you can even modify the workflow
mode so for transparency instead of
making it metallic let's go with a
specular workflow and then over here set
the smoothness to one and the ENT cusion
down to zero and now if we save this
Shader look at that and yep now the
transparent parts are indeed fully
transparent finally over here on the
right side on the mesh render if you
want you might want to play around over
here with the cast Shadows so maybe you
don't want this one to cast Shadows
maybe you don't want it to impact light
probes and so on okay so with this we
have our nice transparent Arrow let's
make sure to save our deliver counter so
let's go outside back into scenes and
let's head on playing and there you go
we have our transparent counter with our
nice Arrow now we want the arrow to
actually move and doing that is actually
super simple going back here in our Shad
graph let's just modify default just so
we can see the arrow that we want to see
so let's select the arrow Sprite okay
there's our Arrow now for moving over
here on the sample texture we've got an
input for the UV the UV is what defines
what portion of the texture we're going
to grab which by default just gets the
whole texture so since this field
represents where we're going to grab
from texture by playing around with this
we can grab different parts so to do
that let's just add a standard UV node
so here it is this is the standard UV
channel so if we connect this then
nothing changes everything still renders
exactly the same but now we can modify
this and to do that we're really just
going to use some basic math remember
that when working with shaders even
though you do see colors everything is
really just numbers so uv2 is just
number the color is just a number the
alpha is just a number so visually
everything might look like images might
look like colors but really in the end
it's all just numbers so for example how
do we move this texture well that's
actually pretty simple we just add a
number onto it so over here on the UV
let's just add an add node so this just
adds two numbers together very basic so
let's take the regular UV and let's add
something on top of it for example we
can make a vector two and let's put it
on say
0.10 and let's add this one onto this
one and now if we drag this one onto the
input look over there on the preview
what happens and there go look that it
moves slightly to the left so if I
modify this one put it down zero there
you go at that 0.1 on that point 2 on
that and so on so you can see that by
modifying here I'm essentially
offsetting the texture I'm offsetting on
the X and over here I can also offset it
on the y basically I'm offsetting the
texture by 10% duv is a normalized value
this is not pixels so that is why 0.1 is
10% regardless of how big the texture is
and if we go way past one then texture
essentially Loops back so this is really
all we need for our moving Arrow we're
going to have zero on the Y and on the X
we're going to constantly either
increase or decrease that's how we're
going to have our moving Arrow so again
the only issue here is that I'm
modifying this manually we don't want a
fixed amount on the Shader instead we
want a nice animation so for that we
have the very useful the time node this
one has various time based outputs the
one that we want for this case is the
time which is just the total time this
one is constantly increasing since the
start of the game by the number of
seconds so if you use this over here
directly on the ad and there going look
that texture is constantly scrolling
okay so that's great except obviously we
have one issue we don't want it to
scroll diagonally we only want to scroll
in One Direction so for that we can
essentially create a simple property to
act as our Spen so let's over here on
the Blackboard let's create a new Vector
2 call it our speed property and for
default let's Def and say 0.1 on the X
zero on the Y
and now if I drag the speed over here
onto our Blackboard okay great this is
basically a multiplier so we just need
to multiply the time by this so let's
add a multiply node also by the way
quick tip over here on each node you've
got a nice little arrow so if you want
to make it a bit more compact so if you
don't actually need to see the preview
so make that and in this case let's take
our time multiply by our speed and then
for the output pass it into the add okay
so look at that now it is indeed moving
in this direction and over here on the
speed we can play around the values so
if we put put it at 0.5 now it's moving
faster and if I put it on the Y now it's
moving diagonally put zero on the X and
now it's only moving vertically okay so
this is really what we want let's just
go ahead save our Shader and now let's
just select our delivery Arrow material
and over here yep we've got the speed if
you don't see it make sure that on the
speed property over here you have it
exposed so we have the speed instead of
moving on the Y let's move on the X and
actually like this it's revers going
backwards so over here we can just put a
negative value so let's put it on minus
one and Y there you go now the arrow is
moving perfectly also here let me make
one important note just in case you're
using this Shader with a custom texture
instead of the one including in the
course if you do that make sure that the
texture that you use over here I'm using
the arrow texture over here on the Arrow
import settings down here under WAP mode
make sure it is set to repeat if you set
it as clamp you might get some weird
visuals or nothing at all in order for
the texture to constantly Loop and
constantly repeat itself that one needs
to be set to repeat okay so here it is
in game and we have a really nice moving
texture for that we created a simple but
really nice useful custom Shader
definitely go ahead and watch the
various effects that I made in the
Shader graph playlist this tool is super
useful definitely make sure you know how
to use it I've used it for making a
building effect I've made some nice
outlines a really nice wind Shader also
a really interesting dissolve effect and
even a cool transition Shader just like
in the game Hades so this really is a
super powerful tool make sure you watch
that playlist to really learn learned
how to use it all right so here we
learned about Shad graph and created a
really nice custom Shader however the
delivery counter still only has a visual
so let's create some proper Logic for
generating and delivering the correct
recipes in the next
lecture hello and welcome I'm your cm in
this lecture we're going to build a
proper delivery manager that will
generate recipes that the customers are
ordering and validate to see if the
player May the right dishes all right so
right now we have the player capable of
making dishes so for example I can put
some cheese cook some meat meat cut the
cheese and then pick up both them then
let's say pick up some bread there you
go got a nice cheeseburger and deliver
it okay so that works but right now they
just vanish on delivery counter so
there's no recipe we need to follow no
validation none of that so let's add
both those things okay first of all
let's make our script so let's create a
brand new script for the delivery
manager let's make a new game object to
run it so a new delivery manager attach
the script let's make sure to keep
things clean so reset the transform and
also by the way since over here let's go
ahead and put the plates and delivery
counter inside the counter so everything
is nice and organized okay great so
let's open up this script now here
basically we need to Define some sort of
list to store all the recipes that the
customers are waiting for which of
course begs a question what type is that
going to be now technically one thing we
could do since a recipe is really just a
list of kitchen objects over here we
could have a list of list of kitchen
object this would be our recipe list
technically that would work but that
really it looks quite dirty instead of
having a list of list we should probably
have a proper type for this so let's
write some good clean code and Define a
proper recipe script M object back in
unity let's go inside the script M
object folder and create a brand new one
let's call this the recipe so and over
here let's make this a script M object
so extend script M object make the
create asset menu and now over here for
the fields for the data that we need
really like I said a recipe is just a
list of ingredients so just a list of
kitchen objecto for the kitchen objecto
list okay that's it that's really all
the data that we need to define a recipe
just to be able to identify them for the
player let's also add a public string
for the recipe name so just a nice name
String okay great now back in the editor
let's define so let's go inside the
script objects and make a brand new one
for our recipe so and now inside let's
create a brand new recipe so for this
one let's call it just burger and over
here first of all for the name just name
it burger and then for the kitchen
object list well to make a burger let's
well first let's add some meat and we
want some cooked meat we don't want to
serve uncooked or burnt meat so only the
cooked meat then for a simple Burger
obviously we need some bread and that's
about it so some bread some meat that's
our very basic Burger now let's also
make another one so let's duplicate this
one and name this one the cheeseburger
over here let's name it cheese
burger and like name implies has bread
meat and obviously some nice cheese
slices so there you go okay we have a
cheeseburger now let's also make a mega
Burger so something with everything so
let's call this one the mega burger and
over here for the string name for the
Mega burger and for that we have meat
bread cheese let's also have some nice
cabbage slices and also some tomato
slices all right that's our Mega burger
with everything and finally let's also
make just a nice simple salad so let's
duplicate this for a salad let's name it
salad and for the salad we don't have
any meat we don't have any bread and
also no cheese so just cabbage slice and
tomato slice that's a simple salad okay
so here we have all of our recipes so
back here on the delivery manager script
instead of making a list of list of Game
object let's just make a list of recipe
recipe so and name it the recipe so list
this is where we're going to place the
recipes that the customers are waiting
for so let's actually rename this let's
put it waiting recipe list okay so the
customers are waiting for whatever is
inside this list and now we could make
this a serialized feel and then set it
in the editor but we don't want to have
a fixed list we want to periodically
spawn new recipes and in order to spawn
new recipes we also need to know which
ones we can spawn so for that we could
add a list of all of the recipes then we
could pick a random one from the list
and add it over here to the waiting list
that would work that's one good approach
but since we already did something
similar to that various times on this
course here let me teach you a different
approach that sometimes might make more
sense for that second approach we just
need one thing we need a script M object
to hold all of our recipes so let's do
that let's do a brand new C script this
is the recipe and list script M object
and then inside this one is going to be
a script M object let's add the create
asset menu and inside we're just going
to have a list of recipe so for the
recipe so list so that's it super simple
now let's just create one object of this
type we can put it inside the recipe so
list since we're only going to have one
so let's make a recipe list so name it
the recipe list so and then over here
let's just drag our recipe so we've got
a burger a cheeseburger we have a mega
burger and finally a salad okay so
basically we have a script B object with
all of our recipes and now just for
safety since we only want to ever have a
single one of these objects a recipe
list as so for this one we can go back
here in the script and simply comment
out the create asset menu so now back in
the game over here we can no longer
create another type of recipe list as so
so just a nice safety thing since we
probably only need just one and let's
also add an underscore just so it shows
up at the top of the list okay great so
we have this and now over here on the
recipe manager we can basically expose
that in a serialized field so let's make
a serialize
field make it private of type recipe so
list recipe list so for the recipe list
so and now here in the editor we just
drag that reference all right that's it
so basically the difference that we did
with this method is over here on
delivery manager instead of having a
list of all of our recipes we just have
a reference to one object and then that
object holds a list of all the recipes
in this specific use case like I said
this approach doesn't really have many
benefits compared to just storing the
list here but let's say we had another
script that also need the list of all of
our recipes if we did that we would
basically have duplicate references so
this script would have a list of all the
recipes then some other script would
also have a list of all the recipes and
then if you wanted to add a brand new
recipe you would need to add it to all
the list on all the scripts whereas like
this any script that needs to know about
all the recipes just needs a reference
to the recipe list as so and whenever we
want to add or remove a recipe we just
need to update this one object and
everything works perfectly that's one of
the benefits of this approach where you
have a scriptable object to hold a list
of all the objects of some type
personally I find this pattern to be
quite useful okay so on delivery manager
we have a list of all of our recipes now
let's just make a simple timer to spawn
them like I mentioned previously in the
spawn plate logic you could just use a
co- routine if you like that co-
routines can be useful for running
timers but personally like I mentioned I
do not like co- routines I don't like
the pattern they force you to use so
over here I'm just going to make a
simple float timer so a private float
for the spawn recipe timer and another
one for the recipe timer Max and let's
say 4 seconds then we just do a simple
private void update on update let's
count down the timer so time. Delta time
and if the spawn timer is is under 0f
let's reset the timer and now let's
basically spawn a recipe so for that
let's grab a random one from the list so
we go into the recipe listo and grab the
recipe so list then we're going to grab
a random one so let's get a random index
so random. range between zero and the
recipe and listo do recipo list. count
so you get a random one this is going to
be a recipe so for the waiting recipe so
and then we simply go into the waiting
recipe so list
and we add a brand new recipe okay
that's it super simple let's just make
sure to initialize the list so let's do
here a simple awake for the waiting
recipe ass on list and just initialize
it okay so like this it should be
working however we're also going to
generate recipes non-stop we don't want
that so let's find some kind of Maximum
so let's find a simple in for the
waiting recipes
Max let's say we can have a maximum of
four recipes waiting and then down here
when time elapses so if the waiting
recipe has only stock count if it is
under the maximum then we generate an
added okay that's it pretty simple now
for testing let's just add a log here to
print the name so debug. log on the
waiting recipe so that we generate so
let's print out the recipe name okay so
let's test so here we are and yep one
will spawned right away so we have a
salad and after 4 seconds yep there you
go another salad and if we wait for 4
seconds we should have another one there
you go a mega burger recipe and finally
after 4 seconds we have yep we have
another burger and now no matter how
much time passes there should be no more
since we're at the limit and yep time
passed and no more okay all right
awesome so we are correctly generating
recipes that the customers are waiting
for now let's set logic to try to
fulfill these orders so over here on
delivery manager let's make a function
to deliver a recipe so let's make a
public void make it public since we're
going to access this from the delivery
counter call it deliver recipe and the
recipes are going to be delivered whilst
on a plate so let's receive a parameter
of type Plate Kitchen object and over
here the logic is actually going to be
pretty simple we just need to cycle
through all the recipes that the
customers are waiting for and see if the
ingredients on this plate matches the
ones on any waiting recipe so over here
let's cycle through all of our recipes
so let's do a four enti zero going
through the entire recipe list count i++
okay let's grab the recip PSO for the
waiting
recipo and we grab from the waiting
recipo list on this index okay so we
have that then first let's do a quick
test just to check if the waiting recipe
has the same number of ingredients as
there are on the plate if not then we
already know that it's not valid so over
here let's do a quick test SO waiting
recipe so let's check the catchen object
ass list. count if this one matches the
play kitchen object let's get the
kitchen object s on list and also check
the count so over here we know that has
the same number of ingredients so this
is the first check then we need to cycle
through all the ingredients on this
recipe and all of the ingredients on the
plate and basically see if both of them
match so let's first cycle through the
ingredients on the recipe so for each
kitchen object ASO let's call it the
recipe kitchen object so in the waiting
recipe so let's go into the waiting
recipe and get the kitchen object list
okay so here we are cycling through all
ingredients in the recipe then we need
to cycle through all the ingredients on
the plate so let's do another cycle for
the Plate Kitchen object so and we're
going to go inside the Plate Kitchen
object get the kitchen object so list
like this so here we are cycling through
all the ingredients on the
plate okay so now here basically we need
to see if this ingredient that we're
cycling through if this one matches the
ingredient on the recipe so here we
check if the Plate Kitchen object do so
if this one matches the recipe kitchen
object as so if so then the ingredient
does match so in order to keep track if
it does match over here before we cycle
through all the ones on the plate let's
define a bow for found or ingredient
found let's defaed to false and over
here if we have match and this one
becomes true and by the way over here we
can also break out of the cycle now if
you're not familiar with break basically
this is going to break out at four each
so let's say the plate has 10
ingredients and the second one matches
when this cycle gets to the second one
it triggers a break so it no longer goes
through the remaining eight so basically
it breaks out of the cycle so it keeps
writing some code right down here okay
so we cycle through all of the ones on
the recipe then we cycle through the
plate and if we do find that ingredient
on that plate then we have an ingredient
found so over here if we have a not
ingredient
found then over here that means means
this
recipe ingredient was not found on the
plate so if that happens then
essentially over here we have a fail
state so the ingredient that this recipe
requires is not on the plate so let's go
up here when we have the same number of
ingredients let's find a bullion called
the plate contents matches recipe let's
seea it to true and over here if we
don't find at least one of them then the
plate contents do not match the recipe
and afterwards we can check this B again
so if this one is true that means they
all match if just one of them does not
matches then this one won't be false so
over here we know player delivered the
correct recipe so over here let's do a
quick debug. log and print out a
message and after we do let's also do a
return so we stop the rest of the
execution so basically if we find a
waiting recipe that matches we don't
want to keep going and also here if we
do find it let's also remove it from the
list so let's go into waiting Q remove
remove at and remove at this index okay
so we're going to remove this recipe but
if this doesn't happen then it's going
to be keep cycling and it's going to
cycle through all the recipes so
basically if it reaches the end this
four then basically no matches
found so the player did not deliver a
correct
recipe so let's do another debug. log in
here okay so this don't for logic
it looks a bit complex but I hope this
was easy to follow when we see it in
action It all becomes a bit more clear
so all that's left is just calling this
function from the delivery counter so
let's do that over here on the delivery
counter it accepts plates it destroys
plates but before we destroy let's go
into delivery manager which means we
need to access a reference so again we
could add a serialized field or in this
case it makes perfect sense to make this
a Singleton so let's make it here public
static of type delivery manager call it
in
with a public get and a private
set okay then over here on awake let's
set instance equals
this all right so now over here on the
delivery counter we can go into the
delivery manager access the instance and
deliver our recipe and pass in the Plate
Kitchen
object okay that should do it let's test
all right so let's look in the log to
see what they are waiting for so there
are two cheeseburgers waiting another
Mega burger and a cheeseburger so let's
make a cheeseburger to deliver so first
of all let's cook some meat let's slice
some cheese let's pick up the meat
before it burns pick up the cheese and
we just need the bread okay this is a
valent cheeseburger so let's deliver it
and if there we go the player deliver
the correct recipe okay great now let's
deliver something that nobody asked for
let's say just some meat actually let's
burn it just for fun all right so there
we have a bunch of charred meat so
nobody really wants this but if we
deliver yep there you go player did not
deliver a correct recipe all right
awesome so over here everything worked
we have a bunch of recipes being
generated and then we have the logic so
that when the player delivers something
it checks if the player delivered
something correct or incorrect so
everything is great all that's missing
is obviously some nice UI so let's do
that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
create a nice UI visual to display our
waiting recipes okay so our delivery
manager is already working we are are
randomly spawning some random recipes
every once in a while now instead of
looking at the console let's add a
proper UI so for that over here in the
editor let's go inside the canvas and by
the way let's click on the button to
unlock the canvas and this is actually
the first time we're using the regular
canvas quite a while ago we just created
it we didn't really set it up so let's
quickly do that for the random mode this
one is meant to be a regular UI so let's
leave it on the screen space overlay
then over here on the canvas scaler
instead of constant pixel size let's go
with scale with screen size then for the
reference resolution I like to use 1920
by 1080 and finally I like to fully
match with the height basically this
means that objects in the canvas will
only be scaled if the height changes for
example let's head inside just a quick
UI image just a test let's look in the
game view there you go there's the image
let's just put on a different color okay
so there's the image and note how if I
modify the aspect ratio here so let's
say I put it on 5x4 there you go the
horizontal size of the window changed
but note how the element was not scaled
so I can put it even on free aspect so
really wide and does not change the size
whereas if I modify this if I modify the
vertical size the image does indeed get
Scaled up or down personally I like the
setup because means that I only have to
worry about positioning things
horizontally if the vertical part gets
changed everything gets automatically
scaled okay so great so over here let's
go back into full HD all right and let's
get rid of the image all right back in
the scene view let's quickly look at the
canvas so we can select the canvas press
the F in order to zoom out and also we
can press the 2D button up here to go
into 2D mode okay so here's our nice UI
now inside the canvas let's create an
empty game object call it the delivery
manager UI then in the inspector let's
make it stretch to occupy the whole
thing so let's put zero on everything
okay so this window now occupies the
entire screen now inside let's do just
like we did a while ago for the plate
icons meaning let's make the template
that we can then clone but let's also
put those templates inside of a
container so first of all let's make the
the container so a new empty game object
call it just the container the reason
why I'm going with this approach is
because I also end to have other objects
outside of here if you remember how we
did with the templates we can actually
go there and see so let's go inside the
prefabs inside the counters actually
it's on the kitchen objects let's go
inside the plate over here for the
template basically we use the plate
icons UI this main canvas as the
container but if you remember how we did
that in order to make sure we didn't end
up with duplicate icons we always
destroy the previous one when we spawned
a brand new one so every time we were
cycling through the children of this
object in order to destroy all of them
except the template so over here we're
going to use a container so that we can
apply that logic only to the children of
the container and that way we can have
other objects outside of the container
for example outside of here let's say we
want some nice text just saying recipes
in waiting so on delivery manager let's
make it a child of that one let's go
into UI and let's make a text textmesh
Pro and this is the first time that
we're using textmesh Pro so this window
pops out let's actually import the text
mesh Pro Essentials okay just let it
import okay that's it we don't need the
examples are extra so let's just close
this window over here on this window
let's name this the title text let's set
the text to something like recipes
waiting let's put it up there on the
corner so let's anchor it on the top
left corner also for the text I like to
put it on a width and height of zero but
of course that makes the text really
vertical so then down here on the
wrapping let's just disable it so there
you go looks like that and let's put it
over there on that corner now in scene
view we are seeing things different so
if you want to see what this looks like
just go into the game View and over
there yep we do see the recipes let's
just make it in Bol so there you go just
some nice text okay so that's our text
and then for the container let's make
inside the delivery template so let's
create an empty game object let's call
it the recipe template and for this one
we're going to want to Anchor it to the
top left corner so with the template
selected over here in the inspector
let's click and we want to click up here
however
we also want to set the pivot so let's
make sure to hold down shift in order to
set the pivot over there okay great
that's exactly what we want so we want
the template around the corner then
let's give it a size of say 250 by 100
okay now instead of template we just
need two things we want the name of the
recipe as well as the list of all the
ingredients although before that let's
actually make a nice visual for the
background so a new UI image for the
background let's make this one stretch
to occupy the whole thing let's put
everything on zero okay that's the
background let's put it on a black with
just a little bit lower Alpha okay
that's good then for the name let's make
a text field so inside the template
let's create another text call it the
recipe name text then over here let's
put it a bit small so on a font size of
maybe just 20 let's put it in bold and
let's also again put the width and
height of zero and over here make sure
to disable wrapping okay so that's the
text so we've got it up there let's just
anchor it to the top left corner okay
great over here we we can change the
name to recipe and then what we need is
the icons down here and for that we're
going to do pretty much the exact same
thing that we did on plate but before we
do that logic let's just get this basic
setup working so let's just position
everything so first of all the container
for all the templates let's anchor it on
the top left corner and let's push it
all the way over there and for
positioning them let's use this time the
vertical layout group so inside let's
duplicate template just to be able to
see them okay so that's pretty much what
we want we can actually set the width
and height both to zero and let's set
the spacing to something like 30 okay so
that's our basic UI now let's make the
script to run this so over here in our
scripts let's create a brand new C
script for the delivery manager UI let's
go into the parent game object and let's
attach to script let's open okay so now
here first we need a field for the
container and another one for the
template so let's do a serialized field
private transform for the
container and another another one for
the transform and this is going to be
the recipe template then let's do pretty
much the same thing we did previously so
first of all let's actually go onw in
order to hide the template so game
object set active into false okay so
first we hide the template then let's
make an update visual function so
private void update Visual and for
updating we're going to do the exact
same thing that we did so first let's
cycle through the container and destroy
everything except for the template so do
a 4 in transform child in the container
and if the child is the
template if so then we're going to
continue and if not we're going to
destroy the child game object okay so we
have the cleanup now all we need is to
cycle through all the waiting recipes so
that means that over here on delivery
manager we need to expose our waiting
recipe as on list so let's go down here
make a function to do that public going
to return a list of recipe so get
waiting recipe so list and we just
return return the waiting recipe as on
list okay great so now here on the UI we
can now go into the liy manager accy
static instance in order to get the
waiting recipes on list so let's cycle
through this so do a 4 in for each
recipe so recipe so in the waiting
recipe on list and for each of them
let's
instantiate and let's spawn our recipe
template spawn it inside the container
and then we just need to set this to
enabled so let's grab the transform for
the recipe transform we grab this one
grab the game object and set active into
true okay so like this the only thing
missing is the text but that's okay for
now let's just see where we're going to
call this function to update the visuals
and as usual we want to be smart and
write some good clean code so let's not
do the dirty approach of just updating
this on every single update instead
let's only call this function when
something actually changes so over here
on the delivery manager let's just make
some simple events
so public event event handler let's call
on recipe spawn and another one call it
on recipe
completed and actually as soon as I add
the event handler which also add using
system now here we have an interesting
thing we've got a nice namespace
Collision it's telling us that random is
an ambiguous reference between Unity
engine. random and system. random that
is because both these name spaces Unity
engine and system both of them have a
class named exactly random so the here
does not know which class we're trying
to use to solve this conflict we really
just need to be more specific in this
case here we want to use the unity
engine version so let's just write the
full name Unity engine. random and yep
that works okay so now let's fire off
the events so first of all the on recipe
spawn so over here when we spawn a
recipe let's invoke this event so this
event tars empty and let's also get rid
of along we don't long need that okay
now we could also add the waiting recipe
on the event ARS but in this case we
don't need it just firing the event is
enough and then down here when the
player delivers something if the player
delivers the correct recipe we remove it
from the list and then let's fire off
the event so on recipe completed let's
invoke with this and event arsmt okay so
we have the event and down here we also
don't need a log okay so that works and
finally over here on the delivery men UI
let's just make a private void start on
start going to delivery manager access
the static instance and listen to both
these events so the spawn and let's also
listen to the other one so delivery
manager instance on recipe completed
when either of these work let's just go
and update the visual so just like this
let's also rename this because again
instance doesn't sound like a very good
name let's actually rename this to
delivery manager and same thing up here
by the way I'm using the visual studio
shortcut control RR in order to rename
this to delivery
manager and finally we also need to
update the visual on start just to make
sure the previous ones do not show up
okay that's it so like this it should be
working we should be able to see no
Visual and then as more are spawned we
should be able to see each one being
spawned until the maximum so let's see
just over here in the U let's make sure
to drag the references so the container
and the template and let's set on play
and okay right away actually it spawned
one recipe it spawned instantly then
after 4 seconds there you go a second
one and after 4 seconds we should be
able to see yep another one now four
more seconds and we should see the final
one and now no matter how long we wait
it should no longer spawn anymore and
yep that works all right awesome so the
basic logic is working now let's handle
the proper Logic on the template for
that like I mentioned previously one
approach would be over here you could go
and do a transform. find find the actual
recipe name text then get the text mesh
component set it that would work but
like I mentioned previously that would
be very dirty not good at all we should
avoid using find at any time and we
should also avoid the individual logic
from the total logic so let's do it
properly and make a proper script to
handle each spawn template so let's
create a brand new C script call this
delivery manager single UI single just
because refers to a single recipe and
also right now we already have quite a
few UI scripts so let's organize our
project again so let's organize a new
folder for the UI and inside let's put
all of our UI scripts so the LI manag is
single this one D play icons play icons
and the progress bar let's put all of
these nicely organized in the UI folder
okay so with the script let's go into
the recipe template and attach script
now let's open and over here let's begin
by adding a field for our text so a
serialized field and over here it's also
very important for the text we are not
using the text inside unityengine.ui
this is the Legacy text it is not textes
Pro so this is not what we were using
instead we want to use text mesh Pro UGI
which is in inside TM Pro so we need to
go up here and add using TM Pro and now
we can use this type and also make sure
you're using text mes Pro Yi and not
text mesh Pro this one also exists but
don't mix these two these are two very
different types if we go over here in
the editor and if outside the canvas if
I just create and create new 3D object
and new text object if I do that then if
we'll look over here in the inspector we
see this one is of type text mesh Pro
whereas for the ones that we're using
inside the canvas if we look this is
text mesh Pro it's a UI text so these
are the two different classes within
text mesh Pro you have text mesh Pro and
text mesh Pro UGI we're working on the
UI so we want this one okay so we name
this the recipe name text okay that's it
over here into the editor let's drag our
reference all right so on the script
let's make a function to set the recipe
so a public void and let's call it set
recipe
so and we going to receive a recipo
recipe so then we just go into the
recipe name text and we set the text to
recipo do recipe name okay so that's
pretty much it now over here on the U
script when we instantiate our recipe
transform let's get component of type of
our delivery manager single UI and call
set recipes so and pass in the recipe so
okay so let's see if the name shows up
and if right way it does show up so we
can see that we generate the
cheeseburger recipe and right now a mega
burger recipe okay great so all that's
left are the icons down here so like I
said that is going to be yet another
usage of our template pattern so inside
the recipe template let's create an mty
game object call it the icon container
and then inside that let's make the
template and template is just going to
be an image so we can just create an
image St away call it the ingredient
image let's scale it with a size of 40
and 40 let's put a image by default just
like that and on the icon container
let's put the width of zero height of
zero and let's put a horizontal layout
group put it over there on the left side
and we can create a bunch more just to
see how it looks okay so that's pretty
much it now over here on the single
script let's add a serialized field
private transform for the icon container
and another one for the icon
template then we do the same thing as
usual so when we set the recipe so let's
first of all clean up the container so
let's do for each transform child in the
icon
container and if the child is the
template then we want to continue and
ignore it if not we want to destroy the
child. game object okay so that's a
cleanup and then let's do for each
kitchen object so in the recipe so do
kitchen object ass own
list second through all this let's
instantiate our icon temp
template instantiated inside the icon
container so this going to be the
transform for the icon
transform then as usual we need to go
into the game object set active in order
to enable it and also let's go up here
make a private void awake and on awake
the icon template game object let's
disable it okay we don't want the
template to be visible okay so we
insantiy template we set it as active
then since this one just has an image we
can just do a get component of Type
image that's image not image
conversion so image so it's this one the
one inside unityengine.ui so let's get
this image and let's modify the Sprite
and set it to this kitchen object as so.
Sprite okay so that's it that should do
it let's test over here in the editor
let's just go into the template let's
drag the container reference and the
template reference and let's also rename
this instead of ingredient image put
icon template just to be AIT more clear
and we can get rid of the other ones or
leave them doesn't really matter okay
great so let's head on play and see and
yep right away it does work so we can
see a burger is composed of a burger and
a bun a salad yep there you go some
sliced cabbage and sliced tomatoes then
cheeseburger same thing as the burger
with some cheese and then another Burger
let's just deliver until we see the mega
Burger so let's deliver a cheeseburger
let's cut
it get this get some bread place it in
there pick it up before it burns that's
a cheeseburgers so that one should
vanish and Y there we go it does vanish
let's see if something else not
cheeseburger so let's keep doing until
we get the mega burger just to see that
everything works so let's deliver a
regular burger okay now let's deliver a
regular
salad okay just pick up like that like
that and drop it okay let's see any yep
there it is the mega bar all right great
so the visual logic is fully working and
the delivery logic all of it is working
so I can deliver the right recipes and
get rid of them from the recipe waiting
list and more are spawn every time here
we can see the name of the recipe as
well as all of the nice icons okay so
with all this our game is really taking
shape everything is very close to being
done one massive thing we're still
missing is an obvious one which is sound
so let's do that in the next
lecture hey again quick intermission
you're almost at the end so once again
congrats for making it this far this is
the second secret call out go ahead Post
in the comments a time stamp and a nice
monkey emoji it won't be fun to see how
many people make it to this point by now
you already know about the website I
hope it's been very useful to you and
you already know to ask any questions in
the comments if you need help with
anything so all that's left for me to
say right now is thanks for watching the
course so far and I really hope you've
already learned a ton there's only a
bunch more lectures until we get to the
final polished game so let's continue on
the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
add some audio to our game starting with
a really nice music track okay so our
game is already looking pretty good but
everything is still way too silent so
let's begin by adding some music adding
this is actually extremely easy to do in
the included assets over here inside the
sounds we've got a really nice music
track I hired the musician to make this
it sounds really good it's a seamless
Loop so to add to our game it's going to
be super simple we just want a constant
never ending Loop so let's begin by
creating an mty game object call it the
Music Manager manager let's reset
transform keep things organized and
let's add a component and we want the
component an audio Source here is this
one like new implies this one acts like
a source of audio you will note how by
default on the main camera down here it
already has an audio listener so the
source plays some sound and The Listener
listens to it now for here we just need
to set these fields so for example on
the audio clip let's make sure to drag
the music audio clip okay great next
over here let's enable play on awake we
wanted to start playing right away and
for this track we do want to enable
looping okay great then for priority
basically Unity has a limit to how many
sounds can be played at once if you play
too many then some sounds won't play and
which ones do you play is all based on
priority we always want the music to
play so let's put this one on Max
priority then for the volume later on
we're going to make a proper option
screen to handle this but for now let's
put it on something like 04 or5 just
make a nice background track
then we have here the spatial blend for
this music track we wanted to play the
same regardless of where the camera is
so let's make this all the way fully a
2d sound okay and that's it we don't
need to play around with any of the
other settings and just like this if we
are on play any up there's the music now
if you're not hearing anything make sure
that on the game view first of all that
the game is actually selected make sure
the scene is in Focus so over here I can
move around so the game is in Focus then
on the game view over here on the top
right corner make sure this sound sound
icon is toggled if not then everything
is muted and also again make sure like I
mentioned on the main camera that it has
the audio listener component with all of
that yep you should be able to hear the
music now this song is playing and it
won't Loop forever just like we wanted
personally I really like how it sounds
I'm really happy with what the composer
made it perfectly matches the vibe of
the game so it really is this simple to
add some music to the game let me just
point out one thing also related to
sound one of the things you can make is
an audio mixer so for example on the
project files let's create a brand new
and let's find over here the audio mixer
so there you go here is an audio mixer
then you can double click to open up the
audio mixer window and then over here
you have the master node and then you
can create multiple groups so let's
create a brand new group for something
else and then you can play around over
here with the effects with the volume
all kinds of things all kinds of effects
everything then for each sound where you
have the audio Source over here note how
you have an output and for this output
you can set it to play on the fter so it
plays on everything or set it on just
one individual group so with this you
could assign a group to one individual
type of sound effect or the music or so
on maybe you could even have your music
split into multiple stems so there's
lots you can do but for me I'm not an
audio engineer audio is probably the
part of game development that I know
least about I just stick with the
absolute Basics but if you want to learn
more definitely look into the audio
mixer this is an extremely powerful tool
but like I said for me I don't know how
to work with it so I'm just going to
stick with basics
so on the output let's revert back into
none close the audio mixer and get rid
of this and there it is the music is
playing and it all sounds really nice
all right so here we very easily added
some music to our game this lecture is
actually super short because it is
genuinely that simple now the next thing
that we need is going to be a little bit
more complex and that is adding sound
effects so let's do that in the next
lecture hello and welcome I'm your code
monkey in this lecture we're going to
add some sound effects for our game okay
so previously we already added some
really nice music now let's add a whole
bunch of sound effects in the project
files if we go inside the assets over
here we've got all kinds of sound
effects basically I heard a really nice
sound designer to make all of these and
I think they all sound really great so
let's add them to our game now when it
comes to sound effects there are two
main ways to play a sound one is just
like we did for the music so we can
create a game object add the audio
Source component and play it that's one
approach but that basally requires pre-
preparing the sound objects so there is
an another simpler way that just
requires one line of code so let's begin
by making a Sound Manager game object so
a new empty game object for The Sound
Manager let's reset the transform now
let's make our script so let's go in the
scripts folder create a brand new C
script for The Sound Manager let's
attach a script and open okay so now
here let's make a function to play
Simple sound so let's do a private void
just call it play sound and over here
the way we play sound through codes
actually super simple we just just go
inside the audio Source class and in
here there's a static function play clip
at point this as you can see takes an
audio clip a vector 3 for the position
and finally a volume so basically it
won't play that sound on that position
by default Unity already has 3D sound so
if you play the sound on the left or the
right side of the camera it will play in
the correct place also for the volume
the further away it is from the camera
the lower it will be and if we don't
want the 3D sound we can just play
directly on top of the camera position
okay so in this function let's receive
our arguments so for the audio clip it's
going to be our audio clip then let's
receive Vector 3 for the position and
let's also receive an optional one for
the volume let's just default this to 1f
okay so here we just pass this in into
our function so the position and the
volume okay great so now let's call this
nice function and for example let's
start with a simple one so let's start
with the delivery sounds so over here on
the delivery manager script down here we
have the logic for delivering a recipe
and over here we know when we completed
a successful recipe or when we failed
and the player delivered a wrong recipe
so this is where we want to play some
sounds and again here we have yet
another very important clean code
question we could technically call the
play sound function directly from here
that would work but of course that would
make this class tightly coupled with The
Sound Manager for a simple game on this
scale that approach can work just play
sounds directly from the logic code
however again to make things properly we
should should really separate the logic
from the sound just like we separated
the logic from the visuals so instead
let's not call the sound directly from
here instead let's make two more events
so let's make one on recipe success and
another one on recipe
failed okay so now let's fire off these
events so over here we have the success
so on recipe success and if we get down
here then we have a fail so on recipe
fail okay great we have two events now
back here on The Sound Manager we can
just listen to those so let's do a start
go into delivery manager access the
instance and listen to the on success
and on failed events so listen to that
one delivery manager instance on recipe
failed listen to both of these again
let's write some good clean codes let's
rename this one instead of instance
let's put it delivery manager and same
thing on this one also name it correctly
delivery manager okay great so now when
we have this we want to call play sound
and now want to pass in a reference to
the recipe fail sound so technically one
approach would be up here to add a
serialized fi for an audio clip that
would work but since we've already done
that so many times in this course here
let's use a different approach that I
also like to use let's create a script M
object to hold a reference to all of our
sounds so similar to how we Define the
script M object hold all of our recipes
let's just comment this out just to make
sure the code compiles okay great so
back here in the other edor let's make a
new Script Mod object type so let's
create a brand new C script for the
audio clip refs Script Mod object now
here let's make this a simple scriptable
object with a create asset
menu okay so now for the fields if we
look in the S over here the audio design
that I hired actually made several
variations for each sound so we've got
multiple chops multiple delivery fails
and so on so back in the code here
instead of storing a reference for a
single audio clip
let's store an array for all of them so
we have the chop then we have all the
others so let's just add all of the
references so there's a chop there's the
delivery
fail then we have delivery success then
we have
footsteps then the object drop then the
object pickup then we have the stove
Sizzle although this one is just one
then we have the trash and finally we
have the warning
all right so these are all the sound
references we're going to use back in
the editor let's just create the object
so on the script M objects let's create
a brand new one let's make it of audio
clip refs so just name it audio clip
refs
Soo and over here let's just wrag the
references so let's use that quick un
tip in order to un lock the inspector
now I can select all the chops and drag
them all delivery fails drag them
delivery success drag it then for all of
the footsteps after that are all of the
object drops then the pickups then we
have the sizzle which is just one
finally we have the trash and the
warning okay those are all the
references so our script object now has
all of the data we need let's unlock the
inspector okay and back in the code here
on The Sound Manager let's make another
version of this function so let's make
one play sound except instead of
receiving an audio clip it receives an
array of audio clip I then basically we
just call the other function so we call
the other play sound function and pass
in an audio clip from this array so
let's actually rename this so audio clip
array and let's pass in an audio clip
from here so do a simple random.
range between zero and the array. length
passing the position and the
volume okay so just like this now we
need is a reference to our scrip object
so a seriz film private of the audio
clip refs so
okay we have this then here in the
editor let's just assign the reference
so the audio clip reference okay great
and over here when we have the recipe
failed let's go into the audio clip reps
and let's pick up this one is delivery
fail and then the other one is going to
be delivery
success for the position let's just
default to the camera. main
transform.position
so like this the sounds will play
exactly on top of the camera okay so
let's and see if it all works okay so
here we are and let's do a wrong
delivery now quick warning if you're
following along or if you're just
watching the video this sound will
probably be way too loud but let's test
so if I just pick up the plate and I
just deliver an empty plate yep there
you go there's the sound and now if I
deliver a correct one so someone wants a
salad so let's cut a nice salad chop
that chop this pick up the plate pick up
that one and that one deliver the
correct salad and yep there you go it
does work all right great so the sound
effects work they played perfectly but
they're a bit too loud basically that's
because these sounds were designed to be
played in the world rather than on top
of the camera so when we play the sound
let's actually play it on the position
of the delivery counter here is the
delivery counter script and based on our
design we're only going to have a single
delivery counter so we can just make
this a Singleton so as usual public
static of type delivery counter call it
instance with a public get and a private
set
then on private void awake let's just
set the instance equals
this okay so now over here on The Sound
Manager we can just grab delivery
counter delivery counter and we just go
delivery counter and grab the static
instance and then for the sound position
we can just go delivery counter access
the transform.
position okay so just like this on that
one and on this one
okay so let's test now it shouldn't be
as loud okay so here we are and let's do
a wrong delivery and yep it does work
now let's do a successful delivery so
let's make a nice cheeseburger so grab
some cheese slice it grab a plate just
need some
bread and deliver it and yep there you
go it worked all right
awesome okay so this is really it this
is how we're going to play our simple
sounds now there are some that are going
to require more logic like the footstep
sounds and stove Sizzle but first let's
begin by adding the simple ones so let's
begin with the chop sounds this is super
simple we just need to go over here onto
the cut en counter and actually we
already have the uncut event that we
made previously this was used to spawn
the visual so we can also use it to
spawn the sounds however there's
actually one difference we're going to
have multiple cutting counters and this
one as you can see this one is not a
static event meaning each different
counter is going to have each list of
listeners and we really don't want to
have to subscribe to every single one of
the counters individually so what we can
do is instead of making it a regular
event that belongs to each instance of a
cutting counter we can make a static
event which will belong to the entire
class but we still want to leave this
one just for the visual so let's do
another one a public static event event
handler and let's call it on any cut
basically for any static events that
belong to any object type I like to add
the keyword any we're going to fire this
event when any any cutting counter is
going to trigger a cut action so where
we fire this event is exactly the same
thing so over here we've got the uncut
let's do the exact same thing so on any
cut with this and event rs. empty okay
so we have our nice static event now
over here on The Sound Manager let's
listen to it so let's go into the cut en
counter again we're going to access
through the class name and let's listen
to the on any cut event and over here
let's just play the sound so let's play
the sound let's go inside the audio clip
refs so and let's grab the chop sound
then for the position we want to know
who fired this event and by following
the C standard over here we already have
the object sender so we know this was
the object that fired this event and we
know this is going to be of type cutting
counter so we can just get cutting
counter cutting counter and we just grab
the sender as a cutting counter okay so
we have this then over here very simple
access transform.
position okay that's it great that won't
play The Cutting sound on that position
on that cutting counter okay great now
let's handle the player picking up
something and for that let's go over
here onto the player class and the way
we set up the kitchen object parent
system is actually already perfect for
this down here we have a function so if
we scroll down Yep this function set
kitchen object this one is called
whenever the player receives a kitchen
object which means really when the
player picks up something so if this
kitchen object is not n then that means
the player picked up something so let's
do that so here let's make the event so
a public event event handler call it on
picked
something and then down here just we
test so if the catch an object is not
null so if the player did pick up
something then let's just fire off this
event so just do our usual invoke with
this and event RX that
empty okay so that's great then on the
sound manual let's just listen to it so
let's go into the player class let's
access the static instance and let's
listen to the on picked up something
event and again let's rename this to a
proper name so player onp picked
something and over here let's just play
the sound and for the sound go into the
refs and grab in this case the object
pickup and for the position let's just
go player do instance and grab the
transform. position okay that's it next
for item dropping now we can only drop
items on a counter so over here we have
the base counter class and again we have
the same thing so we have the set
kitchen object and again the same thing
as with the cutting counter we don't
want to be required to listen to every
single counter we just want to listen to
one event so let's make it up here so a
public static event of type event
handler and let's name it on any object
placed
here and then down here when we have the
set kitchen object we do the usual if
kitchen object is not null if so then
let's fire off this event
okay great and on the sound maner let's
listen so go into the base counter on
any object placed here when that happens
play the sound and let's go into the
other PRS and this one is the object
drop so that one and for the position
let's do the same thing we did so we
cast the base counter equals the cender
as a base counter and then we go into
the base counter and let's grab the
transform. position okay so we just need
one more special counter type here we
have the trash counter and this one it
never really changes the parent it just
destroys the object so over here on the
trash counter itself let's fire off an
event but again let's make it static
even though we're only going to have one
trash but make it static just to be able
to support multiple so public static
event event handler on any object
trashed and then over here just fire off
this event so invoke with this and event
R is empty okay so now if we go into The
Sound Manager and over here once again
the trash counter on any not the on any
object plac but on any object trashed
and on this one let's do pretty much
exactly the same thing so let's copy
this the sound is going to be the trash
sound instead of a base counter we could
just cast it to a base counter but let's
make it proper so let's make a trash
counter as a trash counter and this is a
trash counter okay great that's that's
it so these are all of our basic simple
sounds as you can see all the logic is
super simple so let's test and see if it
all works okay so first of all let's
pick up an object so if I go into a
container and I pick it up and Y there
you go there's the sound now if I drop
it somewhere and yep there's the sound
now for the trash pick it up drop it on
the trash and yep there's the trash
sound okay great then also let's check
out the cutting so I pick up some cheese
drop it there and cut and you there you
go got a really nice cutting sound okay
so far so good now let's s on the more
complex ones starting off with the stove
for this one the sound is meant to be
looping but only when the stove is on so
we don't want to just play once but play
and stop playing depending on the state
of the stove so for this one instead of
spawning the sound through code let's
actually spawn it on the object itself
so let's go inside the stove object
let's go on the stove counter and open
up the prefab and inside this prefab
let's create a brand new empty game
object name it sound let's reset
transform make sure it's on 0 0 0 okay
great now let's add an audio Source
component and for the auto clip let's
use the pan Sizzle let's make sure to
not toggle play on awake but we do want
it to Loop and let's also make it a 3D
sound okay so that's a basic setup Now
to control this let's make a script so
let's go into our scripts folder and
let's create a brand new C script called
the stove counter
sound let's attach the script over here
and let's open it so now here first
let's grab the audio Source component so
we've got a private audio source for the
audio source and just go on awake and
audio Source equals get component of
type audio Source okay then we're also
going to need a reference to the stove
counter so let's add up here eiz field
private of type stove counter for the
stove counter then back in the editor
let's drag that reference all right now
in the stove counter over here we
already have the states and we have the
on state change event again the same one
that we use to modify the visual so on
the sound let's do pretty much exactly
the same thing over here let's do a
private void start and on start let's go
into the stove counter and listen to the
on state Chang
event and basically when this changes we
want to check if it's frying or fried if
so then we want to play the sound if no
then we don't want to play it so let's
find a b call it play sound and we're
going to play if the state equals we are
fry or the state equals that it is
currently fried and about to burn Okay
then if we have a play sound then let's
go into the audio source and call
play and if not then let's go into audio
source and call
pause all right so that's it pretty
simple let's just make sure to save our
prefab go back outside and let's set on
play and okay four stars there's no
sound playing now if I pick up some meat
and I drop it on there and if there we
go there's the sizzling sound and
continues going and now it is still
sizzling but if it burns it should stop
so if I go and if there you go the
sizzling sound sto all right awesome so
let's take this one out let's actually
trash it now let's pick up another one
let it cook and once it's cooked pick it
up and there you go the sound does stop
all right awesome so we just have one
more final sound remaining that's the
footsteps
by the way the warning sound this is
going to be added during the Polish
lecture for the footsteps we want very
much the same thing that we did on the
stove so we're going to want a script to
handle that logic but this time we don't
need an audio Source on the player we're
going to use the same play Method as the
other ones let's just make a script to
run the sounds so let's make a new C
script for the player sounds let's go
into the player game object and attach
the sound okay so now here let's first
grab the player reference
so private player player and on private
void awake let's get component of type
player and assign it to the player okay
then for the footsteps basically we want
to play them every certain amount of
time so let's do up here a private float
for the footstep timer another one for
the footstep timer Max and let's say we
want to play say 10 times per second
then we do a basic update and on update
footstep timer countdown by time. time
and and if the footstep timer is under
zero then let's reset it so set it to
the maximum and it's in here that we're
going to play the sound so now here we
have two options we can fire an event
here and we can listen to it on The
Sound Manager so exactly the same thing
that we've been doing previously or we
can just trigger the sound directly from
here doing that will mean that this
class is tightly coupled with The Sound
Manager usually we want to avoid tight
couplings however in this case the
player sounds class this one is really
only meant to exist alongside the sound
manager so in this case it's perfectly
fine to title couple them so let's play
the sound directly from here which means
we need a reference to The Sound Manager
we could make a serialized field or just
make this a Singleton so let's do that
so a public static type sound
manager name it instance with a public
get and a private
set then on private void
awake we just set the instance equals
this okay so then over here we can just
access it so just go into the sound
manager access the instance and we call
play
sound which we actually need to make
public however this function also takes
a reference to the audio clip array so
that means we need a reference to the
audio clips so again we have multiple
options we could add over here on the
player sounds add a serialized field for
the footstep sounds or we can just make
a specialized function over here on The
Sound Manager both options can work just
fine let's go with the second one just
to be different so just make here a
public void play footstep
sound we're just going to receive a
vector three for the position and then
we just call play sound let's go into
the audio clip
refo and let's pick up the footsteps and
play it on this position and let's also
receive the volume just appear a FL for
the volume okay so that's great now we
just need to call this function so over
here on the player instead of calling
play sound let's call the other one play
the footstep sound then for the position
that's see player transform. position
and for the volume I just exposed the
volume just in case you want to make the
footsteps a bit more sent or not but for
now let's begin with 1 F and then see if
that's way too loud as usual instead of
using magic numbers let's define a float
for the volume put it at 1f and over
here use the volume okay great however
you might be noticing an obvious issue
here right now this is going to play
non-stop obviously we don't want to do
that we only want to play footstep
sounds if the player is actually moving
so this pretty simple we just need to
ask the player if it is moving and we
already did that so player is walking so
if the player is walking then we play
The Sounds if not we don't okay that's
it so let's test so here we are and if
I'm standing still there's no footsteps
okay that's great and as soon as I move
yep there you go we got some nice
footstep sounds all right great so with
all of that we added all of our sounds
now here note how we mostly use this
method of going into the audio source
and using the play clip at Point
function this one is great because it is
so simple but it does have limitations
specifically with regards to all the
options if we look on the audio Source
component here we have all these options
so you can use an output use an audio
mixer like we saw in the previous
lecture we can play around priority play
around the pitch make it 2D or 3D play
around over here with how the sound
falls off so tons and tons of options
that you can't really access if you use
that simple function so when approach if
you need these options you could make
each sound a prefab so make a prefab for
each different audio clip and then
instead of calling that function you
would simply ineni that prefab to spawn
that audio so you've got lots of options
depending on how complex you want your
sound to be but for a simple game and
for simple sounds this one line of code
is super simple all right so here we
have added sound effects to our game
that coupled with the music that we add
previously already makes everything
sound so much more Al it's really
starting to look like a proper game
the one thing we still don't have is
some kind of game start and game end
scenario so let's add that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture let's add a
simple beginning state to our game so
right now we can play the game all of
the mechanics everything works perfectly
it's all been implemented however in the
beginning of the game it just starts
right away as it loads there's no start
no countdown no time for the player to
get ready so let's sort that out with a
simple countdown
let's begin by making a general game
manager script to handle all of our
general game States so let's create a
brand new C script and now here you
could use the name game manager so you
could use this name however for some
reason Unity un likes to add this custom
icon when a script is named exactly game
manager personally I don't like this I
don't want it to be a different icon I
want this script to look and behave just
like any other one of my scripts so
personally I don't like this but if it
doesn't bother you then go ahead use it
doesn't really change anything just a
visual but in my case I prefer to give
it a different name so sometimes I call
it game Handler or other times just
something related to this game like for
example the kitchen game manager and
just like that it won't have that custom
icon just need to go inside and rename
this to Kitchen game manager okay save
the script and all right now let's make
a game object to run it so a new game
object with the same name let's attach a
kitchen game manager and reset transform
okay let's open now here we're going to
Define all the various game states that
our game can be in so for that let's
define an enum so a simple enum call it
State and for the various States let's
say we are first of all waiting to start
then we are on countdown to start then
the game is playing and then we have a
game over okay so these are our states
let's do a private void awake and on
awake let's set the state so we need to
store a state for our state and on awake
we set the state equals and let's begin
on waiting to start by by the way the
point with this waiting to start state
will also be very important in the next
video covering multiplayer basically
we're going to wait until everyone is
connected before we start the actual
countdown but over here for now we're
just going to wait a little bit on the
waiting to start then we're going to
trigger the countdown and then after
some time trigger the game playing state
so pretty much all of these states are
going to be time based so let's make a
simple timer so a private float for the
waiting to start timer let's begin on
something like 1f so we just wait for 1
second then let's make a private void
update and let's make a state machine
just like we've done previously so do a
switch on our
state in case we are on state. waiting
to start if so then let's go into the
waiting to start timer count it down by
time. Delta time then if the waiting to
start timer if it is under zero if so
then let's move into the state equal
state DOT let's go into the countdown to
start okay so that's it and the other
states are going to be pretty much
exactly the same so let's just copy this
so we have the winning to start then the
countdown to start then we have the game
playing and finally we have the game
over and that one doesn't have anything
so just like this like I said we could
reuse the same timer but let's write our
code nice and proper so let's make
different timers for each so let's make
three timers so we're going to have the
countdown to start timer so countdown
for this one let's see found two three
so we're going to wait 3 seconds before
we start and then the game playing timer
and for this one let's put it something
short just for testing so let's put it
just test and then down here let's just
use them so on the countdown let's
countdown this timer on the game playing
countdown this timer when the countdown
ends we go into game playing and when
the game playing ends we go into game
over all right so that's our super basic
state machine just a bunch of timers
super simple let's do a quick log just
to see so over here just a debug.log and
let's just print out the current state
okay so just like this let's test and
yep right away we are waiting to start
after 1 second going to countdown then
after 3 seconds going to game playing
and now if we wait for 10 seconds after
10 seconds we should be able to see just
a little bit and yep there you go we've
got our game over okay great all the
logic is working although we actually
didn't change anything technically the
game right now is on a game over but
everything still works the same as
previously so I can still play I can
still do everything so let's sort that
when we are in any state other than the
game playing State we don't want the
player to be able to interact with
anything we want to leave it movement
cuz that's usually nice and fun but we
don't want it to be able to interact
pick up objects or do anything so let's
do that basically over here on the game
manager let's just expose a function so
public bow let's call this is game play
Then over here pretty simple just return
if the state equals state. gameplay
that's it so now we can go into the
player script so over here on the player
script let's go down into the
interaction function so over here we've
got the interact alternate and the
interact and on both of these basically
let's just ask if the game is in the
game playing state if so we want to
interact but if not then we don't want
to do anything so to access the game
manager we could add a pi calized field
or as usual let's just make a nice
Singleton so Pi public static of type
kitchen game manager the instance make a
public get and a private
set then down here on awake let's set
the instance equals this okay so now for
here on the player let's just go into
the kitchen game manager access the in
and test is game playing and we're going
to do an if if the game is not playing
so if we are not playing we want to stop
this so let's just do a return so if the
game is not playing the code is going to
stop executing here and same thing on
the interaction so just like that we
won't be able to interact with anything
once we are not in the game playay State
okay so here we are waiting to start
nope I cannot pick up anything count on
to start nope I can't and as soon as we
go into game playing yep now I can
interact so I can cut a bunch of things
and as soon as it goes into game
overstate
there you go currently in game overstate
so now if I try to interact nope can't
do it okay awesome everything works
perfectly so in terms of logic this is
really it there's nothing else we need
to do but of course right now the player
would have no clue as to why sometimes
they can grab and sometimes they can't
so let's add a proper visual first let's
add a visual to the starting countdown
so let's do that as a canvas element so
let's go inside our canvas create an
empty game object name this the game
start countdown you want
let's press F to focus on the object
press two to turn this into 2D okay so
let's see now over here we really just
need a text object so let's leave this
one anchored on the center let's put the
width and height both on zero we don't
need that and then let's go inside
create a new text object call this the
countdown text and then inside let's
just put a number so just a three let's
put the width and height both on zero
then down here let's put it in bold on a
really big font size so let's say some
like 250 okay really nice big number
then let's also put it centered and down
the middle okay that's great we've got
our nice big countdown number also by
the way when using text M Pro we can
easily add a whole bunch of effects if
we look down here we have the default
text mesh Pro material and over here we
can add an outline underlay and so on so
that's really great however there's one
very very crucial thing when you want to
add some effects always remember that
the effects are being apply to the
material meaning any text objects that
are sharing this material all of them
will modify so for the most most part
usually you don't want to modify the
default material if you do then
everything using this default material
will change like for example I want to
add a nice thick outline to this one but
over here I've got some regular text
that is also using the default material
so if I now add an outline and I
increase the thickness and there you go
those also got an outline as well as
this and if I want to downlo and make it
quite a lot bigger there you go all of
them modify because all of them are
sharing the same material so usually you
don't want to modify the default
material if you want to add some kind of
special effects always make sure to
create a brand new material beforehand
so over here let's remove the outline P
back on the dilation and let's go up
here to create the brand new material
first we need to find our font so over
here on the font asset we can just click
on it and we can see it over here
highlighted on the project window so
it's inside the textmesh pro folder the
resources fonts and so on so here is the
default font and inside this one is the
font that we're using now this font
there's a nice little arrow icon and
inside we can see the default material
so let's duplicate this material
although it's important make sure you
duplicate the material and not the font
so with this material selected I'm going
to press contrl D and there you go it
duplicates the material and over here
let's give it some name so let's say
this is the material that I want to use
for the start countdown so there we go
just like this also one very very
important thing the name of the material
needs to include the font name otherwise
it won't show up for example if I get
rid of this The Liberation Sans SDF if I
name the material just like this and now
I look over here on the countdown text
look on text mesh Pro here is the drop-
down menu for selecting material and
over here note how that one does not
show up so it is extremely important in
order for it to show up in here it needs
to have the same staring name so over
here if I rename this material put
Liberation SS SF and then the name and
now back in here now look and yep now I
do see my material okay so that's great
and now over here we can add what kind
of effects we want and it will only
affect this one and not any others okay
so for this one let's add a nice outline
and let's make make some nice thick
numbers so over here on dilation let's
diate by quite a little bit then for the
outline color let's put it maybe on a
blue something a bit like this okay
let's push it back just a little bit
okay I think that looks pretty good now
if you want you could add even more
effects to this I made another video
covering how to use custom Textures in
your font doing that you can just import
the font directly into Photoshop and
edit it with all kinds of effects for
example that method is exactly what I
use in my game hyperight to make the
head counter look really nice I also
have a tutorial specifically on that so
if you want even more custom text
definitely go ahead and watch those
videos but anyways here we have our
countdown text looking pretty nice now
the number itself will be written
through code so let's do that let's go
into our scripts into our UI folder
create a brand new C script for the game
start countdown UI okay let's select the
parent object and attach the script now
here first thing we need is a reference
to that text object so let's add a
serialized field private and again
remember what I mentioned a couple of
lectures ago with regards to the types
so we want text mesh Pro Yugi we want
this one so it's going to be our
countdown text and now for updating this
text basically we just need to know the
game state so we need to know when the
countdown should show up and as usual
let's use some nice events so over here
on the kitchen game manager let's fire
an event whenever the state changes so a
public event event
handler let's call it on State
changed okay just like this no need for
the arguments so let's go down here
whenever the state changes let's just
invoke this event so invoke this tars
empty so we change in there change in
there and change down there okay that's
it so now over here on the game start
countdown let's do a private void start
and on start let's go into the kitchen
game manager access the instance listen
into the onate Chang event as usual
write some nice clean codes let's rename
this to the kitchen game manager so when
the state changes we basically want to
show this if we are on the countdown to
start so let's go here to the kitchen
game manager and let's make another
function so public bow is countdown to
start
active and we just return if the
state equals the state. countdown to
start okay so that's a nice symol
function and on the U script if the
kitchen game
manager if this one do is countown to
start
active if so then let's show if not then
let's hide so else let's do a hide so
let's make these functions so private
void
show and a private void hide and on this
let's just do the usual thing so game
object set active into true or over here
set it into false and on start right
after we subscribe to the event let's
also hide it by default okay so that's
the basic logic for showing or hiding it
and now for the timer text technically
over here once inside the countdown to
start we could fire an event on every
single update that would work but it
would have some unnecessary overhead so
instead another option is just make a
function to expose it so let's go here
make a public return a float get the
countown to start
timer and we just return the countdown
to start timer very simple so then over
here on the UI script we can just make a
regular private void update and on
update go into the countdown text in to
set the text and let's go into the
katchen game manager and let's get the
countdown to start timer and just do
ait2 string okay so that's it super
simple so on update we're going to
constantly update the timer so let's see
if this works back here in the editor
let's just make sure to drag the
countdown text reference and let's set
on play and okay waiting to start and
after a bit yep there you go there's the
number it's currently on countdown and
now the game is playing so to showing
High it did work although the numbers
seemed quite a bit odd that's because
over here on the we have wrapping enabl
so let's just quickly disable this and
let's test again so there we are waiting
to start and there you go there's our
countdown 3 2 1 zero and there you go
game play okay so it did work now of
course as it comes to the Visions it
depends on what you want for example if
you want to limit the decimals you can
use over here the two string this one
can include all kinds of string formats
for example for displaying just two
decimal places you can add the string
format
F2 let's see what this looks like
waiting for the countdown and there you
go now it does Show with two decimals
okay so this is one approach
alternatively another format you can use
is number sign Point number number and
let's see this
one and yep there you go now it looks
like this so as you can see there's lots
of things you can play around with when
it comes to the two string formats but
in our case I don't really want any
decimals I really just want to see whole
numbers so for that let's just seal out
this number so a methf do seal
let's seal this one out and then just do
a two string okay let's see so wait a
bit and we got three two and one and
there you go the game is playing all
right awesome so here we have our
waiting to start and the countdown to
start all of that logic is working
perfectly now the next thing we need is
to handle the game end so let's do that
in the next
lecture hello and welcome I'm your code
monkey in this lecture we're going to
handle the game over State now for the
game over State this is obviously a game
design question for example you could
make it so that each recipe had a timer
attached to it and the player had to
create that recipe within the time limit
then if they failed enough recipes you
could trigger some kind of game over or
for something more simple let's just do
exactly what we did for the game start
let's just do a basic countdown timer
after the game is over let's pop up a
game over window and show how many
recipes a player delivered so let's do
that let's go into our canvas and inside
make an empty game object call it the
game over UI then over here let's
stretch it to occupy the entire parent
like this now inside let's begin by
making a UI image this is going to be
the background let's put it in black
with just a little bit of transparency
and let's also stretches to occupy the
entire thing so just like this then
let's make some text so let's make a new
UI text call it the game over text and
let's say just game over let's set the
width and height both at zero then down
here disable wrapping put it centered
let's put it pretty big so maybe 135 put
it a little bit higher then for some
more text let's duplicate this let's
call this the label recipes delivered
text and over here we just say
recipes
delivered let's put this one a bit lower
and quite a bit smaller say on 50 okay
and also on this one let's put it in Bal
then change the color a little bit okay
next let's make yet another text this
one is going to be for the final number
so let's call this recipes deliver text
and this one is just going to have
whatever number of recipes we delivered
and let's put it over here and quite a
bit bigger okay so this is the game over
window that we want also quick note like
I mentioned previously the Sorting order
over here on the UI is based on the
ordering the hierarchy so for the game
over we want this one to show up on top
of everything else so make sure the game
over is the last one over here on the UI
make sure it is the bottommost child on
the canvas okay now let's make a game
object to run this so let's create a
brand new script game over UI let's go
into the object wait for the compilation
and let's drag the script okay now here
the only reference that we need is just
for the text so let's just make a
serialized field of type text mesh Pro
UI for the recipes deliver text here in
the editor let's just drag that
reference okay now let's make some show
and height functions and also show it
just on the game over so really we're
going to do the exact same thing that we
did over here on the game start
countdown so let's actually copy exactly
this let's go into game over UI pass the
exact same thing Okay so we've got the
show and height functions we test and
then over here on the state change
instead of showing this one on the
countdown we want to show it on the game
over so let's go over here and just make
another function so public bowl is game
over and we just return if the state
equals the state. game over okay that's
the function so over here if we are is
State game
over if so then we show if not we hide
okay the last thing we need is just for
the text so this is going to be the
recipes delivered text so we're going to
set this to something which really means
that we just need to keep track of all
the recipes that have been delivered so
let's go here onto the delivery manager
script and let's just keep track so just
a simple in so a private end for the
successful recipe
amount and then whenever we have a
recipe success so let's go here into our
delivery recipe function whenever we
have a success let's just increase this
by one okay so that's it now we just
need a function to expose this so we pin
for the get the successful recipes
amount and just return the successful
recipes amount okay so finally back here
on the game over UI let's just printed
so go into delivery manager access the
static instance and get the successful
recipes amount and and of course we need
the string so two string except for this
one this is never going to change after
the game is already over so let's not do
this on update that would be quite
wasteful so let's just do it up here so
as soon as we have the game over we show
we print the recipes and that's it okay
so let's test so here we are waiting for
the timer and let's wait and just wait 5
seconds for it to finish and we should
see a zero so let's just make sure that
works so after a little bit of time yep
there you go we've got breast piece L
zero okay
now back here again let's try to deliver
some recipes now so let's try and make a
cheeseburger try to deliver that cut
this one pick up this one pick it up put
it in there and okay quickly all right
good and there you go we've got a one
all right Awesome everything worked
perfectly let's just add one more final
element right now we cannot see what is
the time left in the game so let's add a
nice lock element so over here on the
canvas let's make another empty game
object
let's name this the game playing clock
UI and let's also put it behind the game
over UI so let's put it above on the
Hier key so that it shows up behind in
order to be able to see what we're doing
let's also just hide the game over UI
but only here on scene view so let's
click on the I icon okay so here we have
our window let's just anchor it on the
upper right corner so let's put it
somewhere in there then inside let's
create a new UI image quality background
for the Sprite
let's go with the circle Sprite so let's
click on the I icon to show all the
default Sprites and let's use the one
included with the circle so you have
this one let's also add a nice little
outline so let's put it on 2 two with
full Alpha and let's also add a nice
shadow just nice visual so on five - 5
like that and for the color let's also
put it some kind of dark ray okay so
this is our background now let's
duplicate this so contrl D and let's
rename this one the timer image and for
this one let's give it a different color
so maybe something like a blue so
something like this okay and now over
here on the image type instead of simple
let's go with fill let's choose radial
360 okay great and now over here we can
play around the fil amount and this will
be our timer then you can set it up
however you want for me I'm going to
choose to start from the top so as it
starts the timer is going to count down
until the end okay so that's great now
let's make the script to run this so
let's create the Brand C script script
same thing the game playing clock UI and
over here let's just attach a script so
now all we need is reference to our
image so let's make a serialized
field private image let's make sure to
use this one the image inside Unity
engine. UI this is going to be our timer
image okay like this back here in the
editor let's drag the reference all
right now that we have this we need to
ask the game manager to get the timer
normalized so let's go over here onto
the kitchen game manager and let's make
a function to return just that so a
public float let's call it get playe
timer normalized or game playing timer
actually just to match a
state so get this one and up here we
have the playing timer we just need to
define a maximum in order to be able to
calculate the normalized value so let's
duplicate this call it the game timer
Max and set this one to 10 and this one
leave it like this and down here when we
change the timer when we go into game
play let's set this one equals this. Max
that way we only Define the timer just
up here okay so with that now down here
we can do the compilation so we can
return the game playing timer divide by
the game playing timer Max except just
like this going to be inverted because
for the game playing timer we're
counting down instead of counting up so
all we need to do is very simple just
reverse this so just one minus just like
this okay great so we have this function
and then over here on the clock just go
private void update and on update let's
go into the kitchen game manager the
instance let's get that and we're going
to use that on the timer image. fill
amount okay that's it super simple let's
see okay here we are on the waiting to
start all right waiting and as soon as
we start y there you go there's the
timer going and we can see it constantly
increasing so it's at the halfway
point and just a little bit more and
there you go yep we've got the time over
and we have our game over all right
awesome so over here we implemented a
really nice game over State we have a
playing timer with an icei element and
when it ends we get a game over window
showing a bunch of stats now with this
working the next task is to have some
kind of main menu so we can play again
after the game is done so let's do that
in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
make a super simple main menu and the
loading system okay so every game needs
a main menu so let's build one let's
begin by making the scene so let's go
into our scenes and create a brand new
scene call this the main menu scene and
okay here's our default scene now over
here for the most part you really just
want some basic buttons so nothing too
special so let's create a brand new UI
canvas and let's set up as usual so
screen space overlay yep then let's go
with scale with screen size 1920 by
1080 and let's match with the height
okay so there's our canvas now inside
let's make an empty gam object name this
the main menu UI
let's stretch it to occupy the entire
thing so 0 0 on everything okay now
inside let's create a brand new UI
button let's name this the play button
then inside for the text let's say play
Let's size the button to be quite a bit
bigger so let's say 450 by 150 and on
the text itself let's put it in bold on
a font size quite a bit bigger let's say
70 then let's also change the color
let's put the text in White and the play
button over here the normal color for
the image let's put it on a dark ray
then also over here on the button
background let's add a nice outline
let's put it on full black say something
like 3 three then let's make a Shadow
and for this one 5 - 5 okay so that's
our basic button let's just anchor the
button so choose the play button let's
anchor it on the lower left corner and
let's push it just a bit like this okay
pretty simple now let's duplicate this
one push it a bit lower let's also make
it just a tiny bit smaller so just 120
this is going to be our quit button so
let's rename this to the quit button and
inside for the text just say quit and
put a bit lower on the font size okay
like this okay so we have the two basic
buttons that we need now let's make the
script random so let's make a script
with the same name so main menu UI so
let's go into our script UI folder
create new script for the main menu UI
let's attach the script and open okay so
now here let's begin by making
serialized fields for our buttons so aiz
film private of type button inside
unityengine.ui this is the play button
and then we have another one for the
quit button okay back in the editor
let's drag the references so that's the
play button and the quit button okay now
here in the code let's add some
listeners to these buttons so let's do a
private void awake and on awake let's go
into the play button and go into the
onclick event so the event when the
player clicks on the button and let's
add listener and now we pass in The
Listener now over here to do this we can
add a function so we can make a private
void Play Click we can define a function
kind of like this and over here add it
as a listener so that's one approach or
another alternative that personally I
like to use is to use what is called a
Lambda expression so instead of defining
an external function down here we just
go up here and directly we Define a
Lambda so we open parameters to display
the parameters for the function which in
this case we have none so just open and
close then we do a nice little arrow and
then we have whatever we want to be our
click code so both the code that I have
here and one that I have here both of
these are exactly the same thing this
one is called the lmda expression which
is also a type of delegate definitely go
ahead and watch my video on C delegates
in detail it's yet another extremely
powerful C feature I find them
especially useful especially over here
to setting the click listeners there's
no need to make another function just
use a Lambda expression and that's it so
over here I'm going to use that instead
of an external function Okay so we've
got the play and then let's also listen
to the quit so on the quit button the
exact same thing okay now first on the
quit button it's actually very simple we
just go into application and we call the
quit function this will quit the game
that's it very simple although one note
if we actually test it like this so here
is game playing and if I click on quit
and nope nothing happens now the logic
is actually working we can see visually
that the button is changing state so we
are indeed capturing clicks however when
the game is running inside the editor
calling that function the application
now quit doesn't do anything
but if this were a full build then
clicking on that would indeed close our
game okay so now for the play button for
this one it's also very simple we just
need to go inside the scene manager
which is inside Unity engine. scene
management we just need to go inside of
this one and we call load scene this
function will load a certain scene and
for loading we can either use the scene
build index or we can use the scene name
like I've mentioned several times string
names are horrible although in this case
the alternative using an INT is also not
very good just the number is very hard
to read the code and be able to know
what scene this is loading so there's
one better approach that I prefer to use
but first over here let's just use the
index just for testing so we're going to
load the scene on index one so just like
this and then here in the editor let's
go into file and build settings and over
here we see the scenes in our build
right now we just have the game scene so
let's just add our scene so let's drag
the main men scene and drag it on there
and also let's make sure it's on the top
of the list basically the first scene is
the one that will be loaded as soon as
the game starts so let's drag it right
up top just like that then over here on
the right we see the index so by loading
the scene on index one we're going to be
loading the game scene okay so with this
let's test so here we are and if I click
on play and Y there you go it does load
the main scene okay great everything is
working so this is the simest way to do
scene loading however this method does
have one issue it's not super noticeable
on a game of this scale because loads
pretty quickly but like this note how
when we click on play there you go
everything freezes for a little bit
while the game is loading like I
mentioned in this case the freeze is so
small so not necessarily an issue but if
the game was much more complex then the
player would be staring at a frozen main
menu for perhaps 30 seconds that would
not be good one way to avoid that is
actually very simple basically it's what
I already covered in detail in the scene
loading video that video was made quite
a while ago but it's still very much up
to date here we're going to do pretty
much the same thing so we first create
the scene just empty just saying loading
and then from that scene we load the
final scene that way the game stays
Frozen on a scene that says loading
which is much more clear to the player
so let's do that first let's make our
scene so inside our scenes folder let's
create a brand new scene call this the
loading scene okay let's go inside and
now in this one we want this one to be
fully black so let's go into the main
camera and scroll down over here under
environment and instead of rendering the
Skybox for the background let's go with
a solid color and let's go with full
black okay there's our black main camera
now let's make a canvas so a new UI
canvas let's set it up as usual so scale
with screen size 1920 by 1080 and match
with the height okay then inside let's
just make a simple text object so just
say text then over here let's say just
loading let's put the text width and
height on zero put it on Bold let's make
sure to disable
wrapping and push it over there on the
side and maybe increase the font size by
a little bit okay there you go we have
our very basic loading screen now we're
going to load this scene and then whil
on this scene we're going to load the
final scene although also one very
important thing related to loading
scenes is you need to remember the
lifetime of the objects regular game
objects like for example the ones that
we see here in the hierarchy these get
destroyed when you do a scene change so
for the goal that we're trying to
achieve we need to load this loading
scene but then also somehow transfer
data so that the loading scene here
knows which one is the final scene now
you might think that over here on the
main menu we could create a game object
attach a script that would hold the
reference to the final scene but like I
said game objects get destroyed as soon
as we load the loading scene so for
transferring data between scenes we
can't really use a regular script on a
regular game object now one approach is
to use the don't destroy on load this is
a Unity function that helps you stop a
particular script or game object from
being destroyed that way the object
won't purist through scene changes so
that's one option but another option
that I prefer is very simple let's just
make it loader class so let's create a
new C script call this loader and over
here let's go ahead and make this class
a static class and we are not going to
extend mod Behavior so just like this
basically by making it static it means
that this one is not attached to any
specific instance of an object this
class cannot be attached to any object
and cannot have any instances
constructed then inside we can add
static functions in fields like for
example a static in for the Target scene
index so now this field we could set
this field from over here on the main
menu UI and when we would load we would
not be resetting this field also here I
should point out one quick thing you can
make field static without making the
entire class itself static making the
class static is just a good approach if
the entire thing if everything in this
class is also meant to be static if you
don't make it static then you can have
regular Fields
here you can have both static and
non-static whereas if you make this
static then you're going to have an
error because you cannot have have
non-static Fields so this is another
clean code thing if it's only meant to
contain static logic then make the class
itself static okay so we have a static
field for our Target scene but as usual
we don't want this to be a public field
we don't want the main menu to directly
write to this field so let's make this
class the only one responsible for
anything related with scene loading
soste let's make a function so a public
static void call it load and for a
parameter let's receive a string for the
Target scene name
then over here we load the actual scene
so let's go into the scene manager and
load the
scene and let's pass in the Target scene
name okay that's it and then over here
on the main menu UI instead of directly
loading a scene let's go into the loader
and call load and pass in the scene name
so that's the game
scene okay so this is what we're going
to do that's good except it's obviously
not good over here we're using string
names that's horrible we should never
use this so let's avoid using strings as
much as possible and and one simple way
is to just Define an inum for all of our
scenes so let's go here on the loader
and let's define that so a public inum
let's call it scene and for all of our
scenes so we have the main menu scene
then we have the game scene and the
loading
scene okay so then down here on this
function instead of receiving a string
we just receive a scene for the Target
scene and we use the target scene
although of course un API does not
support loading our custom enum it has
to be an index or string so the simple
approach is just to convert this one
into a string that's it so the only
thing you need to make sure is that the
inum values over here match the actual
name on the actual scenes perfectly so
don't make any mistakes keep it case
sensitive so don't do this make sure
everything matches perfectly okay so
just like this everything should already
be working the same as previously so the
main menu calls that let's actually just
use that so let's use scene. game scene
so on the main menu we do this and on
loader we load the scene okay let's test
here is the main menu and if we click
and wait a bit and Y there you go it
didn't load the game scene okay great so
everything still works the same as
previously except now all of the loading
logic is inside of this class and over
here let's Lo a loading scene in the
middle basically when we have this
function to load a final scene let's
first off set this field so this one
instead of being type in let's make it
of type scene and this is going to be
the target scene and let's make it
private okay so when we have this
function let's set that field although
here remember how this is a static class
so in order to access this field we need
to access it through the class name
because over here we also have a local
variable with the exact same name so
let's access the loader. target scene
and set it to the Target scene so again
don't be confused here you can even use
Visual studiio and put the cursor on top
to see what object represents what so
you can see the loader. target scene is
referencing this field whereas this one
over here is referencing the local field
so we want to assign the member field to
the one that we received as a parameter
okay so we store that and then let's
immediately load the loading scene so
scene manager let's load the scene and
we're going to
load the scene. loading scene. two
string okay so we're going to load that
and now here comes the tricky part if we
do this so if we load the loading scene
and then immediately load the target
scene if we do it like this it won't
actually show the loading scene we're
calling these functions one right after
the other so it will load one and
immediately the other basically we need
to wait at least one frame to render so
that the loading scene is visible and
then we can load the final scene so
let's make a script to do a very simple
job let's create a brand new C script
for the UN loader callback and now let's
go inside the unloading scene so this is
important let's make this on the loading
scene not the main menu or the game
scene so over here let's create an mty
game object for the loader call back
let's reset transform just keep things
nice and clean and let's attach the
script so the loaded comb back okay and
on this script we want to basically just
wait for the very first update so let's
say a private ball is first update and
we start off as true actually so is the
first update is true then we do a
private void update so if it is the
first update if so then let's set is
first update to
false and we have the first update
although technically I should point out
that we don't really need this we're
going to load right away so either way
it will only run One update but still I
like to add this just to make the logic
perfectly clear
basically if it is the first update then
let's call a function on the loader so
on the loader over here let's make a
function public static void call it
loader
callback okay we have this function so
over here on the loader comback let's
just go into the loader and call the
loader comback function all right so
basically now here we have this function
that is going to be triggered on the
first update so we know for certain the
unloading scene has been rendered so
it's over here that we want to load the
actual final scene okay that's it here
we have a super super simple loading
system just make perfectly sure that the
loader call back with the script this
one only exists on loading scene it
should not be on any of the other ones
so let's test and for that let's go
inside the main menu scene okay and now
let's head on play okay so here we are
on the main menu now if I click on play
and actually here's the thing that I
forgot so make sure you don't forget
this we need to add the loading scene to
the builds in order to be able to load
so let's go up here into the build
settings let's go into the project drag
the loading scene like that okay so now
let's test so here we are on the main
menu let's head on play and there's the
loading scene after a bit yep here we
have our game scene all right awesome so
with that everything is working
perfectly all of the logic is working
great now that it all works great let's
just make a nice proper visual for our
main menu so for that let's go inside
the game scene and over here let's copy
a few things so let's pick up the floor
object and let's also pick up the global
volume with the post pressing so let's
copy both of these let's go into the
main menu scene and over here let's
paste both objects okay now let's also
drag some player visuals so let's put
this in 3D go back down to the floor and
let's pick up some visuals so let's go
inside our assets on the prefabs visuals
let's find over here the player visual
again make sure you drag the visual only
we don't want any logic components and
by the way this is yet another great
benefit of separating the logic from the
visuals right now it's super simple for
us to play some players here because we
have just the visuals completely
separated from the logic okay so on the
visual let's just make it look at the
camera let's position a bunch more
players so let's duplicate this and put
one to the side we're going to move the
camera in a bit but now let's just place
them and in included assets there are a
bunch of materials so over here we see
the player body then we've got a blue a
green and a red like I said this first
course is on making this game in single
player but the goal is to then make a
second course after this one on
converting this game into multiplayer so
that's why I included multiple colors so
let's just drag these let's let's go
into this player Visual and on this one
make it blue so on the head and on the
body then on this one on the side here
let's make this one green so green there
and green on the head and for the one
behind let's make this one the red one
so put it in red and in red Okay so
we've got our nice four players now
let's also add a camera so we're going
to have the camera kind of like this
kind of From Below looking upwards I
think that looks pretty good for that
let's use S machine so let's go into
game object go into cin machine and
let's create a brand new virtual camera
okay like this let's just push it up a
little bit okay so this is our nice
composition now on the virtual camera
let's just go ahead and add some noise
so let's add basic multi channel pein so
let's do it just like we did when we
first added C machine so let's use a
handheld normal mild and now let's just
play around these fields which by the
way you can do that while the game is
playing so let's head on play and over
here you can play around all the fields
although actually defaults already look
pretty good but let's put the free
frequency maybe a little bit less and
the amplitude maybe a little bit bigger
so just some nice little Sway and by the
way if you make any changes to the C
Machine virtual camera and if now you
stop playing it will actually lose those
changes but over here on the virtual
camera there's this nice toggle save
during play so if you tick this and now
you exit play mode and there you go
those changes were saved okay great now
let's just make sure to untick this so
we don't accidentally modified okay so
here we have the basic Vision that we
want finally there's also a game logo in
the included assets so let's just go
into our canvas into our main menu let's
create a brand new UI image let's assign
the logo Sprite then let's just position
it on that corner so let's move it all
the way up there we can anchor it to the
top left corner and let's make it a bit
bigger and by the way on something like
this if you play around this it might
get a bit stretched so if so over here
on the options on the image you can tell
on this one to preserve the aspect ratio
so that way even if you stretch it won't
actually be stretch it will always be
perfect okay just like this okay so here
we have our basic main menu it's a basic
setup but it looks pretty good and with
that we have built a nice main menu
along side with a loading system so I
can click on play it goes into the
loading scene and then into the game
scene so that's great the next thing
that we need is some kind of pause
button so let's do that in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
add a pause button with a p window that
also has the ability to quit back to the
main menu and in doing so we're also
going to solve some sneaky issues with
loading okay so here in the main menu we
can click the play button in order to
load the game and yep everything works
now I'm in the game but now let's say I
want to pause the game for a bit or quit
back to the main menu right now there's
no way so let's do that let's go here
onto the game scene and first let's send
on the pause and for that we're actually
going to need some input so let's first
go inside our player input actions let's
open this and then over here let's make
a brand new action let's name it the
pause for the action TP let's go with
button okay and for the the bindings
over here let's go with escape and
actually if we use the same method that
we've been using if we listen and press
on Escape nope doesn't work because
Escape just cancels it so instead we
need to use a search bar here Search for
escape keyboard just like this okay
great now again as always let's make
sure to save the asset and wait for the
compilation to happen there it is so now
here on the game input class let's
listen to it and far the event as usual
so go into the player input actions the
player action map let's go into the
pause action and listen to the performed
event and when this happens let's fire
off an event so a public event event
handler let's go on pause
action and then down here we're simply
going to invoke this
event okay just like this now for
listening to it here's a question where
does that make more sense should we do
it over here on the player script or
perhaps over here on the kitchen game
game manager I think over here on the
game manager makes more sense since a
pause is more related to the game itself
rather than a specific action by the
player so let's head it over here let's
first of all listen to the event so
let's do a private void start and on
start let's listen to it so let's go
into the game input and we didn't
actually make it a Singleton yet so
let's do that over here let's make a
public static game input for the
instance with a public yet and a private
set then down here on a wake let's set
instance equals this okay there's our
Singleton so now back in the kitchen
game manager let's go into the instance
and listen to the on pause action
event and again let's rename this to
give it a proper name so this the game
input on pause action okay so here we
have it when we have this let's call
some kind of pause game function so
let's define this let's go to the end
the file here and over here let's make
that function so a private void pause
game and over here we're going to pause
the game now for pausing doing this is
actually surprisingly easy basically all
of our logic is using time. time for
example over here on the player script
we have our movement speed yep then we
get the inputs and over here on the
handle movement function yep for the
movement distance we have move speed
multiplied by time. time for another use
case over here on the stove counter
we've got a frying timer and how we
count it down again is the same thing
time. the time well it turns out that
behind the scenes time. the time
actually already has a multiplier when
you you access this it is after that
multiplier calculation so over here on
the pause game function we can just go
into time and we can modify the time
scale this one is the multiplier so if
we just put this at Zer F then that's it
this is going to pause all of the other
Delta times so let's test so here we are
pay attention to that and the countdown
timer and I press on escape and there
you go everything pauses the countdown
timer pauses over here the script pauses
and I can no longer move nothing works
everything is perfectly paused all right
Awesome everything works except when one
problem obviously right now we cannot
unpause if I press Escape it's not
unpausing so let's do that over here on
the kitchen game maner let's add a
simple ball so a private ball let's call
it is game paused and let's defold it to
false okay so is game paused and then
down here on the pause game function
let's simply flip this one so we set
this one equals not this one so that is
going to flip that buum and then we
check if the game is paused if so set it
to zerf and if not then we're going to
set the time. time scale back into 1 f
okay so now this should pause and
unpause so let's actually rename this
function since this is no longer just
going to pause let's rename this to
toggle pause game this going to pause
and unpause okay so let's test okay so
here we are everything is running now I
pause and there you go everything freeze
I cannot move the arrow is stop the
countdown is stop now I press again and
there you go nice and resume all right
great so all of the logic is working
perfectly the only thing we need is
really just see Visual and as usual
let's separate the logic from the
visuals so let's go inside the canvas
let's go into the scene View and inside
the canvas let's create an empty game
object call it the game pause UI then
let's stretch to occupy the entire
screen so zero on everything okay great
now inside let's first of all add a
background so a new image name this the
background let's once again stretch to
occupy
everything and on the color let's put it
in black with just a little bit of alpha
okay just like that then let's set some
text so let's create a brand new UI text
let's name it pause text and in here
let's just say paused let's just make it
big so the width and height both on zero
let's disable wrapping Put It Center
down the middle and let's increase the
font size by quite a bit and put it in
bold and let's also change the color
maybe a nice yellow something like this
okay that looks pretty good let's just
lift it up by a little bit now let's
make a script to show this
so on the UI folder let's create a brand
new C script call this the game pause UI
let's attach it and open now here let's
do the usual thing so let's make two
show and hide functions so private void
show and then a private void
hide so on the show game object set
active into true and on the hide set it
into
false okay that's it pretty simple now
we need to know when to show our high
these functions so over here on the
catch and game manager let's make two
events to do that so let's go up here
make a public event event
handler and let's name this on game
paused and another one for oname
unpaused okay we have both events then
down here on the togg on pause game if
we have this one time scale zero that
means we have pause so let's invoke the
oname pause this event ours. empty okay
and on this one let's trigger the other
one so on game
unpaused okay we've got the two basic
events now back here on the game pause
UI let's listen to it and as usual let's
do it on start so private void start
let's go into the kitchen game manager
access the static incense and let's
listen to the on game paused and then
going to listen to the other one so the
instance on game unpaused so listen to
both of them and as usual let's write
good clean codes and let's rename this
so kitchen game manager and on this one
the same thing so also the kitchen game
manager okay we have both and when the
game is unpause then we want to hide the
pause window and when the game is paused
then we want to show the pause window
and finally of course we want to hide it
by default so over here on start after
we had listeners let's just hide it okay
so that's it that should work so let's
test so here we are everything is
running now press the pause and there
you go got a nice paused window press
again and there you go everything
resumes okay great so the last thing
that we want is just a button over here
to go back to the main menu and let's
also add a button to resume without
having to press the hotkey so over here
let's create a new UI let's make it a
button this is going to be the main menu
button now let's make it quite a bit
bigger okay width and height of 30 and
80 let's put this one quite a bit down
there and inside for the text this one
is the main menu let's put the color in
White and the background for the button
let's put this one in a dark ray and
let's also just for fun add a nice
outline and let's also add a shadow for
the outline let's put it on full Alpha
and let's put it on about 3 three and
for the effect on the shadow 5 - 5 okay
so that add a nice outline and nice
shadow and then for the text itself
let's put it in bold and raise it by
just a little bit okay just like that
looks pretty good so this is the main
menu button and then let's also make so
duplicate this let's make this one
rename it this is the resume button and
inside on the text let's say resume okay
we have our two basic buttons so let's
hand them in the script so over here
let's add as usual a serialized field
private of type button so that's inside
unityengine.ui
so it's for the resume button and then
we're going to have the main menu button
okay let's save the script and back in
the editor let's drag those references
so that's the main menu button and the
resume button okay so now for these
let's add the click action so let's do a
private void awake and on awake go into
the resume button the on click and let's
add a a listener so this going to be our
listener and same thing for a main menu
button so main menu now for the main
menu this one is super simple let's just
go into the loader and call the load
function and we're going to load the
main menu scene okay that's the main
menu very simple and for the resume this
one is only going to be clickable when
the game is paused so we can just
trigger the same function on the kitchen
game manager to toggle the pause so
kitchen game manager the instance and
toggle the pause game this one is
actually private so let's go to it and
let's make this public so we can call
from there okay that's it super simple
let's test okay so here we are and let's
pause the game and now if I click on
resume yep there you go it does work
everything resumes and now pause again
and now let's go back to the main menu
loading and yep there you go back in
main menu all right awesome so
everything works perfectly however
there's one sneaky issue here you can
already see the issue by seeing that all
of these animations are still but let's
click on play and look that issue
everything is still frozen I cannot move
the character and over there the Shader
that one is completely Frozen so the
time scale is still set to zero
basically we need to manually reset it
and the simplest way to do this is
really just in the main menu so we can
go here on the main menu Y and we can
just use this as our reset function so
let's just go into time. time scale and
let's set this one back into 1f that's
it that's the only change let's test so
here we are let's pause let's go back
into the main menu
and we can see the animations are indeed
playing and if we go back into play and
if there you go everything works
perfectly we can pause and yep here we
do see one of the other two sneaky
issues left basically it has to do with
scene loading and cleanup so the first
one is on input over here on the game
input class we are constructing our
player input actions and we are
listening to these events and
technically this object the one where
the game input is attached this object
is going to be destroyed when the scene
changes
however this object that we're creating
this instance of player input actions
this one does not get destroyed
automatically so that is why when I went
into the pause menu again for the second
time over here we've got a missing
reference exception basically the player
input actions of the previous game is
trying to show the pause window also of
the previous game which has since been
destroyed so obviously we have a missing
reference exception because that object
no longer exists so in this case we have
two options to solve this one option is
we can just unsubscribe to these events
Unity mono behaviors have a really nice
comback called on Destroy so over here
private void on Destroy so this is the
default one this one is called when the
mono behavior is
destroyed so we can go into this one and
we can manually unsubscribe and the way
that you unsubscribe is you just do
minus
equals so this would solve that problem
because when this object is destroyed
it's going to unsubscribe from those
events so the next time it will no
longer trigger so that would fix it
however on the game input class we are
still creating a new object of this type
I'm not 100% sure how the input system
works in the background so perhaps this
object might stay in memory which is not
good so another approach we can do or
perhaps in combination with this is we
can unsubscribe and then we can properly
dispose of this object how we do that is
very simple let's just go into the
player input actions and we just call
the dispose function that's it this
should clean up that object and free up
any memory so let's test so here in the
game view let's pause let's go back into
the main menu now let's go back into the
main game and if I hit pause and Y there
you go we no longer have any errors okay
so that's good however now we still have
one more potential issue and this one
has to do with Statics like I mentioned
before Statics belong to the class and
not any instance of that class so that
means that static Fields will not be
destroyed or reset when the scene
changes in the case of our loader here
where we have a private static field
this one the fact that this one doesn't
reset automatically that was a good
thing that's what allowed this to make
the unloading system but in the case of
maybe static events that might not be as
good it might mean that we might be
keeping some saate from the previous
game which might cause everything to
break so basically we have a similar
problem to what we had in the input
where some logic from the previous game
might be affecting the next game in all
the code that we wrote the main place
where we use Statics were in the
Singleton and these are going to be
cleared automatically when the
underlying instance object when that one
is destroyed so these do not cause any
problems however for example over here
on the cutting counter we've got a
static event when the scene changes this
will not be cleared so this will still
have the same number of listeners we can
actually see how many listeners there
are by printing it so let's go down here
before we're invoking the event let's do
a debug. log let's go inside the on any
cut event and over here we can get the
invocation list this one is a list of
all the functions that are listening to
the this event and we can just print out
the link to see how many listeners are
listening to this event so let's see
what this returns okay so over here
let's pick up some cheese and slice it
and if I look in the log yep there you
go one there's only one listener okay
that's correct however now if I go back
into the main menu and now I go back and
I play again okay so let's play let's
just wait for the countdown and once it
countown ends pick up some cheese go
there slice it and there you go there's
the problem now we have two listeners in
this case doesn't really cause an error
because the tun listeners they're just
over here on The Sound Manager so we are
subscribing to this event and we're
doing the cut and playing the cut object
however if here we do something with
this transform like for example let's
just do a debug. log on this transform.
position if we do this here let's go
ahead on the first one let's slice and
okay that works let's go back into the
main menu now play again now wait for
the timer pick up some cheese go there
slice and if there you go there we have
our error that is because we are now
accessing The Sound Manager transform
and that one has since been destroyed so
if you do use static events like this
one here if you do that always remember
you need to manually reset that state it
won't happen automatically on the scene
load and one way that I normally do it
is just make a class responsible for
doing that so let's go ahead let's
create a brand new C Class let's call
this the reset static data manager and
for this one we want this one to run
only on the main menu That's only where
we're going to reset the things so let's
go inside the main menu scene let's go
there let's create a brand new mty game
object for the reset static data manager
let's reset transform just keep things
clean and let's attach that script again
it's very important that this object
only exists on the main menu then over
here we're basically just going to go
into any script and reset any data so
for that on all those scripts let's make
a function so over here on the cutting
counter let's make a public static
function let's call this reset Set
static data and in order to reset any
listeners let's just go into the on any
cut and set it to null that won't clear
all the listeners so we just do this and
then on this script let's do a private
void awake and on awake let's go into
the cutting counter under the class so
not any instance so we're going to
access the static and we're going to
reset the static data that will clear
all the listeners on The Cutting counter
all we need to do is make sure to do
this on every single static event that
we have so on The Sound Manager and by
the way here we can get rid of the
testing code here we can see all of the
static events that we're using so we've
got the cutting counter then we've got
the base counter and trash counter so
let's go here on the base counter and
paste the exact same thing and reset
this event okay and now let's go into
the trash counter so here on trash
counter same thing reset this event set
them all into null and by the way here
we have a warning that's because trash
counter extends base counter so
basically this is telling us that we are
hiding another function with the exact
same name in this case we do want to
hide it so let's actually make this new
to make sure that this one is a
different one just to avoid that warning
and same thing over here on the cutting
counter we also need to make a new okay
so that's it and now we just need to go
over here onto the reset static data
manager let's go into the base counter
and reset the static data go into the
trash counter and reset the static data
okay that should do it let's see so here
we are in the game let's pick it up and
slice it and yep we've got just one
listener that's good let's go back
outside back into the main menu let's
play once more and over here let's pick
it up again go there drop it and there
you go still just one listener because
we are now correctly eliminating all of
the previous listeners so this is the
one sneaky issue that you must be
careful with when it comes to object
Lifetime and Statics for static Fields
you need to remember that they don't
manually get cleaned up that's up to you
so that's something you have to keep in
mind but you can also see how easy it is
to solve now that this is solved let's
just go into the cutting counter and
just get rid of our testing log all
right so with all of that all of our
scenes are working so we can start from
here from the main menu and go straight
into the game then here we are in the
game playing normally we can pause the
game at any point from the pause screen
we can either resume or we can go back
into the main menu and from back into
the main menu we can once again play the
game from scratch and you there you go
everything works all right awesome now
the next thing that every game requires
is some options so let's do that in the
next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
create a simple options menu where we
can modify the audio levels okay so here
let's make the options menu so on our
game scene let's go into the canvas and
create a new MTM object let's make this
the options UI let's stretch out this
one to occupy the entire screen then
inside let's make a UI image once again
let's stretch out
everything let's put this one in black
and just almost full Alpha okay now
let's make some text so let's create a
brand new UI text
call it the options text then for text
let's say just options let's put the
width and height at zero let's disable
wrapping Put It Center down the middle
and put it quite a lot
bigger okay that's the options now just
move it slightly upwards all right now
let's make some simple buttons to handle
our audio controls we're going to make
it super simple literally just a button
we can click so inside the options UI
let's create a brand new button call
this the sound sound effects button then
let's make the button a bit bigger
something like this
okay and inside for the text let's say
sound effects and then we're going to
have a number for the sound effects
let's just quickly change the color so
put the text in White and the button
over here the button image let's put it
in a dark ray okay let's also make it
just a tiny bit thinner just like that
okay so this is the sound effects button
now let's duplicate this this one this
one is going to be the music button so
let's name this the music
button then inside for the text music
and then a number and that's pretty much
it so by clicking on either of these
buttons we're going to increase and then
Loop the volume so let's make a simple
script to handle our options window so
in our scripts inside the UI let's
create a brand new C script for the
options UI let's go ahead and attach a
script and open so here as usual let's
get some fields for our button so
serialized film private of type button
for the sound effects button and then
there's another one for the music
button okay both buttons now let's add
the click events so on private board
awake let's go into the sound effects
button and on the onclick let's add a
listener and we're going to do the same
thing on the music
button okay so now when we click we want
to change the volume so let's go go here
onto The Sound Manager and make a
function to modify the volume let's make
a private void change
volume and here we're going to increase
the volume by .1% so constantly increase
in 10% increments so that means we need
to keep track of the volume so up here
let's find find a simple private float
for the
volume let's default it to onef okay so
now down here we take the volume and we
increase it by 0.1f and now let's Loop
it back to zero now for looping usually
you do it using the modular operator so
here you could do volume equals volume
modu of 1.1 F that way when it gets to
1.1 f it would reset back to zero but
here since we're working with floats
which can have a bit of odd Precision
with this let's just do a simple if to
make sure that always works so if the
volume is above
1f if so then let's just reset it to
zero okay so here we modified the volume
and let's just make sure to use it over
here when we actually call the audio
source. playay clip at Point here we've
got a volume but this is the one that we
received as a parameter so let's
actually receive this one rename this to
volume
multiplier and we're going to basically
multiply the one that we receive in the
parameter by the one that we actually
store so this way on these functions
when we play a certain sound we can
still give an optional volume if we want
to make it louder or quieter than the
regular sound effects okay so we have
our change volume function now we just
need to call this from the options UI so
that means this one actually needs to be
public okay so now here on the options
UI we go into the sound manager access
the instance and call change volume okay
so that is going to change the volume
then we just need to update the values
on the options UI so let's make a
private void update
Visual and this one we need to update
the text so up here let's add once again
some more generaliz Fields so text mesh
Pro UI one for the sound effects text
and another one for the music
text okay we have both these then here
the sound effects text. text equals and
we go into The Sound Manager the
instance and then we need to get the
volume so over here on the sound menion
let's make a function to get it so we
public float return get volume and we
just return volume okay so then here
let's get volume except volume is going
to be a normalized value so rather than
showing .1 2.3 on the UI let's just
multiply the volume by 10f that way we
show between 1 and 10 okay then let's
just round out this
number and then add the text so here
sound effects and then we have the
volume okay so that's pretty much it and
up here when we change the volume let's
just just update the visual and let's
also make a priv void start and on start
let's also update the visual okay that's
it pretty simple now let's do the exact
same thing on the music except on the
Music Manager we named it music manager
but over here we just have an audio
Source there's no actual manager so
let's actually make one let's create new
C script for the Music Manager let's go
into the Music Manager object let's
attach a script and let's open so here
we really just need pretty much Exel the
same thing that we had so let's just go
here into The Sound Manager and just
copy these so on the Music Manager let's
paste them we need a volume so a private
FL for the volume just like this okay so
that changes the volume except again the
Music Manager this one the music is
constantly going to be looping so after
we modify the volume we need to update
the actual audio source so let's first
begin by grabbing the audio source audio
source and we just do a private boid
awake and on awake let's grab the audio
source get the component of type audio
Source okay so we have this and when we
change the volume let's go here and
update this volume okay that's it and
let's also default it to something like
3F okay good then in order to be able to
call this from the options UI we just
need to make it a s ton so as usual
public static Music Manager for the
instance and we have a public get and a
private
set and then awake just set instance
equals this okay so then here on the
options UI we can go into the music
manager the instance and change the
volume and afterwards let's update the
visual and down here on the update
visual let's do pretty much the same
thing so on the music text modify the
text to say music then we go into the
music manager and get the volume all
right that's it all this should be
working let's just drag our references
so back in the editor let's drag first
the button so the sound effects button
that's this one then the music button
that's this one then we have the music
text that's this one and the sound
effects test like that okay let's test
okay so here we are the music is playing
and as I click the music is currently
getting louder and louder and there you
go music is at max volume and if I click
again now the music is completely muted
all right awesome and the sound effects
also work so like this they should be
less louder than usual okay great so
everything works perfectly except
obviously we have one big issue the
options window is on top of everything
the goal is for the options window to be
kind of a submenu of the pause window
we want to have an options button on the
pause window that will bring up the
options window so let's do that let's
first hide the options window let's go
into the game pause UI and over here we
have these buttons let's just make one
more let's put it down the middle this
is going to be the options button and
inside let's modify the text to options
okay now let's setedit this script so
we're going to have another button so
this is the options button and down here
we're going to have another click so the
options button okay okay and when this
happens we want to just show the options
window so in order to access it let's
make this a single T So public static
for the options
UI a static
instance with a get a private set and
onw as usual instance equals this so
over here on the game posi y we go into
the options UI access the instance and
then call a show function so we need to
make this
so here on the options UI let's make
those so a public void
show and this one as usual just game
object set active into
true and then we have a private void
hide and this set active into false okay
we have both these on the other side we
show it and over here on start let's
also hide it okay
then let's also hide it manually so
let's add a button to close the options
UI so over here let's show the options
UI and let's make another button let's
put it on the bottom this one is a close
button and over here let's just say
close so then here on the options UI
just make another button the close
button and down here for the click
event we go into the close button and we
just call
hide okay so that will hide the window
how however remember that the pause
window can also be closed by just
pressing escape if we resume with a
hotkey it won't hide the pause window so
let's also make sure this one hides on
the same thing so we can do pretty much
going to the kitchen game manager the
instance and let's listen when the game
is unpaused so when that happens let's
hide this window so once again let's do
things nice and clean let's rename this
so the kitchen game manager and when
this happens let's just hide okay this
should work let's just drag all the
references so first here on the options
UI let's drag the close button and then
on the game pause UI let's drag the
options button okay so let's test and
yep right away the options window is not
showing that's great and if I press an
escape there you go there's the pause
window and if I click on options yep
there's the options window now if I
click on close back here back into
resume okay works now if I pause options
and now press on the Escape key and
there go it closes everything all right
great so everything is working fine
however we have one slight
issue the option does work so I can
modify this to change the sound effects
in the music volume so for example let's
mute the music and put the sound effects
on five so I put it like this but now if
I stop playing and I hit play again and
look in the options and nope there's the
issue basically the data is back to the
defaults obviously that is resetting
since we didn't actually save anything
so let's save it now in unity the
easiest way to save some data is using
player prefs so let's go over here on
The Sound Manager and when we modify the
volume over here when we do that let's
access the Unity Player prefs and over
here we've got a bunch of set functions
so we can save a float and int or a
string this one as you can see takes a
string and a value so this is pretty
much essentially just a dictionary now
for the key as you can see it's a type
string but again we should not be using
strings directly so let's go up here in
our to make a proper constant so a
private con string let's call it player
prefs sound effects
volume and let's go sound effects volume
okay we have our nice Cent constant and
down here when we set the float let's
use this string and save the volume okay
so that is going to set the float and
now technically Unity is going to
automatically save the player PRS
basically there are only problems if
Unity somehow crashes in between when
you call set float and when it actually
saves but if you want to prevent that
from happening you can just go and tell
it to save manually just like that that
will definitely save it and now we just
need to handle loading so here on a wake
when we have this let's go into the play
prefs and let's use get float let's pass
in the same key so this one takes a key
and default value so let's defa it to 1f
basically the default value is used if
there's no save data on displayer press
on this key so the first time we run
it's actually going to use this default
and this one is going to return the
saved value so let's just set it on the
volume okay so that's it that's all it
takes to save some basic data now let's
do the exact same thing on music so over
here on the Music Manager let's first
Define our private con string for the
player prefs music volume and this is
going to be the Music
Volume okay we have our string and then
down here when to change the volume
player
presss and let's set the float on this
key and let's pass in the Music Volume
okay and then let's go into player preps
and actually save it and now appear on
awake let's grab the
volume and it's going to be going to the
player preface in order to get the float
on this
key and default value is 3F however over
here on the music again we are not
spawning the sound afterwards the sound
starts playing right away so let's make
sure to set the audio Source volume to
the one we grab from there okay that's
it so like this it should be working so
let's test so here we are and the music
is playing let's pause going to the
options let's bring the music completely
down so let's mute the music okay the
music is gone and sound effects let's
put it on five now let's stop playing
and now play again and go into the menu
options and Y there you go the data was
indeed saved and the music music is
indeed muted all right awesome so here
we have some basic data being saved and
also just quick note related to saving
for this simple game the sessions are
pretty quick so I didn't include any
kind of save system for the actual game
data but if you want to know how to do
that I also have video covering that
topic okay so with that we have our
options window working the volume
sliders work perfectly the next thing we
need to add to our options is some key
rebinding so let's do that in the next
lecture hello and welcome I'm your Cod
mon in this lecture we're going to add
key rebinding to our options menu so
here we already have this nice options
menu we can modify the volume of the
sound effects or the music next let's
handle key rebinding okay so first let's
build the elements over here on the UI
so let's create a bunch more buttons but
before that let's actually make some
text on the side and buttons in the
middle so let's create a brand new UI
text call this move up text let's put it
on the same size as the other one so
these got a font of 24 let's put it the
same thing font of 24 width and height
let's put both of these on zero and down
here anchor it to the left okay down the
middle and with no wrapping okay so then
over here this is going to be the move
up action so we have move up then we
have the move down move left move right
then we have the interact the interact
alternate and finally the pause so these
are all of our actions so let's just
make all of these so rename this so this
one is the move down then this one over
here is the move left this one is the
move right this one is the interact text
then the interact alternate text and
finally the pause text now let's just
modify the text on these so that's the
pause that one is the interact
alt then this one is the interact then
we've got the move right then over here
the move left and finally we have the
move down okay so those are our labels
for our controls now let's just make
buttons over here on the right side so
let's duplicate one of these buttons
let's put it over here and put it on
some like 50 by 50 so this is going to
be the move up button and inside on the
text this is going to be pretty much
just a w okay so we have the move up
then we're going to have the move down
move left move right the interact the
interact alternate and the pause so we
just need a a bit more space so let's
move all of these up by quite a bit
let's also move the music and the sound
effects so move all of these like that
okay let's just name all these buttons
so this one is the second one so this
move
down then over here the move left then
the move right then the interact button
the interact alternate button and
finally the pause button
okay those are all the buttons let's
just position all the en labels exactly
where they should
be okay so here we have all of the
options all of our bindings now in code
let's grab references to all the buttons
and all the text inside the buttons so
over here inside the options U let's add
all of those so first of all for the
text we're going to have the move up
text then the down left right and so on
so let's just do all of these so down
then over here the left then the right
then the interact text the interact
alternate text and finally we have the
pause text and for the buttons let's go
up here make all the buttons so they
move up button then the move down
button then we have the move left button
then the move right button then we have
the interact button the interact
alternate button and finally the pause
button
okay so we have all of these references
over here in the editor let's just drag
them so let's make sure we drag them all
correctly so let's do it one by one so
the move up this is the text and
actually it's not that one so that's
already a mistake right there we want
the text from inside buttons so let's
pick up all of these text objects so
let's go into the options so text inside
the move up let's grab that one then
inside the move down let's grab that one
and the left and so on so definitely
make sure you grab the right ones okay
that's on text now for the button so
that you move up button then the move
down then the move left the move right
the interact interact alternate and
finally the pause button okay great and
just to verify that everything is
working let's give proper names to these
objects so the move up button
text okay so I've renamed all the
buttons so now over here it's much
easier to verify that we have the
correct references so the sound sound
music music and so on so definitely make
sure all of these are correct otherwise
you might go crazy when things start to
go a bit weird so make sure these are
all correct all right now let's begin by
updating the text inside over here so
let's go into our update visual so we go
into this set the text and now we need
to get the binding text for this binding
so for that let's make that function on
the game input over here let's just
comment this out then over here on the
game input script let's make a function
to get the bindings so technically we
could make something just to grab this
player input actions but again we don't
want the options UI to know what input
system we're using it should work
regardless of what input system so we
don't want the game input to return
anything of this type instead we want to
make a nice layer of abstraction so for
that let's make an enum to Define all of
our bindings so let's make a public
since we're going to access it enum call
it binding and over here let's add all
the bindings so we've got the move up
then we have the move down down the move
left the move right then we have the
interact the interact
alternate and finally dep pause so these
are all of the bindings now let's make a
function to return the binding text so
over here let's make a public we're
going to return a string let's just name
it get binding text and as a parameter
let's receive a
binding okay so now here let's just do a
switch switch on this binding and
basically just match up the enome to
whatever action we have so for example
let's begin with the interact since
these are the simplest ones so for this
one to get the bindings we first go
inside the player input actions then
let's go inside the player action map
then for the action so in this case the
interact and then inside we've got the
bindings this is an array of all the
bindings in our input map we defined all
of the keyboard bindings on index zero
later on we're going to add Gamepad
bindings but for now we're going to have
the keyboard always on index zero so
over here going to bindings access on
zero and let's just do a two string okay
so let's just return this and let's do a
default to return always this one just
like this okay so let's do a quick log
to see what this returns so let's do it
over here on the game input just a
debug.log go into there get the binding
text for the
interact okay so let's test and right
away yep we do see it working so the
interact and The Binding is on keyboard
SL e but we don't want all this text we
really just want to see the E thankfully
the input system has a really great
function for just that so instead of
calling the general two string let's
call two display string let's see and Y
this one does return just e key okay
great so this is the one that we want
let's do the same thing for all of the
other simple actions so we've got the
interact then we have the interact
alternate and we have the pause so these
are all the super symol ones so just
going to interact alternate grab the
binding on zero and for the pause
binding on zero okay so these are all
super simple now the more complex one is
the move it's more complex because you
can see all the others just have one
binding except for the move over here we
have a composite binding so that's
basically a binding which inside has
four separate bindings basically the way
that this works is that when you use a
composite binding all of these are added
to the array so this 2D Vector is going
to be on binding zero then the up is
going to be on binding 1 2 3 four and so
on then the arrow key this one is going
to be on five then we have 6 7 8 9 and
10 let's do a log just to verify so here
if we do one for the move up action for
this one let's go into the move and
let's print out just the binding zero
let's a regular two string let's see
what this returns so up here let's just
modify our log to say the move up okay
so let's see and yep index zero does
have the move to the vector and now if
we print the one on binding of one y yep
now this one does have the move on the
dou so like I said we can see that all
of these composits These are technically
inside that one but in terms of that
array it's just a flat array so this one
index zero 1 2 3 and four so that makes
it super simple to add over here so they
move up down left right and let's just
do all
these so we have all the bindings and
over here just one two 3 and
four and instead of two string let's
call the display string okay so the
binding text this is all set up so let's
go up here and get rid of our testing
code we can now call this from the
options so over here let's do exactly
that so when we update the visual let's
go into the game input let's access the
static instance let's get the binding
text and this one is going to be the
move up so that's it this one is going
to return a string let's write all of
them
okay here are all of them so let's see
and yep there they are all perfect WSC
EF Escape okay great so the visual is
working now let's handle the rebinding
so let's add a click event let's go into
the move up
button let's go into the on click let's
add a listener and for the listener over
here let's make a function on the game
input to rebind this binding so over
here on the game input let's say public
void rebind binding and and we receive a
binding now for rebinding I covered this
in detail in the dedicated input system
video first basically we need to disable
the action map so let's go into the
player input actions let's access the
player and disable it so we need to do
this first then we're going to need to
find the actions so player input actions
and for now let's go into the player and
let's just modify the move up action so
we're going to call the function perform
interactive
rebinding this one as you can see it
takes a binding index and if we remember
up here we saw that in order to modify
the move up it's on bindings index one
so let's modify the one on index one
okay so this is the function this
returns an object of this type a
rebinding operation this is a pretty
complex object where you can modify all
kinds of things add a bunch of
limitations and so on like for example
make a key not be able to be bound to
the mouse or something so there's tons
and tons of options you can play with
over here for the simple thing let's
just add an oncomplete listener so this
one takes in a callback and this will
will be called whenever the interactive
rebinding
completes so over here let's define a
Lambda so a call back and inside we have
this by the way over here this is the
same Lambda expression that we saw
previously so exactly the same thing as
this except when we have just one
parentheses we don't need to add them
okay so like this so then on this
callback we can see all kinds of things
like for example we can see the action
that we just rebound this is going going
to contain all the data on the rebind
operation so for example let's print out
the path so let's go into the action
let's go into the bindings on index one
and let's print out the path so let's do
a debug.log
and there's actually another one so
let's log the path and also the override
path these are two different things
let's see why in a bit we do this and
after we log we also need to reenable
the player action map so let's go into
the player input actions the player and
back enable this okay so we're only
going to need these settings on the
rebind action then we can just call
start in order to start the rebinding
process okay so this should work let's
just call this from the options UI so
over here we have the click let's go
into game input instance and let's
rebind The Binding and for this one is
the move
up okay with this let's test okay so
here if I click on the button and I
click on the T e and if there go it did
work so you can see that it print out
the regular path that is w and the
override path which is T so now if I
exit out of the options go back into the
game if I press W nope it does not move
but if I press T yep it does move
upwards okay great so we have
successfully rebound this one key now
here just one thing in previous versions
of the input system when doing a rebind
operation you need to manually dispose
of this call back otherwise it would
throw a memory error in the recent
version that I'm using here there's no
error so it seems perhaps it's no longer
needed to dispose of the comback
manually but still there's no harm doing
it just in case over here comb back.
dispose okay so with that the key
rebinding is working except we have two
issues the first one is that it's not
very clear that it's listening for an
input and the second one is that the
text options also does not update so
let's solve both those first let's set a
visual when waiting for a key press so
inside the game options UI let's create
an empty game object call this the press
to rebind
key let's stretch it out so put it on
zero on everything okay then inside
let's add a UI image let's put it in
black and once again let's stretch it
out okay now let's also add a simple
text and for text let's say press a key
to rebind as usual let's put the width
and height on zero put it in bold Center
down the middle with no wrapping
and increase the size by quite a bit
okay so that's our super basic window
now in the code we just want to show and
hide this so let's do that and let's
actually begin with this hidden by
default so let's disable this object so
here on the options UI let's add another
serialized field it's going to be a
transform for the press to rebind key
transform so you have this let's make
two show and hide
functions so we show press to rebind
key we just go into that one game object
set active this one into true and
another one where we set it to false so
just hide and set it to false okay
pretty simple let's make sure to hide
this over here on our start okay just
like that and for showing let's show it
when we actually rebind an action so
right in here but since we're going to
have tons of listeners to these events
let's actually make a nice separate
function to handle all the rebinding
logic so down here let's make a function
rebind
binding we receive a game input.
binding and then first we show The Press
rebind key and then let's go into game
input access the instance and tell them
to rebind the binding and pass in the
same binding okay so we have this and
now up here on the button event let's
just call in this function okay very
simple so this will work for actually
showing the window but now we need to
know when to hide it and for that let's
use something that we've used a few
times in this course but never directly
let's use a c delegate as usual I have a
dedicated video on them this is
basically how you can define a field or
a parameter of a type which can hold a
function it's another Super useful C
feature definitely watch that video to
learn all about it let's go here on the
game input and down here when we have
our rebind binding over here let's
receive a second parameter this one is
going to be of type action this is one
of the built in delegates it takes no
parameters and returns void so this one
is perfect for a simple callback just
like this one let's call it on action
rebound and we're going to trigger this
right here after we achieve the comback
so we get the comback let's trigger this
just like that and let's also get rid of
these testing logs we no longer need
them so just like this now back here on
the options UI so we've got that and for
the second parameter let's just pass in
the function to hide that window so hide
the Press rebind key that's it
again remember we're passing in the
function itself we're not calling it so
there's no parenthesis we're just
passing in the function itself okay so
with this let's test so here on the
options let's rebind the move W and
there you go it does show up the window
and now if I press the key y there you
go that one hides okay great so this is
working but over here the text is still
not updating so over here on the second
callback instead of just calling this
function we need to call this and then
also call the update visual function so
as usual let's use a simple Lambda
expression to do exactly both so let's
open and close the
parenthesis and we do exactly
this so we hide the press rebind and
then we update the visual okay that's it
let's test so here we are let's rebind
the move W press on the T key and there
you go it did rebind and it did update
all right great now let's just apply
this to all of the other bindings so
first up here on the buttons let's set
listeners to all the buttons so that's
the move left actually the move down
then the move left move right the
interact button the interact alternate
button and finally the pause button and
for the bindings this one is the pause
binding the interact alternate then the
interact then the move this one is the
right again make sure you don't make
mistakes here you call in the exact same
one so they move down okay so all of it
is correct here and now over here on the
player input let's do a switch on our
bind
so case move up we do something and now
we could write this code directly up
here and then make a move down and write
a bunch more code that would work but
that would be way too worthy so let's
write our code in a nice clean way
basically the only thing we need down
here is we need to know the actual
action we're going to rebind and we need
to know the action index so let's just
find up here exactly that so an input
action for the input action and then an
in for The Binding index okay and then
over here when we have the switch for
all of our bindings we just set those so
the input action in this case it's going
to be the player input actions player
and it's the move action and for The
Binding Index this one is on index one
then we're going to have the other moves
so the move down is going to be on index
two then left and right
these are on index three and four okay
so we have all these and now for the
other ones so for the interact this is
the interact action on binding zero then
we've got the interact alternate and the
pause so interact alternate and the
pause and this one is the pause action
and the interact alternate action and
all of them are in binding index of zero
okay so that's good so over here we are
assigning the input action in The
Binding index and also one thing we need
to make sure to always assign these
values so let's make sure to add a
default here just make sure it always
works okay great so now down here
instead of always accessing the move
let's access whatever is stored on the
input
action and for The Binding whatever it
is on The Binding index okay so now this
will work with all of our bindings so
here we are and let's try rebinding all
of them so let's put them over here on
the side so before the move up let's put
it on T down on G A on F then D on H for
the interact on y interact out on J and
for the Escape let's put it on E okay so
all these Keys have been rebound let's
just make sure they work so here I am
moving with these keys and yep it does
work go up here to interact and do the
alt interact and now the pause and Y
there you go everything works perfectly
all right awesome so everything worked
perfectly although again we have the
same issue as previously so all the keys
have been rebound so it's all correct
great however now if I stop playing and
now now if I play again and nope there's
the issue the rebinding was lost so just
like with the sound we also need to save
the new state now thankfully the new
input system has a function that makes
that super easy let's go down to where
we are rebinding things and when we
finish rebinding let's just go into the
player input actions and let's call this
function the save bindings overrides as
Json this one is going to return return
a Json string now if you don't know what
is Json go watch my quick video on it
basically it's a super easy to
understand and widely used file format
it's very easy to read and modify it's a
format where it sort of as just text so
let's look at what this says let's do a
debug. log over here after rebinding
something let's see so here if I rebind
one of these and if there you go there
we have our Json so the override
Bindings that overload the move on this
ID on this new path so basically we just
need to store this string somewhere and
just like we did with the sound let's
just store it in the player press
so first let's define our constant so
private constraint for the player preps
bindings and let's call this the input
bindings okay just like
this so then down here after we rebind
the key let's go into player prefs and
let's set a string on the player
preps bindings and we're going to save
the overrides as Json
and after we do let's just make sure the
player preps is correctly saved okay so
that saves it then let's go on awake to
load it so over here on awake let's load
that let's first do a quick test to see
if there's a save so if the player preps
if it has a key and if it has this
key if so then let's get it so the
player preps let's get the string on
this key that Returns the string and
we're going to use the string let's just
go to the player input actions and let's
call the function load binding overrides
from Json just like this and also let's
make sure we do this right after we
construct the object and before we
enable the action map okay so that's
really it let's test so here we are
let's rebind the move up to T okay it
rebound now stop playing now play again
and Y here it is still rebound to T all
right awesome okay so here we created a
really nice options menu where we can
modify the volume and rebind
the only issue that we still have is
that we can only navigate the menus with
the mouse so let's add support for menu
navigation with a controller in the next
lecture hello and welcome I'm your Cod
monkey in this lecture we're going to
set up full controller support for our
game including regular actions and menu
navigation okay so first let's just set
up the controller inputs I have an Xbox
Gamepad controller connected so let's
open up our player input actions and
over here we have all of our actions and
we already made the move one long time
ago so let's just add the bindings for
the other ones for example over here on
the interact let's add a brand new
binding let's go into the path and
listen and for interact I'm going to
press the a button and again here you
can specify just the a button on Xbox
controller or you can use the generic
South button which will mean a on an
Xbox or cross on a PlayStation or B on a
switch or anything else so let's go with
the generic one for the internal
alternate let's add a binding and for
this one I'm going to put it on the X on
the Xbox so the button West and for the
pause let's add let's listen and I'm
going to press the menu which is the
start button okay so these are the basic
inputs let's make sure they work and
thanks to this new input system we
really don't need to modify any code
let's just save this asset let's wait
for the compilation and then we can do a
test so here we are and yep I'm using my
controller to move now let's just wait
for the countdown and go up there and
pick up a cheese put it and slice some
cheese yep I can do that pick up a plate
and so on all right so everything works
let's also pause and yep that also works
okay great so everything works except
there are two issues with the game pad
especially one with the movement that I
only noticed just now the first issue
that we have is the dead zone right now
we don't have one so if I just slly
touch my Gamepad joystick there you go
it starts moving automatically in game
pad games you should always have some
kind of dead zone to prevent any kind of
joycon drift thankfully that is super
easy to solve let's just go into the
player input actions let's go into the
move find the left stick bind finding
and over here for the processors let's
add one and let's add a stake dead zone
so that's it pretty simple this
basically considers that inputs under
this minimum to be zero and above this
maximum to be one so if you have
joystick drift where when the joystick
is Idle it's always moving by say 01
then Direction this helps solve that
problem except in our case for our game
we're only using normalized inputs so
actually for our use case let's increase
the minimum by quite a bit I did some
testing and 05 Works quite great and the
max at default that is just fine okay so
that's it one problem solved let's just
go ahead save this ENT now the other
bigger issue that we have is if I
approach a counter and I try to look at
it it's really difficult it tries moving
left and right instead of actually
facing the counter that's because the
logic that we added a long time ago that
logic to help the character controller
feel better when moving on diagonals
against the counter that works great for
keyboard because it's digital so it's
either moving fully left fully right or
on the diagonals but it messes up the
controller which is analog on the player
movement if we are not moving perfectly
up or perfectly down then it's
considered a diagonal and on the game
pad it's really difficult to get a
perfect just up or just down input we're
always going to have a tiny bit of
either left or right so that's the issue
that we have here and thankfully the
solution is actually pretty simple let's
go over here onto our player script and
let's scroll down into the handle
movement function okay so we're doing a
can move using the regular move
Direction and if it doesn't work then
it's over here that we are attempting
only the X movement or only The Zed
movement and for doing that we made it
so we can move if there's nothing only
on the X and if we have any movement at
all on the X so if it is different from
zero basically the issue here is if the
move de. X is let's say 0.1 that is
still different from zero so it is still
going to trigger this logic so basically
let's just widen this Gap instead of
testing literally just different from
zero let's test if they move here. X if
it is under say minus5 F or if move thex
if it is bigger than plus5 F so instead
of being exactly just on zero we're only
going to consider diagonals if we are at
least moving 05 either left or right so
we just do this and same thing over here
except we just test for the Zed so the
move the. Z and the move the. Z okay so
like this it should feel much better on
the GamePad and still work exactly the
same on the keyboard so let's test so
here I am moving around and yep now it
is much easier to just stay around and
look straight at a counter
okay so that's great so I can pick up
and this is all much much easier and the
character is no longer just sliding left
and right non-stop okay that's great so
now that this is working let's set
support for rebinding our controller
bindings so over here on the game input
let's do it just like we did for the
keyboard so let's add a bunch more
bindings over here on the enum let's add
the GamePad interact then the GamePad
interact alternate and then the GamePad
pause okay so we have our bindings then
let's let's go down and add them to both
our functions so first the text and then
the bindings so over here on the text
let's copy pretty much this we're going
to have the GamePad interact then we're
going to have the other two so the
GamePad interact alternate and the
GamePad pa okay now for these bindings
we're going to use the same actions so
this one is the interact alternate and
over here we have the interact and over
here on the input actions we saw that we
added for all of them on index zero we
have the keyboard and on index one we
have all the game pads so over here
that's literally the only change for the
game pad let's go into bindings and
access the array on index one okay and
then over here on the rebind binding
it's going to be pretty much the exact
same thing so let's copy all these
change this to the game pad interact
then the GamePad interact alternate and
then the GamePad pause so all these all
we need to change is just buy an index
put them all on one okay so with that
all the code over here on the game input
is working perfectly now let's go over
here into options UI so we've got all of
our buttons so let's duplicate our
buttons let's just go into the interact
the pause and so on let's duplicate push
them to the right side okay and just
change the name so let's go into all of
them so this one is the game pad
interact button then the game pad
interact alternate and finally the
GamePad pass okay also inside let's also
rename these buttons just to make sure
the text works
great and let's also make sure that
these show up behind the press the
rebind key so let's drag them put them
above okay so that's our setup over here
on the options UI now let's go over here
on the options UI script and let's add
references to our buttons and to our
text objects so let's copy all of these
the game pad and add all these this is
the pause the interact and the interact
alternate and then down here the exact
same thing let's add all of
these okay like this now over here let's
drag all of our references so on the
options UI let's make sure to always
drag the correct things so the game pad
interact text the interact alternate
text and the pause button text and then
the buttons themselves so the pause
button interact alt and the interact
button again make sure you always drag
the correct references so check and
double check make sure everything is
correct okay then over here for our code
let's first handle the text over here so
the text for all of these
so the GamePad interact text then the
GamePad interact alternate text and
finally the GamePad pause text and we
just go the GamePad pause the GamePad
interact alternate and the GamePad
interact finally over here on the
buttons let's do the exact same thing so
game pad interact interact alternate and
the
pause okay so we added everything let's
do a test and see if everything is
working so over here let's pause pause
the game go into the options and for the
interact let's modify this one instead
of a let's put it on B and Y there you
go it did go so let's close let's resume
and now let's see so if I approach and I
press a nothing happens Press B and
there you go it doesn't interact okay
awesome so the rebinding is all working
perfectly except we have another obvious
issue I can pause with the GamePad
however now with this pause I cannot
click on any of those buttons and if I
go back to the main menu over here I
also cannot do anything with a
controller so let's solve that the first
step is on the event system object look
at how it shows us this warning
basically if we're using the new input
system we should be using a different
input Handler here thankfully this is
super easy we just need to click on this
button and yep that's it it
automatically sets it up now the way
that this works is by pre-selecting
buttons and in order to better see which
button is selected we should probably
add a more visible color let's go into
our pause window so for now let's hide
over here the options UI show the pause
window and we have these three buttons
let's select all of them and over here
on the right side on the button we can
see one option for the selected color so
instead of being white which is going to
be really difficult to see let's put
something really visible so let's say
like a bright green okay like this let's
do the same thing for all the buttons on
the options UI so let's show this one
and find all the buttons so we've got
all of these ones down here and these
three ones up here and let's do the same
thing so on the select Ed let's put it
all on a nice screen okay so all the
buttons have a nice selected color and
just like this if we test and if I pause
the game and right now nothing is
selected so right now I cannot do
anything with the controller however if
I press over here with the mouse on this
button and that let go whilst outside
the button yep look at that now that
button is selected so now as long as
that one is selected now if I move with
the mouse pad yep now I can navigate
through this menu and if I press on a
yep I can essentially click that button
so that's great basically all we need is
to make sure that we select a button as
soon as the pause menu shows up so let's
go over here on the game pause UI script
and then over here let's go into the
show function so when we show this
window when we do let's go into the
resume button and just call the select
function this will make it selected so
that's it and with this if we test and
now here with the game playing if I
pause whilst pressing the button on the
game pad and if there you go that one is
selected and now I can select any option
okay that's great so now it works fully
with just the game pad except now if I
go into options yep now you can see that
the button that is selected is still the
options one over there on the background
so let's also make sure to select a
button on the options as soon as the
options window shows up so over here on
the options UI let's go into our show
function and let's just select the sound
effects button and just call Select okay
let's test so here let's pause go into
options select any of there go that did
work okay great except we have another
issue as I move upward down over over
here on these buttons yep look that some
of them are a bit strange like for
example over here on a I'm moving up and
look at that it actually selected the
resume button behind it so as we are
moving upward and down we are actually
selecting buttons on both menus that's
very strange basically what is going on
is that since both windows are visible
the game is trying to guess which button
we want to select basically what is
happening is Unity is trying to use
automatic navigation if we select a
button so let's go for for example let's
hide the options and show just the game
pause okay let's select one of these
buttons and over there on the button
component we can see navigation is set
to automatic and we have a button to
visualize and if we click on that yep
over here we can see all kinds of arrows
for example we can see one over here on
the options that seems to be going to
some button in there that is going to be
the button that is showing over there so
if we move down from the options we're
going to end up over here on the
interact alt button now usually the
automatic navigation actually works very
well the only reason why we're having
problems is because we have both windows
active at once one solution to this is
to make the navigation explicit so let's
hide the options here and over here on
the resume on the navigation instead of
automatic let's put none and then let's
select explicit and if now we have all
four Fields so we can decide which
object get selected when we are here and
we move up down left or right so for
example here we would drag for the up
going up we could go into the main menu
so we would drag that button button and
going down we could drag the options
button so that's one solution just add
the explicit navigation to every single
button or another simpler solution is
let's leave this one on automatic and in
said we're just going to hide the pause
window whilst we are in the options
window so over here on the game pause UI
let's see over here we are showing the
options UI and when we do let's just
call hide on this so we are going to
hide this window when we show the
options and then on the options we want
to know when the options load so that we
can show this one again so over here on
the show function let's receive an
action this is what we're going to do
when we close the options let's call it
on close button
action and let's store it up here so
let's store a simple private action for
this okay so we have this and then down
here when we have our show function when
we have let's set this equals this we
store this and then we're just going to
run this action whenever we click on the
close button so let's go over here the
close button we've got that one let's
hide the options window and Trigger this
action so now we need is over here on
the game pause y let's pass in and
basically when we close the options UI
we want to show the pause UI okay so
let's test so here we are let's pause
the game okay let's go into options and
open it and if there you go it only
shows the options and over here moving
up or down works perfectly and moving
left and right also works perfectly and
now if I want to go back let's go into
close press it and there you go back
into the pause menu
all right awesome so everything is
working perfectly now the last thing we
need is over here on the main menu so
let's do the same thing first let's open
up the main menu scene let's save the
changes okay and over here let's begin
by doing the same thing on the event
system so let's replace it okay great
then let's go inside our canvas inside
main menu y let's select our buttons and
once again let's modify the select color
put it on nice green all right and since
over here we only have one menu we could
set it as selected over here on the main
menu y script that's one option or we
can just go into the event system and
over here on the event system there's a
field for the first selected so we can
just drag the play button and that will
automatically make it the selected one
so let's test and yep the play button
starts off as selected and I can move up
or down and if I press a button yep
there you go here I am playing the game
I can pause I can resume go back to the
main menu and so on all right awesome so
here we have the final thing we needed
to make our game fully playable with the
game pad thanks to how the input system
works and the menu automatic navigation
this was a pretty simple task with this
our game is pretty much completely done
however the next lecture is also one of
the most important lectures it's all
about polish so let's do that in the
next
lecture hello and welcome I'm your code
Mak in this lecture we're going to add
all kinds of small things to polish up
our game if you're a regular on this
channel then you've certainly heard me
say that polish is what separates good
games from great games so as you build
your own games make sure you don't
neglect polish here let's add a bunch of
small tiny things that will make a big
difference in the final game let's begin
with a very simple very visual one let's
just add some walls to our map and first
let's just hide our canvas so that it's
not blocking our view so again over here
we can use the buttons on the hierar key
to hide it okay great so let's add some
walls and for that let's create a brand
new 3D cube let's name this a wall let's
put it quite a bit thin so over here on
the scale for the X let's put it 0 25
then on the Y let's put three so
something like this then we modify the Z
so let's put it over here on the side
right next to the counters okay so
that's the wall let's just stretch it
out One Direction and the other one okay
so that's our basic wall now in included
project files there's a nice wall
material so let's go over here into
assets under materials and Y here does a
wall material so let's just drag it and
use this one and there you go it's just
a nice simple gradient this is also an
example of how you can take something
simple and make it a bit more
interesting if you look at this material
the base texture is really just this it
is literally just a simple vertical
gradient texture and then with a color
apply to it and looks pretty good okay
so this Dall let's put the wall on all
three sides so let's duplicate this so
just select and press control D
duplicate let's put one on the other
side so right there right next to the
counters okay and finally the one there
so contrl D to duplicate it let's push
it over there on the side and rotate at
90 and let's put it just like that
let's just scale it to get to that end
and to get to that end okay so we have
our nice walls but over here if we're
playing the game we can still see the
floor on the outside that looks a bit
ugly so let's fix that let's create
another object and let's create a 3D
object another Cube and for this Cube
let's put it over here on the side and
this one let's use the black material so
again in the included assets there's
this nice black material there you go
it's completely black nothing to it so
let's just use this as kind of a Hider
so let's just scale it quite a bit and
lift it
up okay so there it is a black material
right next to the wall and let's put
another one over here on the left side
and just like that can also put another
one on the back there even though I
don't think the camera can see that part
but still let's put it so just put it
like that and stretch it out okay that's
good by the way over here on the outside
it doesn't have to be perfect doesn't
have to perfectly match the camera is
never going to see that position so it
doesn't matter it only matters what the
camera can see and if we play like this
and if there you go now that looks quite
nice if we want over there we can get it
together just a little bit and we can
also move the camera forward a tiny bit
so over here on this one let's push it
just a little bit to the left okay and
now in the virtual camera let's play the
game and now here if we want we can push
it up a little bit something like this
so let's put it on this Zed so let's
copy it stop playing the game and let's
space it just like that okay so here's
our game and as you can see with just
this one tiny change just adding some
walls and a nice black outside just with
that it already looks so much better
than having some counters in wide open
space now for another simple one let's
add some nice particles while the player
is moving so in the included assets if
we go inside the prefab visuals over
here is a nice one for player moving
particles this one as you can see is a
particle system so let's drag it over
here into the world to see what it looks
like and as you can see by default it's
actually not spawning anything so I can
make sure that this one is running and
nope nothing is spawning so this is
actually set up in a really interesting
way is that instead of spawning
particles all the time it only emits
while moving so if I click to move this
object there you go the particles start
emitting and if I stop they stop so this
one is definitely perfect for a player
particle system do this set up is over
here on the emission on rate over time
it is set to zero so it doesn't spawn
anything automatically and it only has
over here the rate over distance so as
it moves it's going to spawn that number
of particles then the other settings
they're all pretty basic so there's some
gravity so they fall down just like the
stove counter particles the simulation
is over here on space so that as I move
the particles stay behind this is
important if I were to put that in local
and I move it around look at that this
is not what we want we want the
particles to essentially stay behind
instead of following this transform so
that is why this change is super
important if that one is set to whirl
and as I move yep the particle stay
behind okay great and the other
properties are all pretty basic for the
shape it's a cone pointing upwards then
for the size of our lifetime again just
a basic curve constantly becoming
smaller and smaller and down here on the
renderer instead of rendering a quad
it's actually rendering a mesh and it's
rendering a sphere mesh so that is just
so that it looks a little bit better I
think than just having a Sprite particle
okay so that's it so in order to make
this work really all we need is just
attach it to the player so let's find
the player make this object a child of
the player game object and again let's
also make sure to set all of this to
zero so the position on z0 and
zero and there you go just with this
that's all we need if we test here we
are sto and there are no particles and
as I start moving y there you go some
nice particles around the player okay
great next let's set a pretty obvious
one some kind of mini tutorial
we want a window to show the controls
and the goal of the game and wait for
the player input before we start the
countdown so for that let's go into our
canvas so let's show our canvas and
inside let's create an empty game object
call the tutorial UI let's drag this one
above the game pause window so that it
shows up behind it let's double click to
center it and let's press on the 2D
button to go into Tod mode okay let's
also hide those two windows so we can
actually see what we're doing so let's
hide all of these okay okay great now
this one first of all let's stretch it
to occupy everything so put zero on
everything okay then inside let's make a
UI image for our background once again
let's stretch it put it like this and
for this one instead of black like we've
used for all of our Windows let's
actually leave it on white put it on an
alpha something like half so something
like this just to be a bit different
then on top of this let's make another
image so let's make another UI image and
for this one instead of stretching let's
give it a size so let's put it on 1280
by 800 and for the image I created a
nice image for the tutorial if we go
inside the assets and then inside
textures yep here is a really nice
tutorial image so let's just go ahead
and use it so on the image let's drag it
all right there's our nice tutorial
image so this has a pretty basic
tutorial so the recipes come in from the
customers then the player has to prepare
the correct recipes and deliver them on
a plate on the delivery counter so just
a very basic tutorial and also over here
it's very important for the player to
know how to actually play the game so
there's some labels for the controls and
now we're going to dynamically add some
keys on top so let's do that let's
create an empty game object call this
the key let's put it on a size of 40x 40
okay now let's go inside and inside
let's make an image let's name this the
background and for the Sprite let's go
with the included Circle so default
Circle and for the size let's stretch it
to occupy everything put it on 0 0 0
okay there's our nice key so we have the
background and for the background let's
actually make it just a little bit
darker and let's also add just a nice
shadow so maybe 3 minus 3 and let's also
make a nice outline let's put it on 2x
two full Alpha so something like this
just to be a nice one maybe one by one
okay so that's just the visual and then
on top of it let's add a text
and this one essentially going to be the
key so let's put a key for the width and
height let's stretch it to match the
parent size okay then for the font here
let's go with maybe just say 20 let's
put it Center down the middle and also
let's put it on Bold okay so that's our
nice key indicator so this is our key
and we're going to have the movement so
the movement on the keyboard is going to
have four keys so let's just duplicate
so one two three and four Keys okay then
on the game pad that one is actually not
rebindable so let's put this one as
static so let's just go inside inside
the text and just say left stick and
let's lower the font size so that it
fits in there okay great then for some
more keys we're going to have the
interact action then the interact
alternate and finally the pause action
then let's just duplicate these to be on
the other side
okay so these are all of our keys now
instead of having key 1 two three this
is very difficult to understand so let's
give it some proper names so this is the
key move up then we have the key move
down then the key move left then the key
move right then this one is going to be
the key Gamepad move then we have the
key
interact the key interact
alternate the key pause this one is the
key Gamepad interact
alternate this one is the key Gamepad
interact and finally the key Gamepad
pause okay all of these and since we're
going to drag references to the text
objects let's also give those a name so
just copy drop it with text just like
this
okay so those are all the names so
everything is nice and organized okay
great now let's make the script to run
this so our tutorial UI let's go down
into our UI scripts create a brand new C
script for the tutorial UI and let's
attach the script okay so first let's
drag references to all of our keys we
only need the text so let's do a
serialized field of type text mesh Pro
yugui again never make the mistake
always use the Yugi one if for working
in the UI so the key move of text so
let's add all of
these okay these are all the references
then over here let's drag all and make
sure to drag the correct
ones okay let's double check to make
sure all the references are correct okay
they all seem correct all right great
and then over here let to pretty much
exactly the same thing that we did over
here on the options so we need EX only
this so let's copy this and over here
let's do just that let's do a private
void update
Visual and on this one let's do pretty
much this so the key move up text and on
this one you get binding text of move up
yep let's just do all the
others okay so those are all the
bindings that's great now let's let's go
over here on a private void start and on
start let's update our visual all right
and also let's make sure this update
just in case the player rebinds
something from the pause menu once the
tutorial is still visible so we just
need to know when that happen so let's
go over here onto the game input and
make a nice event so public event event
handler let's call it on binding
rebind okay we have this event and down
here when we have our rebind binding
function we do this we rebind and over
here let's invoke this
event okay just like this so then on Tut
y let's go into the game input the
instance on binding rebind let's listen
to this event and as always let's rename
this so let's put it game input okay
when this happens let's simply update
the visual okay that's it pretty simple
so let's test and see if the inputs are
correct
and if there it is we do see it correct
so we've got was we've got e to interact
F and over there we've got the game pad
okay great so all the buttons are
correct all that's left is the show and
hide so over here let's make the usual
two function so PR void show and a
private void hide and for these game
object set active and this one is going
to be into false and this one is going
to be true okay so for show up here on
start let's actually show it by default
even though it's actually already going
to be shown but still okay then for the
hide this one we want to hide when we
press the interact action however when
that happens we don't want just this
window to hide we want the kitchen game
manager to change the state so over here
on the kitchen game manager we currently
have the waiting to start and that one
actually has a timer so we count on a
timer and then we start whereas right
now we want it to be based on player
input so let's modify this to not be
based on timer so let's just get rid of
this time timer and now let's see all
these errors so I'm waiting to start we
are not going to count down any timers
instead let's listen to the game input
so game input let's listen to the on
interact action event and rename this to
the game input okay so when we have this
event when the player press the interact
action let's check if the state if this
one is on waiting to start if so then
let's modify the state so let's go into
State and we're going to go to the
countdown to start and let's trigger the
on state changed
event okay so that's it so we're only
going to change it on the player input
and nothing over here on the update then
for hiding the tutorial over here one
approach would be to listen to the
interact action and hide it but I think
it makes more sense for this to only
listen to the kitchen game manager state
that way if we wanted we could also
modify how this one changes the waiting
to start so let's listen to the state
over here on Tut one let's go into the
kitchen game manager the instance and
let's listen when the state
changes so here we are going to check if
the kitchen game manager instense if it
is on the countdown to start active so
if the countdown is active then we're
going to hide this okay so that should
do it now let's just do one more small
thing the delivery manager is currently
spawning a whilst we're still reading
the tutorial that's not not quite right
so let's go over here on the delivery
manager and right now this one starts
off at 0f and starts counting it down
right away instead of always doing it
like this let's just make sure that we
only spawn a recipe if the game is
playing so that's super simple over here
kitchen game manager instance is game
playing if so then we are going to spawn
a recipe and let's do the same thing on
the plates counter so let's go in the
plates counter so here we are on the
plates counter so we count on time
respon of PL but let's also make sure we
only spawn plates if the game is play
okay so with all of this let's test and
right away here we are we can see our
nice tutorial teaching the player how to
play okay great here we've got the
controls everything and we're currently
waiting for an interaction we can see
over there plates are not being spawned
and recipes are also not being spawned
but as soon as I press the E key and yep
there you go the countdown starts
playing and we've got everything else
and yep there you go the game starts and
after a while yep we've got plates and
we've got recipes all right awesome so
next let's polish the countdown visual
right now it's pretty basic it's just a
static number so let's add a nice
animation to it let's go inside the
canvas let's find the countdown UI so
the game start countdown okay so here it
is we just have some basic text now
let's go into the main game object and
let's add an animator
component then let's create a brand new
animator controller so let's create a
new down here an animated controller for
the countdown UI over there let's assign
this controller okay now let's open up
the animation window so window animation
open up the animation window okay let's
create an animation clip and over here
let's name this e countdown UI number
popup okay that's great now for making
the animation we want to basically make
it shake and also make it fade away so
one very useful component is the canvas
group so over here whil on the parent
let's attach a canvas group component
this one is a really useful component in
this case the main benefit is it lets us
easily animate the alpha so let's go
ahead enter on recording let's go into
the frame just before 1 second so let's
go into 60 frames because we are on 60
frames per second over here let's record
the normal key frame so let's modify the
scale a tiny bit just to record it and
let's reset it back to one okay just to
record the key frame then for rotation
let's rotate on Zed then put it on zero
again just to record the key frame okay
great so now we can go back into the
first frame and over here let's first
make it smaller so for the size let's
put it on 6 then let's rotate it to the
left so let's put 17 over here on this Z
rotation okay like that now let's move
up by just three frames so on frame
three over here let's make it quite a
lot bigger so let's put it on 1.3 and
let's rotate it to the opposite position
so minus 17 okay that's great that's a
nice start now let's put it on frame 10
and over here let's set the rotation to
zero and for the scale put it on 1.1
okay so now finally over here on frame
50 let's set the alpha on 2 one and then
on 1 second let's put the alpha on zero
okay so let's preview and Y there you go
a nice simple animation okay so that
looks great now we just need to play
this when the countdown happens so let's
stop recording let's go inside the
animator controller so here it is we've
got our number pop up and we basically
just want to play this animation
whenever we want so let's put it and
make a transition from the any state
onto the number popup on this transition
let's make sure we have no exit time and
for the settings over here for duration
let's put it on zero so that it's
instant okay great now obviously we need
a condition so on the parameters let's
create a brand new trigger call this the
number popup let's select that one and
Trigger it on this trigger okay great so
now for handling this logic here we have
the usual question so do we put this
visual Logic on the same UI script or do
we separate the animations from the UI
for me I find that the UI is usually
part of the visual so sometimes I like
to mix the two and sometimes I keep them
separate it really depends on a Case by
casee basis this visual is so simple and
so connected to the actual UI Logics
over here let's put them together so
let's open up the game start countdown
script and over here let's first grab
the animator so private animator for the
animator and on private void awake let's
just get the animator and just get
component of type animator okay so we
have the animator now we basically just
need to keep track down here where we're
modifying the text we're doing this on
every update but now we need to know
when this number changes so let's
basically just keep track of the current
number and the previous number so first
of all over here an in for the countdown
number and we're going to get this so
this is our countdown number and over
here we set it to string okay and we
just need to use a different function so
instead of Cl let's use cl2 n just to
convert the output into an integer okay
great so we have the countdown number
now we just need to know if this one is
different from the previous one so let's
go up here let's define a private ttin
for the previous countdown number then
when we go down here we've got the
current countdown number okay then just
check if it's
different if it is different from the
current countdown number if so then
let's update it so the previous one
becomes this one and now let's fire off
the animation so let's go into the
animator and set the trigger and again
we don't want to use strings so let's go
up to the top of the file make a private
con string let's call this the number
popup and number
popup okay so we have this and down here
we just set this trailer okay so that's
it pretty simple and just for fun let's
also add a nice sound effect so let's go
over here onto The Sound Manager and
let's make a function to play sound so
just like we did over here for the play
footstep sound let's make another one
for this one let's call it play
countdown sound and for this one let's
not receive a volume or position and we
just play let's say just the warning
sound so just that one on vector 3.0 and
with the current
volume okay so we have this function and
then down here just going to sound
manager instance and play the countdown
sound again we could refactor this code
to separate the uan logic from the
animation from the sound that is one
approach and it's actually one thing
that we're going to do in the next po
stage but this one is also a possible
thing since the UI is always so directly
connect to visuals okay so with this
let's test so here in the options let's
just make sure that we have our sound
effect effect so let's make sure they
are playing okay great now let's go
ahead and play and there you go we have
our nice countdown number and there you
go it looks great so it looks great and
sounds great all right awesome as you
can see just by adding a simple
animation and some simple sounds that
already look so much better now the next
thing we want to polish is on the stove
so let's go into our stove back into our
counters back into 3D and zoom in over
here okay let's also make sure that we
hide the canvas just so we can play
around this all right great so there's
our stove and for this we want to add
basically a warning icon and a nice
sound when the meat is about to burn so
let's go inside the stove counter pream
okay so now inside of this we already
have a nice generic progress bar UI like
I mentioned if you want to get some more
custom Behavior you can combine a
generic bar like this one with some
specific component so that's exactly
what we're going to do right now so over
here let's create a brand new canvas as
usual let's make it an World space
canvas for position let's put all of
this on zero let's just lift it up by a
bit so set it on a y of three okay great
then let's add our super useful look at
camera component and make it camera for
okay now inside let's go ahead create a
new image let's put it on a size of 0.5
by 0.5 okay just a nice square and for
the Sprite there's a nice warning image
in the assets so it's this one here we
have the warning okay great basically we
want to show this when the meter is
about to burn so let's make a scrim to
run this and on the canvas let's give it
a proper name so let's call this the
stove burn warning UI okay so let's make
the script to run this so we new C
script with the exact same name and over
here let's attach a script okay great so
now the first thing that we need is
obviously a reference to the stove so
let's make a seriz field private for the
stove counter for the stove
counter okay here in the editor let's
drag the reference of the so counter
okay great so now we basically just need
to know when the food is about to burn
and for that we can actually listen to
the on progress event so let's do a
private void start and on start let's go
into the stove counter and let's listen
into the on progress change event okay
so we have this one and basally we're
going to want to show this element so
let's find a b show we're going to want
to show this when the progress
normalized is above a certain amount so
let's define a float for the burn show
progress amount and let's say on .5 so
on this one we show it
except obviously we don't want it to be
shown when the food is just cooking we
only want it to show when it's about to
burn so that means we also need to check
the state on the stove counter so let's
make a function to check if we are in
the state that we want so we're here on
the stove counter let's go down to the
bottom and let's make a public bowl is
fried and over here we just return if
the state equals state. fried okay
that's great so now here we're going to
show if the progress is above 0.5 and
the stove counter is on the Fright State
all right so that's the logic that we
want then we just want to show our
height so let's make the usual functions
private void show any a private void
hide and just do game object set active
into either true or
false and over here if show then let's
call the show function and if not let's
call the Hide function and of course on
start let's start off as hidden okay
that's it let's test
just over here in the editor make sure
the reference is dragged and let's save
the prefab go outside head on play and
yep right away there's no element okay
great now I place it and yep while it's
cooking there's no element and now once
it's on the halfway point for burning
and if there you go we've got the nice
warning okay awesome so now that this is
working let's just add a nice animation
so once again let's go inside the stove
counter and on the burn warning UI let's
add an animated
controller then let's actually create
the animated controller let's create a
brand new animated controller for the
stove burn warning
UI then let's assign it okay and over
here on the animation window let's
create an
animation let's put it on the same
folder and call it for this one let's
say flash we're going to make it Flash
and then again for making it flash let's
use the same component that we used a
while ago so let's add a canvas group so
here it is now we can play around the
alpha so super useful although I should
say that at this point since we just
have a single image we could just record
a change over here on the alpha for the
image itself however one place where
this component is super useful is if you
have multiple images so if over here I
duplicate this one and I put it off to
the side if I change the alpha on one of
them then obviously it only affects that
one but if I go over here and I modify
the canvas group that changes the AL for
both them so if you have a group of
images then using the canvas group makes
it super simple so anyway so here we
have just our image let's go ahead and
record and let's say we start off on an
alpha of zero then after 10 frames go
into Alpha of one and after 20 frames
back into an alpha of zero okay so
that's it a super simple very basic
animation we don't even need analogic
since we just want this animation to
play non-stop so that's great that
should be working now let's add some
sound so for that we could make another
script but already on the stove counter
we already have a nice sound component
so let's open up this script the stove
counter sound so this is basically where
we're playing or stopping the sizzling
sound so over here we can just have had
the warning sound we're going to play
the sound just like we have over here
for the burning UI so let's actually
copy these same components and over here
let's paste it so for this one instead
of show let's give it a proper name so
play warning sound except it's not on
state change so let's actually listen to
the other one so stove counter on
progress changed let's listen to that
one and it's on that one that we use
this Okay so we've got that one and then
for playing the warning sound we're
going to want to basically play it every
certain amount of time so let's make
over here a private void update and on
update let's just Define a private float
for the warning sound
timer and so down here we just count it
down as usual time. Delta time and if
this one is under
zero if so then let's reset it so Define
a certain
maximum let's say 10 times or maybe just
five times per second that should be
good so we have this but obviously we
only want this to run if we should be
playing the warning sound so let's
actually save this one up here so
private ball for the play the warning
sound and then we set it on this one and
down here let's just go and we're only
going to run this if play the warning
sound then we're going to run our timer
logic all right and then over here all
we need is to play that warning sound so
let's actually go into The Sound Manager
and just like we had the countdown sound
let's add another one so let's say the
play warning sound and for this one
let's receive a vector 3 three for the
position and we're going to play the
warning sound on this position so now
over here on the stove counter let's go
into The Sound Manager the instense and
let's play the warning sound and pass in
the stove. transform. position okay that
should do it so we now should have a
nice warning sound and over here we
should have a nice animation on the burn
warning UI so let's see both those okay
so let's pick up some meat and drop it
and right now it's cooking okay great
and once it gets the halfway point give
the there we go now we have a nice
warning sound all right awesome let's
just add one more tiny thing let's make
the bar itself also flesh red when we're
about to burn so once again let's go
inside the stove counter and on the
progress bar UI let's add a nice
animator and let's go ahead and make one
so let's create a new animator
controller for the stove burn flashing
bar let's go ahead and assign so it's
the one on the progress bar let's add
the stove burn flashing bar then on this
one let's create new animation let's go
inside the assets animations let's make
one and just call it idle for this one
we're going to want the exact same color
as the normal color so let's go into the
bar and set the color just save a key
frame over there okay so that's what we
want now let's make another animation so
let's stop recording and let's actually
duplicate this one so duplicate it and
for this one name it flash now of course
we need to add it to the animated
controller so let's go over here and
drag it on top okay now for the
animation let's select the FL Flash and
for this one let's go ahead click on
record let's start off on this one and
after a few frames so let's say maybe
after 10 frames let's Flash in red and
after 20 frames let's copy paste the
same frame okay so that's our nice
flashing bar now let's just set it up so
let's go into the animator and over here
we're going to have a transition from
that to flash and from flash back now
all we need of course is an animator to
control this so let's make a new
animator parameter let's make it a
bullan and call it is flashing and again
make sure to be careful with can't
sensitive okay so from idle into flash
let's go ahead remove the exit time for
duration make it instant so zero and for
the conditions when that one is true
okay great and for going back once again
same thing so instant and let's make the
condition when it's false okay that's it
super simple now let's make a script to
run this so let's go ahead create a
brandy sharp script for the stove burn
flashing bar UI let's go ahead and add
it to the bar so that's see flashing
baru okay over here let's do pretty much
the same thing that we did on the other
one so let's go over here onto the stove
burn warning UI let's actually copy
exactly this so let's go on this one and
paste this one then back here in the
editor let's drag the reference to the
self counter and over here logic is
going to be very very similar so the
only difference is we have an anator so
the animator and we're going to grab it
on private void awake animator get
component of type
animator so we have the animator then
let's let's define the parameter so
private con string for the is
flashing and let's set it is flashing
okay we have our parameter and now down
here instead of showing and hiding let's
just go into the animator in order to
set a bow and the bow will be the is
flashing and let's set it based on show
so either we show or hide and we
actually don't need these functions and
by default of course let's leave it on
false okay so that's it super simple
let's test
just make sure to save the prefab and
hit on play okay let's go ahead and cook
so let's pick it up and drop it all
right so it's cooking let's wait for it
to be burning and as soon as it gets
there yep there you go we've got a nice
warning a nice flashing bar and a nice
sound effect so all three warnings
making ourselves much more polished all
right awesome now just for balancing
let's play around the timers so let's go
into our script M objects on the frying
recipe so let's make this one Take 5
seconds then then on the burning recipe
for this one let's make it take six and
finally let's also add another stove so
let's take our stove counter duplicate
the prefab let's put it over here so
rotate it to the side let's get rid of
this one and put this one right in there
so on 7.5 0 and minus one all right so
we now have two stoves I can put one
cooking put another one and I can start
cutting down some cheese start cutting
and before they start to burn let's
actually here there you go that one is
about to burn burn so let's pick it up
quickly and that one is actually going
to burn but I got it okay great all
right awesome everything's working great
now for one more polish element let's
make a nice visual when we deliver
either a correct or incorrect recipe I
think it would look good as a world
canvas on top of the delivery counter so
let's do that let's over here find
delivery counter let's go inside the
prefab and now in here let's create a
new UI canvas let's name this the
delivery result UI and as usual let's
make this a world space canvas so put it
on world space and for the position
let's actually lift it up and then we're
going to make it look at the camera but
just like this it might actually go
inside the wall so let's put it over
here to the side a little bit so let's
put it on this position so on the X of
minus 1.6 on a y of three and on a zed
of 1.2 okay that's the position so right
there that is going to be looking at the
camera now inside let's create a new UI
image it's going to be our background
and for the size the width and height
let's put it on 2.2
x.9 okay that's our background for the
color let's tint it in a nice green so
let's put it something like this then
let's also add a nice outline let's put
it on full Alpha and for the size let's
put it on
0.1.1 then let's also add a nice shadow
component for this one leave it on half
Alpha and let's put it on0 2 and minus
point2 okay so that's a nice visual now
on top of it let's create create a new
UI text let's call it the message text
and for the message we're going to say
something like delivery and then
underneath success let's put it on a
width and height of zero let's put it on
a super tiny font so let's say just 0 25
let's put it in bold and put it down
Center and get rid of wrapping okay
that's it let's just push it a little
bit on the left side so on minus. 32 on
the X okay and now next to it let's make
another UI image for this one call it
the icon image let's put it with a size
of 0.5 by .5 and put it over to the
right side so an X of 7 okay and now for
the spres including in the asset are two
Nice Sprites so there's a nice cross for
when we get it wrong and there's a nice
tick okay so that's the setup that we
want now on the delivery result UI let's
go ahead add our look at camera
component and for this one let's go
different so instead of the camera
forward let's go ahead with the look at
inverting so there it is this is our
setup now let's make the script run this
so let's go ahead create a new UI new C
script for delivery result UI let's
attach the script and open okay so now
here let's make serialized fields for
our elements so a serialized field first
of all for the background image and this
is actually going to be of Type image
image inside Unity engine dii okay our
background image then we're going to
have another one for the icon image and
we're going to have another one this one
is a text mesh Pro yugui for the message
text okay let's save okay so let's drag
the references to the background the
message text and the icon image okay
great now over here let's listen when a
delivery is delivered so let's make a
private vo start let's go into the
delivery manager the instance and we
have all of our nice events so you've
got a success and a fail so let's listen
into both them so both the success and
on the recipe failed let's listen to all
these and as always let's write goodl
code and rename this so delivery manager
on recipe success and for this one is
the on recipe
failed okay we have both of our events
so over here it's actually going to be
very simple we just want to play around
the text the icon and the background
color so for example when we fail let's
go and we want to set the background
image to about a red so for defining the
color let's actually go up here and
Define a color for the success color and
we're going to have another one for the
fail color and then for the Sprites
let's also have that so a Sprite for the
success Sprite and another one for the
fail Sprite okay those are all the
elements so over here in the editor
let's just set them so for the success
color let's actually use the exact same
color by the way here's a quick tip if
you go up to a field for example like
this one on the color you can right
click and copy and then go into delivery
results and over here right click and
paste there you go the perfect color
then for the failed color let's go with
the red maybe a bit darker and also
importantly make sure you set the the
alpha to fall okay so we have a red nice
like that okay then the success Sprite
this one is going to be the tech and for
the fail this one is going to be the
cross okay those are all of our elements
so now over here when we fail let's go
into the background image and set the
color and let's put the fail color then
for the icon image let's set the Sprite
to the fail
Sprite and for the message text let's
set this one for delivery and then
failed by the way this backwards sln
this means a new line so we're here to
let's just set the text on this one so
it essentially means that it will write
delivery then new line and then fail
thenne just make sure you're using the
backwards slash and not the forward
slash so use the backwards one there you
go there's a new line okay so that's the
on recipe failed and now on the recipe
success let's use the success color the
success Sprite and over here delivery
success okay so that's great that should
be working now just one more visual
thing let's add a nice animation
so just like we did previously let's go
over here over here let's add an
animator
component let's create an animation for
this one for delivery result UI so let's
go up here create a brand new animated
controller for this and let's go ahead
and assign it so delivery result UI all
right now let's make an animation so
this delivery result UI let's call just
popup and for this one let's do just
like we did for the numbers so let's
scale and rotate it however if we rotate
that's actually not going to work that
is because because we have the unlooked
camera and this one is already going to
be setting the rotation so we would end
up with this script fting the animator
for the rotation so that would mess
things up however one nice and simple
solution to this basically we just put
this inside another game object so let's
create a new game object and let's put
it inside let's an mty game object for
delivery result you want then look at
camera so we have this one now the
reason why I created it inside is that
so over here we can set everything to
zero and now with that one all on zero
we can go ahead and drag this outside of
this object and there you go that one
keeps the exact same settings and now on
this one we can add the unlock at camera
component and set it up just like we had
so the UN look at inverting and now on
this one we're going to make a child of
that one and there you go now everything
is on zero exactly as it should be and
on this one we can get rid of the UNL at
camera and now we can indeed play around
the rotation so for the animation let's
just go ahead and set it so for this one
let's go up to 1 second and let's record
a key frame on a scale of one and on a
rotation of zero then let's go back into
the beginning and for this one let's
scale it backwards so maybe something
like this maybe a 15 let's put it quite
a bit smaller then let's go up by three
frames let's put that one on minus5 so
rotation on the other side and put it
quite a bit bigger and then on frame 10
put it on say
1.1 with a rotation of zero just like
that so there you go there's a nice
popup and for the alpha let's also go
over here into the 50 and let's just add
the canvas group let's set this one over
here is on one and then we scroll it
down to zero okay so that's our nice
animation let's stop recording let's
open up the animated controller and over
here let's make our nice animations
transition so transition from any state
to that one let's make it based on a
trigger let's call it just popup and for
this one this has no exit time duration
of zero and let's go when the condition
when we have this trigger
okay so that's it although one thing by
default this animation is going to Loop
so let's just go ahead we can select the
animation and over here let's just
untake Loop time so that way the
animation will not Loop okay so that's
great now let's go into the script and
over here let's get our animator so
private animator animator private void
awake let's get the animator just get
component of type
animator and let's define over here the
private con string for the popup
so we have this and then when we have
either fail or success let's just go
into the end
met and let's set the trigger for our
popup both up here and over here now we
just have obviously one issue which is
that it starts off as visible we don't
want that so over here we can just do
game object set active into false in
order to hide it and when we get either
of these let's set it both to
true then then afterwards the animation
will make it invisible so it will still
be active but it won be invisible so
that's fine so just with this everything
should be working as we want so let's
test let's just make sure to save it and
go back okay so here we are let's try
delivering an incorrect plate and there
you go got a delivery fail okay great
now let's try delivering a correct one
so someone wants a cheeseburger so let's
cook it slice some cheese let's get some
bread so bread cheese and pick up the
burger and the liver and there you go a
nice delivery success all right awesome
okay so with these handful of changes
you can already see how we made quite a
big difference in our game we didn't do
anything to change any core mechanics we
just made what was already there pop out
we added a nice visual boundary to make
the map look nice we added some nice
particles when the character is moving
then we added a nice tutorial in
controls right as the game starts we
also added a bunch of effects on the
stove so it flashes has a warning and
some sound and lastly we also added a
nice popup when delivery is delivered
whether correctly or incorrectly now of
course we can always keep polishing the
game until Infinity there's always more
small things you can add to polish the
game just a little bit more but at this
point I'm very happy with what the game
looks like so after all this work let's
go into the next lecture where we're
going to play our game from start to
finish and see what we've
done hello and welcome I'm your kod Maki
in this lecture we're going to look at
all the work that we've done and have
some fun playing the finnal game okay so
here we are in our nice starting main
menu it's simple but it works actually
think it looks pretty good so we have
our our main menu working and we also
have the loading system that we made so
as soon as I click on Play There You Go
loads the loading scene and here we are
on the game scene so we start off with
our really nice tutorial window and down
here we have the controls of course all
of these are Dynamic so depending on if
the player rebinds or something this one
is going to update so we can look at
this window for as long as we want the
game is paused in the background so it's
on a paused game State then whenever
we're ready we can interact so again
that's the game input class listening to
the input and again all the code in here
is is really nice and clean so when we
press the interact key the tutorial
isn't directly listening to that but
rather the general kitchen game manager
that main State machine is the one
listening to the input and this one is
listening to that state so all our logic
is very well organized all of the
elements only listen to the things that
make sense to them so anyways here we
have tutorial let's interact and there
you go we've got our nice game start
countdown some really nice animation
really nice sound and yep here we are
then we've got our clock showing the
game time and on the left side we can
see our recipe
once again all of the elements they're
all Dynamic they're all spawn randomly
and the icons for all of the recipes
they're also all Dynamic so over here we
have the character control that we built
we have the collisions that we
implemented and of course we have the
ray cast testing for interaction so we
can identify all the objects in front
let's begin delivering some recipes so
for example we need to cook some meat so
let's go ahead put it on the stove so
here is the really nice State machine
that we built so we've got all the
various States we've got the visual
completely separated from the logic so
everything is really nice and of course
here we have the nice burning elements
that we added in the Polish lecture so
that one is burned so let's go ahead and
use the trash bin to get rid of that so
let's go ahead cook another one and
let's make a cheeseburger so let's put
some cheese let's listen to the alt
interaction key and we can slice the
cheese we can pick up the meat pick up
the cheese then also pick up some bread
and deliver the recipe and there you go
our nice polished visual all right
awesome so here you can already see
everything that we've built the
character the physics the logic the put
all of the UI elements all of the world
UI elements all of the various counters
and how they are all prefi variants all
of the plates the separation between the
visuals and logic separation between the
sounds and logic all the Polish elements
that we made over there the nice Shad
graph that we made then of course all of
the basic things that a lot of tutorials
won't teach you like for example how to
make a pause menu how to make the
options how to modify the Sound and
Music Volume how to rebind the Keys and
so on so with all that here throughout
this course we'll learn how to make a
really nice game with lots of
interesting interactions which you can
now apply to any kind of game any kind
of genre you want so like I mentioned in
the very beginning you can take pretty
much what you made here which is really
just a character controller and a bunch
of interesting interactions you can take
everything that you've learned here and
make something on a Sci-Fi space so like
for example make something like amongus
you can make something like FTL or
perhaps make some kind of survival
crafting game so of the interactions you
would have like resource nodes in the
world then you can interact to GA those
resources so with that that you could
build something like rust or Minecraft
or Don't Starve so hopefully in this
course you'll learn a ton that you can
now apply to your own custom original
projects and if you've made this far
then congratulations let's go into the
next lecture where I'll will give you my
closing
thoughts hello and welcome I'm your code
monkey and congratulations you have
completed this course awesome seriously
congrats looking at the stats on my
courses very few people stick with it
until the very end so if you're hearing
this then that's excellent you're on the
top 10% it means you are serious about
learning game development and I
generally hope this course has helped
you on your own Game Dev Journey
throughout this course you'll learn
about the basics of unity and C you'll
learn how to make a character controller
how to do a physics raycast and use that
for both Collision detection and
identifying objects to interact with you
learn about C interface and events two
extremely useful C features you learn
about Script Mod objects how to use the
new input system Shad graph and tons
tons more and the most important thing
of all you'll learn how to build a
relatively Lex game while writing good
clean code I really hope that's the main
takeaway you learn from this course
learning how to write better high
quality code learning how to refactor
how to keep the visuals and logic
separate keep the uid coup from logic
learning all those things has now made
you a 10 times better developer than
when you started so I really hope you
enjoyed learning all that let me know in
the comments what was the most important
thing you learn throughout this course I
really hope this was very fun and very
educational if you enjoyed my teaching
style check out my other courses I
really think the turn-based strategy
course would be excellent for you right
now it Dives even deeper into some
Advanced topics and since you've watched
this entire course all the way you now
have all the knowledge needed to follow
that course it will help you really
solidify all the knowledge you gained
especially everything related to writing
good high quality clean code and since
you use Unity check out my ultimate
unity overview course it covers lots of
tools and features of the engine so you
can really use all the tools that you're
disposal to make any game you can think
of alternatively if you like visual
scripting I have course on that or learn
how to make a really nice Builder
Defender game and definitely make sure
to wish list my upcoming steam game
Total War Liberation I will be posting
Dev vogs and in those you will see how
the code that I use in my own steam game
is on the same level of quality as what
you learned in this course okay so
that's it for me this course was a ton
of work so I generally hope it helped
you a ton on your Game Dev Journey thank
you so much for watching and I'll see
you next time